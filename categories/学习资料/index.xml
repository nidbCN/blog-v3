<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学习资料 on Gaein nidb 的博客</title><link>https://blog.gaein.cn/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</link><description>Recent content in 学习资料 on Gaein nidb 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 11 Jun 2021 19:39:59 +0800</lastBuildDate><atom:link href="https://blog.gaein.cn/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><item><title>C# 中集合和 LINQ 的排序</title><link>https://blog.gaein.cn/passages/csharp-orderby-customed-comparer/</link><pubDate>Fri, 11 Jun 2021 19:39:59 +0800</pubDate><guid>https://blog.gaein.cn/passages/csharp-orderby-customed-comparer/</guid><description>&lt;h2 id="集合的排序-sort-方法">集合的排序—— &lt;code>Sort&lt;/code> 方法
&lt;/h2>&lt;p>&lt;code>Array&lt;/code> 类提供了 &lt;code>Sort&lt;/code> 静态方法，使用快排算法对集合中的元素进行排序。
&lt;code>List&amp;lt;T&amp;gt;&lt;/code> 泛型类提供了 &lt;code>Sort&lt;/code> 方法，使用快排。&lt;/p>
&lt;h3 id="不使用自定义的排序">不使用自定义的排序
&lt;/h3>&lt;blockquote>
&lt;p>注意：使用无参数重载的 &lt;code>Sort&lt;/code> 方法，需要实现 &lt;code>IComparable&lt;/code> 接口。简单类型 &lt;code>System.String&lt;/code> 和 &lt;code>System.Int32&lt;/code> 等实现 &lt;code>IComparable&lt;/code> 接口，所以可以对包含这些类型的元素的数组进行排序。&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="nn">System&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="nn">System.Linq&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToList&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Sort&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">foreach&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">var&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">$&amp;#34;{item} &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">);.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">foreach&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">var&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">$&amp;#34;{item} &amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">10&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">10&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="自定义规则的排序">自定义规则的排序
&lt;/h3>&lt;h4 id="传入比较器实例">传入比较器实例
&lt;/h4>&lt;p>&lt;code>Array&lt;/code> 和 &lt;code>List&amp;lt;T&amp;gt;&lt;/code> 泛型类的 &lt;code>Sort&lt;/code> 方法都有接受实现 &lt;code>IComparer&lt;/code> 接口的类的实例对象的重载。&lt;/p>
&lt;h5 id="显示定义比较器类">显示定义比较器类
&lt;/h5>&lt;p>定义类继承于 &lt;code>Comparer&amp;lt;T&amp;gt;&lt;/code> 泛型类，避免拆箱装箱的额外开销，并且保证类型安全，并且实现 &lt;code>Compare(T, T)&lt;/code> 方法：&lt;/p>
&lt;blockquote>
&lt;p>注意：也可以继承于 &lt;code>IComparer&lt;/code> 和 &lt;code>IComparer&amp;lt;T&amp;gt;&lt;/code> 接口，但是这不是Microsoft 建议的做法：&lt;br>
“建议从 Comparer&lt;T> 类派生，而不是实现 IComparer&lt;T> 接口，因为 Comparer&lt;T> 该类提供方法的显式接口实现 IComparer.Compare 和 Default 获取对象的默认比较器的属性。”&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">MyComparer&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Comparer&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">override&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">Compare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">xPositive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">yPositive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">xPositive&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">CompareTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">yPositive&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>返回值的规则为：&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>x&lt;/code> 应该在 &lt;code>y&lt;/code> 的 &lt;strong>前面&lt;/strong> 的时候（也就是 &lt;code>x&lt;/code> &lt;strong>小于&lt;/strong> &lt;code>y&lt;/code>），返回小于0的数字（-1）&lt;/li>
&lt;li>当 &lt;code>x&lt;/code> 应该在 &lt;code>y&lt;/code> 的 &lt;strong>后面&lt;/strong> 的时候（也就是 &lt;code>x&lt;/code> &lt;strong>大于&lt;/strong> &lt;code>y&lt;/code>），返回大于0的数字（1）&lt;/li>
&lt;li>当 &lt;code>null&lt;/code> 参与比较时不应该引发异常，且为 &lt;code>null&lt;/code> 的对象应在其它对象 &lt;strong>前面&lt;/strong>（也就是说 &lt;strong>小于&lt;/strong> 任何其它对象）&lt;/li>
&lt;/ul>
&lt;h6 id="另请参阅">另请参阅：
&lt;/h6>&lt;p>&lt;a class="link" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.icomparer?view=net-5.0" target="_blank" rel="noopener"
>IComparer 接口 (System.Collections) | Microsoft Docs&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icomparer-1?view=net-5.0" target="_blank" rel="noopener"
>IComparer&lt;T> 接口 (System.Collections.Generic) | Microsoft Docs&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.comparer-1?view=net-5.0" target="_blank" rel="noopener"
>Comparer&lt;T> 类 (System.Collections.Generic) | Microsoft Docs&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.comparer-1.compare?view=net-5.0" target="_blank" rel="noopener"
>&amp;ldquo;Comparer&lt;T>.Compare(T, T) 方法 (System.Collections.Generic) | Microsoft Docs&amp;rdquo;&lt;/a>&lt;/p>
&lt;h5 id="使用-comparertcreate-方法和匿名函数创建比较器">使用 &lt;code>Comparer&amp;lt;T&amp;gt;.Create&lt;/code> 方法和匿名函数创建比较器
&lt;/h5>&lt;p>&lt;code>Create&lt;/code> 方法用指定的比较创建一个比较器。&lt;/p>
&lt;p>该方法的参数是一个 &lt;code>Comparison&amp;lt;T&amp;gt;&lt;/code> 类型的委托。可以使用 lambda 表达式直接创建一个匿名函数委托。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">comparer&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Comparer&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">&amp;gt;.&lt;/span>&lt;span class="n">Create&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">CompareTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">comparer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者直接&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Comparer&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">&amp;gt;.&lt;/span>&lt;span class="n">Create&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">CompareTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关于 lambda 表达式可以看我的这篇笔记：&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note6-Delegates-lambda-Expressions-and-Events/" target="_blank" rel="noopener"
>CSharp的委托、lambda 表达式和事件 - CSharp笔记 —— 博客 | Gaein nidb 的网站&lt;/a>&lt;/p>
&lt;p>箭头前的 &lt;code>x&lt;/code> &lt;code>y&lt;/code> 为两个参数，类型为自动推断的int（如果编译器不能推断可以手动加上类型来指定），只有一个参数的时候可以省略箭头前面的括号。&lt;/p>
&lt;p>箭头后为表达式体，只有一行语句的时候可以在箭头后直接书写语句，该语句的返回值将作为匿名方法返回值。如果有多行语句，使用花括号框成代码块，并且使用 &lt;code>return&lt;/code> 关键字返回值。&lt;/p>
&lt;p>变量 &lt;code>comparer&lt;/code> 为 &lt;code>Comparer&amp;lt;int&amp;gt;&lt;/code> 的实例，作为参数传入 &lt;code>Array.Sort&lt;/code> 方法即可。&lt;/p>
&lt;h6 id="另请参阅-1">另请参阅：
&lt;/h6>&lt;p>&lt;a class="link" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.comparer-1?view=net-5.0" target="_blank" rel="noopener"
>Comparer&lt;T> 类 (System.Collections.Generic) | Microsoft Docs&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.comparer-1.create?view=net-5.0" target="_blank" rel="noopener"
>Comparer&lt;T>.Create(Comparison&lt;T>) 方法 (System.Collections.Generic) | Microsoft Docs&lt;/a>&lt;/p>
&lt;h4 id="传入委托的比较方法">传入委托的比较方法
&lt;/h4>&lt;p>&lt;code>Array&lt;/code> 类和 &lt;code>List&amp;lt;T&amp;gt;&lt;/code> 泛型类也都有 &lt;code>Comparison&amp;lt;T&amp;gt;&lt;/code> 类型参数的重载，所以可以直接使用 lambda 创建匿名函数传入 &lt;code>Sort&lt;/code> 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToList&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">CompareTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Sort&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">CompareTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>没错，把 &lt;code>Create&lt;/code> 方法的参数扔这里就好了（那我前面是什么废话）。&lt;/p>
&lt;h2 id="linq的排序-orderby-方法">LINQ的排序—— &lt;code>OrderBy&lt;/code> 方法
&lt;/h2>&lt;p>&lt;code>OrderBy&lt;/code> 方法用于升序排序，&lt;code>orderby&lt;/code> 子句会被编译器转换为对 OrderBy 方法的调用。&lt;/p>
&lt;h3 id="不使用自定义的排序-1">不使用自定义的排序
&lt;/h3>&lt;p>使用重载 &lt;code>OrderBy&amp;lt;TSource,TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource,TKey&amp;gt;)&lt;/code> 来使用默认的比较器进行升序排序：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="nn">System&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="nn">System.Linq&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">OrderBy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">ToList&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">ForEach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>输出为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">-2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="自定义规则的排序-1">自定义规则的排序
&lt;/h3>&lt;p>LINQ 的 &lt;code>OrderBy&lt;/code> 方法没有像 &lt;code>Array&lt;/code> 和 &lt;code>List&amp;lt;T&amp;gt;&lt;/code> 一样的传入 &lt;code>Comparison&amp;lt;T&amp;gt;&lt;/code> 类型委托的重载。它只提供了重载 &lt;code>OrderBy&amp;lt;TSource,TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource,TKey&amp;gt;, IComparer&amp;lt;TKey&amp;gt;)&lt;/code> 。因此，我们不能在参数表里传入 lambda 表达式创建匿名方法来比较。只能创建类并继承于 &lt;code>Comparer&amp;lt;T&amp;gt;&lt;/code> ，或者使用 &lt;code>Comparer&amp;lt;T&amp;gt;.Create&lt;/code> 方法并传入用于比较的匿名方法。&lt;/p>
&lt;p>当需要多次进行这种比较时推荐创建自定义的类，并且实例化一个对象多次使用。或者创建一个变量来存储 &lt;code>Comparer&amp;lt;T&amp;gt;.Create&lt;/code> 创建的对象。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">files&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DirectoryInfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Directory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetCurrentDirectory&lt;/span>&lt;span class="p">()).&lt;/span>&lt;span class="n">GetFiles&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">ToList&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">comparer&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MyComparer&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 使用创建的类的实例&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">listAfterSort1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">OrderBy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">comparer&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">ToList&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 使用 Comparer&amp;lt;T&amp;gt;.Create 传参委托的匿名函数创建&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">listAfterSort2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">OrderBy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Comparer&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;.&lt;/span>&lt;span class="n">Create&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">string&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Compare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">StringComparison&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Ordinal&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">MyComparer&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Comparer&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">override&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">Compare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Compare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">StringComparison&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Ordinal&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>注意：这种情况实际上是不需要自定义比较器的，为了演示才这么写的（因为我懒得想例子）&lt;/p>&lt;/blockquote></description></item><item><title>C#的运算符和类型强制转换 - C#笔记</title><link>https://blog.gaein.cn/passages/csharp-note4-operators-and-typecasts/</link><pubDate>Sat, 01 May 2021 20:42:20 +0800</pubDate><guid>https://blog.gaein.cn/passages/csharp-note4-operators-and-typecasts/</guid><description>&lt;h2 id="目录">目录
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note1-Basic/" target="_blank" rel="noopener"
>C#基础&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note2-OOP/" target="_blank" rel="noopener"
>C#面向对象&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note3-Generics-Type/" target="_blank" rel="noopener"
>C#泛型&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note4-Operators-and-TypeCasts/" target="_blank" rel="noopener"
>C#运算符和强制类型转换&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note5-Array/" target="_blank" rel="noopener"
>C#中数组的使用&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note6-Delegates-lambda-Expressions-and-Events/" target="_blank" rel="noopener"
>C#的委托、lambda 表达式和事件&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.gaein.cn/passages/CSharp-Note7-String-and-Regular/" target="_blank" rel="noopener"
>C#字符串和正则表达式&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="运算符和类型强制转换">运算符和类型强制转换
&lt;/h2>&lt;h3 id="6---运算符和类型强制转换">6 - 运算符和类型强制转换
&lt;/h3>&lt;h4 id="61---运算符和类型转换">6.1 - 运算符和类型转换
&lt;/h4>&lt;h4 id="62---运算符">6.2 - 运算符
&lt;/h4>&lt;p>CSharp的运算符类似于C++和Java的运算符，但有一些区别。&lt;/p>
&lt;p>除了常见的算数运算符、逻辑运算符、比较运算符和赋值运算符等，CSharp还有&lt;/p>
&lt;ul>
&lt;li>类型信息运算符 &lt;code>sizeof&lt;/code> 、 &lt;code>is&lt;/code> 、 &lt;code>typeof&lt;/code> 、 &lt;code>as&lt;/code>&lt;/li>
&lt;li>溢出异常控制运算符 &lt;code>checked&lt;/code> 、 &lt;code>unchecked&lt;/code>&lt;/li>
&lt;li>标识符的名称运算符 &lt;code>nameof()&lt;/code>&lt;/li>
&lt;li>空合并运算符 &lt;code>??&lt;/code>&lt;/li>
&lt;li>空值条件运算符 &lt;code>?.&lt;/code> 、 &lt;code>?[]&lt;/code>&lt;/li>
&lt;/ul>
&lt;h5 id="621---运算符的简化操作">6.2.1 - 运算符的简化操作
&lt;/h5>&lt;p>自增(&lt;code>++&lt;/code>)、自减(&lt;code>--&lt;/code>)以及一些合并赋值(+=)运算符。&lt;/p>
&lt;p>当自增/自减运算符用于较长的表达式内部时，把运算符放在前面(&lt;code>++x&lt;/code>)会在计算表达式之前递增 &lt;code>x&lt;/code> 。换而言之，在增加了 &lt;code>x&lt;/code> 的值后再带入表达式计算。而把运算符放在后面(&lt;code>x++&lt;/code>)则反之。&lt;/p>
&lt;p>看个例子就行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(++&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// The output is &amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">++);&lt;/span> &lt;span class="c1">// The output is &amp;#34;0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// The output is &amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看这三行输出。第一行是先把 &lt;code>x&lt;/code> 进行了自增，在 &lt;code>x&lt;/code> 传入 &lt;code>WriteLine&lt;/code> 方法前就是 &lt;code>1&lt;/code> 了。第二行代码是先将 &lt;code>x&lt;/code> 的值 &lt;code>0&lt;/code> 传给 &lt;code>WriteLine&lt;/code> 方法，再将 &lt;code>x&lt;/code> 的值自增为 &lt;code>1&lt;/code> 。因此第三行代码输出为 &lt;code>1&lt;/code>。&lt;/p>
&lt;h6 id="条件运算符">条件运算符
&lt;/h6>&lt;p>&lt;strong>适当&lt;/strong>的使用条件运算符可以使程序更简洁，比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// 获取数字为奇数或偶数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;param name=&amp;#34;input&amp;#34;&amp;gt;数字&amp;lt;/param&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;returns&amp;gt;字符串奇数或偶数&amp;lt;/returns&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">NumType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="s">&amp;#34;偶数&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;奇数&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 不使用条件运算符的版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">NumType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;偶数&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;奇数&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用条件运算符明显短了很多。&lt;/p>
&lt;h6 id="checked-和-unchecked-运算符">&lt;code>checked&lt;/code> 和 &lt;code>unchecked&lt;/code> 运算符
&lt;/h6>&lt;p>如果把一个代码块标记为 &lt;code>checked&lt;/code> ，CLR就会执行溢出检查，如果发生了溢出就抛出 &lt;code>OverflowException&lt;/code> 异常。&lt;/p>
&lt;blockquote>
&lt;p>注意：unchecked 是默认行为。只有在 checked 标记的代码块里把几行不去检查的代码进行标记才使用。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>checked 有性能损耗&lt;/p>&lt;/blockquote>
&lt;h6 id="is-运算符">&lt;code>is&lt;/code> 运算符
&lt;/h6>&lt;p>&lt;code>is&lt;/code> 运算符可以检查对象是否与特定的类型兼容。短语“兼容”表示对象或者是该类型或者是派生自该类型，总之，可以安全的正常转换为该类型。&lt;/p>
&lt;p>CSharp7 扩展了具有类型匹配的 &lt;code>is&lt;/code> 运算符，可以在类型的右边声明变量。如果 &lt;code>is&lt;/code> 运算符返回 &lt;code>true&lt;/code> ，则该变量被赋值为转换后的引用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">PeopleReg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">object&lt;/span> &lt;span class="n">o&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">o&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">Person&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// convert success&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">$&amp;#34;Welcome {p.Name}&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;You are not a human!&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h6 id="as-运算符">&lt;code>as&lt;/code> 运算符
&lt;/h6>&lt;p>&lt;code>as&lt;/code> 运算符用于执行引用类型的强制转换。如果要转换的类型与指定的类型兼容，转换就会成功，否则赋值为 &lt;code>null&lt;/code> 。&lt;/p>
&lt;p>&lt;code>as&lt;/code> 运算符允许在一步中进行安全的类型转换，不需要先使用 &lt;code>is&lt;/code> 运算符测试类型，再执行转换。&lt;/p>
&lt;h6 id="sizeof-运算符">&lt;code>sizeof&lt;/code> 运算符
&lt;/h6>&lt;p>使用 &lt;code>sizeof&lt;/code> 运算符可以确定栈中值类型需要的长度（字节）。如果结构体只包含值类型，也可以使用 &lt;code>sizeof&lt;/code> 运算符和结构。&lt;/p>
&lt;p>如果对复杂类型（而非基本类型）使用 &lt;code>sizeof&lt;/code> 运算符，就要把代码放在 &lt;code>unsafe&lt;/code> 块中。&lt;/p>
&lt;h6 id="typeof-运算符">&lt;code>typeof&lt;/code> 运算符
&lt;/h6>&lt;p>&lt;code>typeof&lt;/code> 运算符返回一个表示特定类型的 &lt;code>System.Type&lt;/code> 对象。例如 &lt;code>typeof(string)&lt;/code> 返回表示 &lt;code>System.String&lt;/code> 类的对象。&lt;/p>
&lt;blockquote>
&lt;p>Tip：在使用反射技术动态的查找对象的相关信息时，这个运算符很有用。&lt;/p>&lt;/blockquote>
&lt;h6 id="nameof-运算符">&lt;code>nameof&lt;/code> 运算符
&lt;/h6>&lt;p>接受一个符号、属性或方法，并返回其名称。比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">LikeArticle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Guid&lt;/span> &lt;span class="n">aid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">aid&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArgumentNullException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nameof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">aid&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>还可以使用这个运算符得到属性的名称，也可以得到方法的名称。&lt;/p>
&lt;h6 id="索引运算符">索引运算符
&lt;/h6>&lt;p>类似于访问数组元素，索引运算符可以是任何类型（比如字典中使用的索引运算符）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">title&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">dict&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;title&amp;#34;&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h6 id="可空类型和运算符">可空类型和运算符
&lt;/h6>&lt;p>引用类型可以为空，每次都用 &lt;code>if&lt;/code> 来判断空太麻烦了，所以有了可空类型和运算符。&lt;/p>
&lt;p>可空的值类型使用 &lt;code>?&lt;/code> 来定义，比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int?&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// 获取文章列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;param name=&amp;#34;limit&amp;#34;&amp;gt;限制数&amp;lt;/param&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cs">/// &amp;lt;returns&amp;gt;HTTP 200&amp;lt;/returns&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">[HttpGet]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">async&lt;/span> &lt;span class="n">Task&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">ActionResult&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">ICollection&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">ArticleListDto&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">GetArticleList&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">FromQuery&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="kt">int?&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>注意：通常可空类型与一元或二元运算符一起使用时，如果其中一个操作数或两个操作数都是 &lt;code>null&lt;/code> 则结果也为 &lt;code>null&lt;/code> 。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>在比较可空类型时，有一个为 &lt;code>null&lt;/code> 则结果就是 &lt;code>false&lt;/code> 。&lt;/p>&lt;/blockquote>
&lt;h6 id="空合并运算符">空合并运算符
&lt;/h6>&lt;p>空合并运算符(&lt;code>??&lt;/code>)提供了一种快捷的方式：如果运算符前的表达式不为 &lt;code>null&lt;/code> 则返回前面的表达式，否则返回后面的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">Test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int?&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">numInt&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="p">??&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ReadLine&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="p">??&lt;/span> &lt;span class="s">&amp;#34;C:/&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h6 id="空值条件运算符">空值条件运算符
&lt;/h6>&lt;p>下面这段代码验证传递的参数 &lt;code>p&lt;/code> 是否非空。如果它为空，方法就只是返回，而不会继续执行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ShowPerson&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Person&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">==&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">firstName&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">FirstName&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>（你看它多麻烦）&lt;/p>
&lt;p>使用空值条件运算符 &lt;code>?.&lt;/code> 访问 &lt;code>FirstName&lt;/code> ，当 &lt;code>p&lt;/code> 为空的时候就只返回 &lt;code>null&lt;/code> ，而不继续执行表达式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ShowPerson&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Person&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">firstName&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">?.&lt;/span>&lt;span class="n">FirstName&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>还可以把空值运算符用于数组：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">?[&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 结合 ?? 运算符给它一个默认值：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">valWithDefault&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">?[&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">??&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="522---运算符的优先级和关联性">5.2.2 - 运算符的优先级和关联性
&lt;/h5>&lt;p>基本运算符 &amp;gt; 一元运算符 &amp;gt; 乘除 &amp;gt; 加减 &amp;gt; 移位运算 &amp;gt; 关系运算 &amp;gt; 比较运算 &amp;gt; AND &amp;gt; XOR &amp;gt; OR &amp;gt; 逻辑与 &amp;gt; 逻辑或 &amp;gt; 空合并 &amp;gt; 三元条件运算符 &amp;gt; 赋值与lambda&lt;/p>
&lt;p>关联性的例外是赋值运算符，它们是右关联。&lt;/p>
&lt;p>一个重要的、可能误导右关联是三元条件运算符：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 等价&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>注意：在复杂的表达式中应避免运算符优先级来生成正确的结果。优先级一般符合正常的认知，当不利于人类理解时应该使用括号指定优先级。避免潜在的问题。&lt;/p>&lt;/blockquote>
&lt;h4 id="63---使用二进制运算符">6.3 - 使用二进制运算符
&lt;/h4>&lt;p>&lt;code>Convert.ToString&lt;/code> 提供的一个重载带有两个 &lt;code>int&lt;/code> 参数，其中第二个 &lt;code>int&lt;/code> 值是 &lt;code>toBase&lt;/code> 参数。使用这个方法可以传递值：&lt;/p>
&lt;ul>
&lt;li>2 - 二进制&lt;/li>
&lt;li>8 - 八进制&lt;/li>
&lt;li>10 - 十进制&lt;/li>
&lt;li>16 - 十六进制&lt;/li>
&lt;/ul>
&lt;p>来格式化字符串。&lt;/p>
&lt;p>默认情况下，如果二进制以 &lt;code>0&lt;/code> 开头，则这些 &lt;code>0&lt;/code> 将会被忽略，而不会被打印出来。使用 &lt;code>PadLeft&lt;/code> 方法来填充字符串中的这些 &lt;code>0&lt;/code> 值。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>位与 AND：该位全是1的时候结果为1，否则为0，比如：&lt;/p>
&lt;p>A: 1001_0011_1001_1111&lt;br>
B: 1100_0101_0011_1011&lt;br>
R: 1000_0001_0001_1011&lt;/p>
&lt;/li>
&lt;li>
&lt;p>位或 OR : 该位上任意操作数为1的时候结果为1，比如：&lt;/p>
&lt;p>A: 1001_0011_1001_1111&lt;br>
B: 1100_0101_0011_1011&lt;br>
R: 1101_0111_1011_1111&lt;/p>
&lt;/li>
&lt;li>
&lt;p>位异或XOR: 该位上只有一操作数位1的时候结果为1，比如：&lt;/p>
&lt;p>A: 1001_0011_1001_1111&lt;br>
B: 1100_0101_0011_1011&lt;br>
R: 0101_0110_1010_0100&lt;/p>
&lt;/li>
&lt;li>
&lt;p>位取反NOT:按位取反，比如：&lt;/p>
&lt;p>A: 1001_0011_1001_1111&lt;br>
R: 0110_1100_0110_0000&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="631---位的移动">6.3.1 - 位的移动
&lt;/h5>&lt;p>向左移动 n 位等同于原来的数字乘以 2^n ，这比乘法运算符要快得多哦。&lt;/p>
&lt;h5 id="632---有符号数和无符号数">6.3.2 - 有符号数和无符号数
&lt;/h5>&lt;p>使用二进制时要记住的意见重要的事情是，有符号类型的数字最左边一位表示符号。&lt;/p>
&lt;h4 id="64---类型的安全性">6.4 - 类型的安全性
&lt;/h4>&lt;h5 id="641---类型转换">6.4.1 - 类型转换
&lt;/h5>&lt;h6 id="隐式转换">隐式转换
&lt;/h6>&lt;p>只要保证值不会发生任何变化，类型转换就可以自动进行。即：可以从“小范围”转到“大范围”的意思。&lt;/p>
&lt;blockquote>
&lt;p>Tips：&lt;code>BigInteger&lt;/code> 是包含任意大小的数字的结构体。可以从较小的类型中初始化它，传递一个大数字或者解析字符串。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>只能从较小的整数类型隐式的转换为较大的整数类型，反过来不行。&lt;/li>
&lt;li>可以将整数隐式的转换为浮点数，尽管可能会丢失精度。&lt;/li>
&lt;li>可空类型不能隐式的转换为不可空类型。&lt;/li>
&lt;/ol>&lt;/blockquote>
&lt;h6 id="显示转换">显示转换
&lt;/h6>&lt;p>强制类型转换，使用 &lt;code>(type)identifer&lt;/code> 的语法来转换。强制类型转换可能是不安全的，可能会引发溢出或者异常。&lt;/p>
&lt;p>CSharp提供了 &lt;code>checked&lt;/code> 运算符，可以检查是否有算术溢出。当然它也检查了是否安全，如果不安全则会强制抛出一个异常。&lt;/p>
&lt;blockquote>
&lt;p>Tips：谨慎的使用显示的类型强制转换，就可以把简单值类型的任何实例转换为几乎任何其它类型。&lt;/p>&lt;/blockquote>
&lt;p>如果需要在数字和字符串之间转换可以使用 &lt;code>.NET&lt;/code> 类库提供的一些方法。&lt;/p>
&lt;p>数字 -&amp;gt; 字符串：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">8&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToString&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>字符串 -&amp;gt; 数字：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;8&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">var&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">TryParse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">out&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Successfully convert string to int.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 8&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果使用了 &lt;code>Parse&lt;/code> 方法，将会返回转换后的值，但是如果不能转换该方法就会抛出一个异常。&lt;/p>
&lt;h5 id="642---装箱和拆箱">6.4.2 - 装箱和拆箱
&lt;/h5>&lt;p>前面说过了：&lt;/p>
&lt;ul>
&lt;li>装箱：值类型 -&amp;gt; 引用类型，栈 -&amp;gt; 堆&lt;/li>
&lt;li>拆箱：引用类型 -&amp;gt; 值类型，堆 -&amp;gt; 栈&lt;/li>
&lt;/ul>
&lt;p>装箱可以隐式的进行。&lt;/p>
&lt;blockquote>
&lt;p>Tips: 拆箱时必须非常小心，确保能拆&amp;hellip;否则可能会引发一个异常&lt;/p>&lt;/blockquote>
&lt;h4 id="65---比较对象的相等性">6.5 - 比较对象的相等性
&lt;/h4>&lt;h5 id="1-referenceequals-方法">1. &lt;code>ReferenceEquals&lt;/code> 方法
&lt;/h5>&lt;p>&lt;code>ReferenceEquals&lt;/code> 是一个静态方法，其测试两个引用是否指向类的同一个实例，特别是两个引用是否包括内存中相同的地址。不能重写。&lt;/p>
&lt;p>但是，它认为 &lt;code>null&lt;/code> 等于 &lt;code>null&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>Tips：这个方法如果用于比较值类型则总返回 &lt;code>false&lt;/code> 。&lt;/p>&lt;/blockquote>
&lt;h5 id="2-equals-虚方法">2. &lt;code>Equals&lt;/code> 虚方法
&lt;/h5>&lt;p>&lt;code>Equals&lt;/code> 虚版本的也可以实现比较， &lt;code>System.Object&lt;/code> 中实现的版本是比较引用。因为这是虚方法所以可以在自己的类中重写它，使用适合自己类的方法进行比较，比如值比较。&lt;/p>
&lt;blockquote>
&lt;p>如果希望类的实例用作字典的键，就需要重写这个方法。&lt;/p>&lt;/blockquote>
&lt;h5 id="3-equals-静态方法">3. &lt;code>Equals&lt;/code> 静态方法
&lt;/h5>&lt;p>作用相同，不同的是静态方法有两个参数，它的作用是比较这两个参数（引用）的相等性。如果有一个参数为 &lt;code>null&lt;/code> 则返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;h5 id="4--比较运算符">4. &lt;code>==&lt;/code> 比较运算符
&lt;/h5>&lt;p>最好将它看作严格的值比较和严格的引用比较中间的玩意，大多数情况下，如果两边是引用类型的话是引用比较。&lt;/p>
&lt;blockquote>
&lt;p>不过字符串类型通过运算符重载实现了通过比较运算符进行值比较，更符合人的直觉。&lt;/p>&lt;/blockquote>
&lt;p>在使用上述几种方法的时候，通常来说使用 &lt;code>==&lt;/code>，需要比较引用的时候使用 &lt;code>ReferenceEquals&lt;/code> 方法。需要复杂类型的自定义比较时，重写 &lt;code>Equals&lt;/code> 方法，并且，建议使用这个方法重载运算符 &lt;code>==&lt;/code>，以便于更方便的比较。&lt;/p>
&lt;h5 id="652---比较值类型的相等性">6.5.2 - 比较值类型的相等性
&lt;/h5>&lt;p>在比较值类型的相等性时，采用与引用类型相同的规则：&lt;code>ReferenceEquals&lt;/code> 用于比较引用，&lt;code>Equals&lt;/code> 用于比较值，比较运算符可以看作一个中间项。&lt;/p>
&lt;p>如果调用 &lt;code>sA.Equals(sB)&lt;/code> ，其中 &lt;code>sA&lt;/code> 和 &lt;code>sB&lt;/code> 是某个结构的实例，则根据它俩是否存在所有的字段并且包含相同的值返回 &lt;code>true&lt;/code> 或者 &lt;code>false&lt;/code>。&lt;/p>
&lt;p>另一方面，在默认情况下，使用 &lt;code>==&lt;/code> 比较结构会无法编译，除非自己重载了比较运算符。&lt;/p>
&lt;p>尽管 &lt;code>System.ValueType&lt;/code> 提供的 &lt;code>Equals&lt;/code> 默认重写版本肯定足以应付大部分自定义的结构，但是仍然可以重写方法以适用于自己的结构、提高性能。另外，如果值类型包含作为字段的引用类型，就需要重写 &lt;code>Equals&lt;/code> 方法，默认的版本仅比较它们的地址。&lt;/p>
&lt;h4 id="66---运算符重载">6.6 - 运算符重载
&lt;/h4>&lt;p>假如有个 &lt;code>Matrix&lt;/code> 类，实现了矩阵相加、相乘的一些方法。但是直接调用看着太不舒服了，使用更利于理解的运算符才是该干的。&lt;/p>
&lt;p>通过运算符重载可以告诉编译器，&lt;code>+&lt;/code> 和 &lt;code>*&lt;/code> 分别对 &lt;code>Matrix&lt;/code> 对象执行什么操作，以便编写类似于上面的代码。&lt;/p>
&lt;p>事实证明，在许多情况下，重载运算符利于生成可读性更高、更直观的代码。&lt;/p>
&lt;h5 id="661---运算符的工作方式">6.6.1 - 运算符的工作方式
&lt;/h5>&lt;ul>
&lt;li>编译器会看前后的操作数的类型，如果是相同的基础类型，则按照规定的操作进行。&lt;/li>
&lt;li>如果是不同的，则看是否能够隐式转换并选择合适的路径进行转换。&lt;/li>
&lt;li>如果是用户自定义的类型，则去查找重载，找到就走重载，找不到就报错。&lt;/li>
&lt;/ul>
&lt;h5 id="662---运算符重载的示例vector-结构">6.6.2 - 运算符重载的示例：Vector 结构
&lt;/h5>&lt;p>&lt;code>Vector&lt;/code> 结构表示一个三维的数学矢量。为了简单，就算它是三个 &lt;code>double&lt;/code> 类型数字的集合。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">Vector&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">X&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Y&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Z&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Vector&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">X&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">X&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Y&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Z&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">X&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">set&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">Y&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">set&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">Z&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">set&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">override&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">ToString&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="s">$&amp;#34;( {X}, {Y}, {Z} )&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>运算符重载的声明方式与静态方法基本相同，但 &lt;code>operator&lt;/code> 关键字告诉编译器这是运算符重载，它后面紧跟一个运算符，比如 &lt;code>+&lt;/code> ：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Vector&lt;/span> &lt;span class="kd">operator&lt;/span> &lt;span class="p">+(&lt;/span>&lt;span class="n">Vector&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Vector&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">X&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">X&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Y&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Z&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Z&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>注意：CSharp要求所有的运算符重载都声明为 &lt;code>public&lt;/code> 和 &lt;code>static&lt;/code> ，这表示它们与类或结构相关联而不是某个特定的实例。所以运算符重载的代码体不能访问非静态类成员，也不能访问 &lt;code>this&lt;/code> 标识符。&lt;/p>&lt;/blockquote>
&lt;p>有一个运算符重载，其参数依次是一个 &lt;code>double&lt;/code> 和一个 &lt;code>Vector&lt;/code> ，但是编译器不能交换参数的顺序，所以对于这种交换顺序不影响的运算，需要写两个重载。&lt;/p>
&lt;p>虽然 &lt;code>+=&lt;/code> 一般算作一个运算符，但实际上它对应的操作分为两步：相加和赋值。但是CSharp是不允许重载 &lt;code>=&lt;/code> 运算符的，不过如果重载了 &lt;code>+&lt;/code> 运算符，编译器会自动重载 &lt;code>+=&lt;/code> 运算符。&lt;/p>
&lt;h5 id="663---比较运算符的重载">6.6.3 - 比较运算符的重载
&lt;/h5>&lt;p>6个比较运算符分为三对：&lt;/p>
&lt;ol>
&lt;li>&lt;code>==&lt;/code> 和 &lt;code>!=&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> 和 &lt;code>&amp;lt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;gt;=&lt;/code> 和 &lt;code>&amp;lt;=&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>CSharp语言要求成对重载比较运算符，也就是你重载了 &lt;code>&amp;gt;=&lt;/code> 也必须重载 &lt;code>&amp;lt;=&lt;/code> ，否则就会产生编译器错误。&lt;/p>
&lt;blockquote>
&lt;p>Tips：当比较时，需要考虑：如果有嵌入的类，是比较嵌入的类的引用（浅度比较）还是应该比较对象的值是否相等（深度比较）？&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>注意：不要通过调用从 &lt;code>System.Object&lt;/code> 中继承的 &lt;code>Equals&lt;/code> 方法的实例版本来重载比较运算符，如果这么做在双等号左值为 &lt;code>null&lt;/code> 时（例如 &lt;code>objA == objB&lt;/code>）系统会去调用 &lt;code>null.Equals(objB)&lt;/code> ，这样会引发一个异常。采用其他方法（重写 &lt;code>Equals&lt;/code> 方法以比较）比较安全。&lt;/p>&lt;/blockquote>
&lt;p>还需要重写 &lt;code>Equals&lt;/code> 方法和 &lt;code>GetHashCode&lt;/code> 方法。这些方法总是应该在重载 &lt;code>==&lt;/code> 进行重写，否则编译器会报错：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">override&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">Equals&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">object&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">obj&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">Vector&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="k">this&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">override&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">GetHashCode&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">X&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetHashCode&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">^&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Y&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetHashCode&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">^&lt;/span> &lt;span class="n">Z&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetHashCode&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>散列代码的实现应比较快速，且总对相同的对象返回相同的值，因此对几个属性算散列是比较的河里的。&lt;/p>
&lt;h5 id="664---可以重载的运算符">6.6.4 - 可以重载的运算符
&lt;/h5>&lt;p>不同于C++，并不是所有的运算符可以重载。&lt;/p>
&lt;p>可以重载的运算符有：&lt;/p>
&lt;ul>
&lt;li>算术一元、二元运算符&lt;/li>
&lt;li>按位二元运算符&lt;/li>
&lt;li>按位一元运算符：&lt;code>true&lt;/code> 和 &lt;code>false&lt;/code> 运算符必须成对重载&lt;/li>
&lt;li>比较运算符：必须成对重载&lt;/li>
&lt;li>赋值运算符：不能显示重载，重载单个运算符就重载了&lt;/li>
&lt;li>索引运算符：不能直接重载索引运算符，索引器成员类型允许类和结构上支持&lt;/li>
&lt;li>类型强制转换运算符：不能直接重载，可以用用户定义的类型强制转换&lt;/li>
&lt;/ul>
&lt;h4 id="67---实现自定义的索引运算符">6.7 - 实现自定义的索引运算符
&lt;/h4>&lt;p>自定义索引器不能使用运算符重载语法来实现，但是它们可以用与属性非常相似的语法来实现。&lt;/p>
&lt;p>举个 &lt;code>PersonCollection&lt;/code> 类的栗子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">PersonCollection&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">Person&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">_people&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ctor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">PersonCollection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">params&lt;/span> &lt;span class="n">Person&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">people&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_people&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">people&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToArray&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// indexer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Person&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">get&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">_people&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">set&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">_people&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了允许索引器语法访问 &lt;code>PersonCollection&lt;/code> 并返回 &lt;code>Person&lt;/code> 对象，可以创建一个索引器。索引器看起来非常类似于属性。不同之处是名称，指定索引器必须要使用 &lt;code>this&lt;/code> 关键字，中括号中是索引的类型。&lt;/p>
&lt;p>对于索引器，不仅能用 &lt;code>int&lt;/code> 类型进行索引，任何类型都是有效的。&lt;/p>
&lt;h4 id="68-用户定义的类型强制转换">6.8 用户定义的类型强制转换
&lt;/h4>&lt;p>CSharp允许定义用户自己的数据类型，因此，需要去支持这些类型的转换。如果知道无论在源变量中存储什么值，类型强制转换总是安全的，就可以把它定义为隐式强制转换。然而，如果某些数值可能会出错，如丢失什么数据或抛出异常，就应该把数据类型转换定义为显示强制转换。&lt;/p>
&lt;ul>
&lt;li>隐式转换关键字：&lt;code>implicit&lt;/code>&lt;/li>
&lt;li>显示转换关键字：&lt;code>explicit&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>与其他运算符重载一样，类型强制必须同时声明为 &lt;code>public&lt;/code> 和 &lt;code>static&lt;/code> 。&lt;/p>
&lt;h5 id="681---实现用户定义的类型强制转换">6.8.1 - 实现用户定义的类型强制转换
&lt;/h5>&lt;p>定义隐式的强制类型转换使用 &lt;code>implicit&lt;/code> 关键字，假如我们要转 &lt;code>Currency&lt;/code> 类为 &lt;code>float&lt;/code> ：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">implicit&lt;/span> &lt;span class="n">operate&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Currency&lt;/span> &lt;span class="k">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Dollars&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Cents&lt;/span> &lt;span class="p">/&lt;/span> &lt;span class="m">100.0f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>把 &lt;code>float&lt;/code> 转换成 &lt;code>Currency&lt;/code> 不总是成功的，应该定义一个强制转换：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">explicit&lt;/span> &lt;span class="n">operate&lt;/span> &lt;span class="n">Currency&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="k">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint&lt;/span> &lt;span class="n">dollars&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="k">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">ushort&lt;/span> &lt;span class="n">cents&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">ushort&lt;/span>&lt;span class="p">)((&lt;/span>&lt;span class="k">value&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">dollars&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Currency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dollars&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cents&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>Tips：如果类型强制转换用于把 &lt;code>float&lt;/code> 值转换为 &lt;code>int&lt;/code> ，计算机会截取多余的数字，而不是执行四舍五入。&lt;/p>&lt;/blockquote>
&lt;p>&lt;code>System.Convert&lt;/code> 对象包含大量的静态方法来完成各种数字转换，在使用 &lt;code>System.Covert&lt;/code> 类的方法时会造成额外的性能损失，所以只应在需要的时候使用它们。&lt;/p>
&lt;p>&lt;code>System.Convert&lt;/code> 类的方法还执行它们自己的溢出检查，因此，不需要把对它们的调用放在 &lt;code>checked&lt;/code> 环境下面。&lt;/p>
&lt;h6 id="1-类之间的类型强制转换">1. 类之间的类型强制转换
&lt;/h6>&lt;blockquote>
&lt;p>注意：派生类之间不能相互转换。&lt;/p>&lt;/blockquote>
&lt;p>CSharp要求把类型强制转换的定义放在源类或目标类的内部。&lt;/p>
&lt;h6 id="2-基类和派生类之间的类型强制转换">2. 基类和派生类之间的类型强制转换
&lt;/h6>&lt;p>在进行强制类型转换时，会检查被引用的对象。因为基类原则上可以引用一个派生类的实例，所以这个对象可能是要强制转换的派生类的一个实例。如果是这样，强制转换就会成功。如果被引用的实例不是派生自基类的一个实例，强制转换就会抛出异常。&lt;/p>
&lt;p>编译器已经提供了对于基类和派生类之间的强制类型转换。如果要进行的转换是合法的，它们也仅仅是更改了类型，而引用没有变。这些强制类型转换与用户定义的强制类型转换不同。在上面的例子中，将 &lt;code>float&lt;/code> 强制转换为 &lt;code>Currency&lt;/code> 还新定义并初始化了一个实例。&lt;/p>
&lt;h6 id="3-装箱和拆箱类型的强制类型转换">3. 装箱和拆箱类型的强制类型转换
&lt;/h6>&lt;p>从值类型到 &lt;code>object&lt;/code> 的强制转换总是一种隐式的强制转换，因为这种转换是从派生类到基类的的转换。&lt;/p>
&lt;p>在执行上述转换（装箱）时，值类型的变量的值被复制到堆上，放在一个装箱的对象中，并且将装箱后的变量的引用设置为那个对象。&lt;/p>
&lt;p>拆箱是一种显示的强制类型转换，因为如果要强制转换的对象不是正确的类型就会抛出一个异常。&lt;/p>
&lt;p>在使用装箱和拆箱时，这两个过程都把数据复制到新装箱或新拆箱的休想上，理解这一点非常重要。因此，对装箱的操作不会影响源值类型变量的值。&lt;/p>
&lt;h5 id="682-多重类型强制转换">6.8.2 多重类型强制转换
&lt;/h5>&lt;p>如果在进行要求的数据类型转换时没有可用的直接强制类型转换方法，则编译器会自动寻找一种转换方式，将多种转换合并起来以便于进行强制类型转换。&lt;/p>
&lt;blockquote>
&lt;p>Tips：如果希望类利于使用，就应该确保所有的强制类型转换都按照一种互相兼容的方式进行，即这些转换直观上应得到相同的结果。&lt;/p>&lt;/blockquote>
&lt;p>最好设计自己的强制类型转换，让所有的转换路线都得到相同的、正确的结果，此时编译器去选择哪条路径就不重要了。&lt;/p></description></item><item><title>ASCII 码对照表和转换器</title><link>https://blog.gaein.cn/passages/ascii-code-convertor/</link><pubDate>Tue, 22 Sep 2020 14:05:19 +0800</pubDate><guid>https://blog.gaein.cn/passages/ascii-code-convertor/</guid><description>&lt;h2 id="简介">简介
&lt;/h2>&lt;blockquote>
&lt;p>ASCII 是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646。ASCII 第一次以规范标准的类型发表是在 1967 年，最后一次更新则是在 1986 年，到目前为止共定义了 128 个字符（一个 char）&lt;/p>&lt;/blockquote>
&lt;h2 id="内容">内容
&lt;/h2>&lt;p>下面是完整的 ASCII 表，0 ～ 31 及 127(共 33 个)是控制字符或通信专用字符，其余为可显示字符&lt;/p>
&lt;p>&lt;img src="https://img.cdn.gaein.cn/website_used/blog/ASCII-Code-Convertor/01.webp"
loading="lazy"
alt="ASCII"
>&lt;/p>
&lt;h2 id="转换">转换
&lt;/h2>&lt;h3 id="将字符转换为-ascii-十进制码">将字符转换为 ASCII 十进制码
&lt;/h3>&lt;link rel="stylesheet" href="https://static.cdn.gaein.cn/libs/layui/2.9.21/layui/css/layui.css">
&lt;div class="layui-form">
&lt;div class="layui-form-item">
&lt;label class="layui-form-label">输入&lt;/label>
&lt;div class="layui-input-inline">
&lt;input type="text" id="char" placeholder="请输入字符" class="layui-input">
&lt;/div>
&lt;/div>
&lt;div class="layui-form-item">
&lt;label class="layui-form-label">操作&lt;/label>
&lt;div class="layui-input-inline">
&lt;button class="layui-btn layui-btn-lg layui-btn-warm" onclick="charToNum()">转换&lt;/button>
&lt;button type="reset" class="layui-btn layui-btn-lg">清空&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="layui-form-item">
&lt;label class="layui-form-label">结果&lt;/label>
&lt;div class="layui-input-inline">
&lt;div id="numResult" class="layui-bg-blue" style="width:190px;height:35px;text-align:center"> 转换结果
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;br/ >
&lt;h3 id="将十进制码转换为-ascii-字符">将十进制码转换为 ASCII 字符
&lt;/h3>&lt;div class="layui-form">
&lt;div class="layui-form-item">
&lt;label class="layui-form-label">输入&lt;/label>
&lt;div class="layui-input-inline">
&lt;input type="text" id="num" placeholder="请输入数字" class="layui-input">
&lt;/div>
&lt;/div>
&lt;div class="layui-form-item">
&lt;label class="layui-form-label">操作&lt;/label>
&lt;div class="layui-input-inline">
&lt;button class="layui-btn layui-btn-normal layui-btn-lg" onclick="numToChar()">转换&lt;/button>
&lt;button type="reset" class="layui-btn layui-btn-lg">清空&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="layui-form-item">
&lt;label class="layui-form-label">结果&lt;/label>
&lt;div class="layui-input-inline">
&lt;div id="charResult" class="layui-bg-orange" style="width:190px;height:35px;text-align:center"> 转换结果
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;br />
&lt;script>
function numToChar() {
var input = document.getElementById("num").value;
if (input >= 40 &amp;&amp; input &lt;= 126){
var result = String.fromCharCode(input);
document.getElementById("charResult").innerHTML = input + "对应的字符是:\"" + result + "\"";
}
else
{
document.getElementById("charResult").innerHTML = input + "超出有效范围";
}
}
function charToNum() {
var input = document.getElementById("char").value;
input = input.substring(0,1);
var result = input.charCodeAt();
document.getElementById("numResult").innerHTML = "\"" + input + "\"对应的数字是:" + result;
}
&lt;/script></description></item><item><title>高考志愿填报指津</title><link>https://blog.gaein.cn/passages/cee-wish-guidance/</link><pubDate>Sun, 02 Aug 2020 15:52:25 +0800</pubDate><guid>https://blog.gaein.cn/passages/cee-wish-guidance/</guid><description>&lt;p>高考志愿填报一直是很令各位同学、家长纠结的事情，关系到学生的升学。高考结束已经将近一个月，我也研究了大半个月的志愿填报，将经验分享在这里&lt;/p>
&lt;h2 id="明确主体">明确主体
&lt;/h2>&lt;p>高考志愿是大学录取的重要依据，关系到考生4年将在哪里读大学、在哪里生活，很大程度上也会影响之后的就业、组建家庭。所以，作为考生，志愿填报是自己的责任，不能考完试就玩去了，把填报的任务完全推给家长；更不能花钱交给机构，不闻不问！这件事情一定要自己来，家长可以提出建议适度干扰，但不要以强硬的姿态来决定！
当然就算家长强硬决定了，报考密码在你手里呀~ 不过家长的建议要充分的去参考。&lt;/p>
&lt;hr>
&lt;h2 id="明确目的">明确目的
&lt;/h2>&lt;p>志愿填报的目的是升学，升学的目的是就业（至少大部分是，不排除少部分精英们要为国做贡献。但是大部分普通人的目的很简单、也要现实一点，就是就业）
就业还有两种情况，一种是本科/专科毕业后就业，另一种是考研（或者读博士）后再就业，两种就业对于学校的选择不一样。&lt;/p>
&lt;hr>
&lt;h2 id="三个因素">三个因素
&lt;/h2>&lt;p>报考学校有三个重要因素要考虑：&lt;/p>
&lt;h3 id="一是地域">一是地域
&lt;/h3>&lt;ol>
&lt;li>东部大城市，如北京、上海、南京等，大部分学校分数较高，一部分学校虽然是一本招生，但是在其省市内很有可能是二批乃至三批招生。这样学校优势就是地域，能够开拓视野，同时也会有更多的工作机会。&lt;/li>
&lt;li>东部二三线城市，像青岛、大连等，这些地区学校有很多可以选择，视野相对较开阔，工作机会也比中西部地区多一点。&lt;/li>
&lt;li>中部城市，像兰州等地，这里的学校比较有“性价比”，可以用相对少的分数报考一所实力相对好的学校。&lt;/li>
&lt;li>西部地区，像新疆、西藏，这里的学校大部分分数很低，存在很多政策性的211学校（如青海大学、石河子大学）。&lt;/li>
&lt;/ol>
&lt;h3 id="二是学校">二是学校
&lt;/h3>&lt;p>这里比的因素是学校的教学水平、学习氛围、还有社会认可度等，具体可以看学校的博士硕士授予点数量、院士的数量等，还有在校友会、软科等的排名也算是有参考价值（注意：参考价值，仅供参考）。选择一所实力强的学校往往意味着能够学到更多的技能（当然是因人而异，一天到晚不学习还想会什么纯属做梦）。当然，可以比较的还有学校的“标签”：985、211、双一流。有时候“标签”会是某用人单位招聘的“门槛”。&lt;/p>
&lt;h3 id="三是专业">三是专业
&lt;/h3>&lt;p>两个方面，一是专业是否是好就业的专业，比如比较热门的自动化等（当然不代表它一直好就业，这个需要了解专业做出形势推测）。二是专业是否是学校侧重的专业，比如人民政法大学侧重于法学等、理工科学校侧重与工科，电子科技大学侧重电子信息类和计算机等。大部分学校都有它的侧重点，选择学校侧重的学科可能会获得更多的资源。&lt;/p>
&lt;h2 id="选择专业">选择专业
&lt;/h2>&lt;p>订购一本专业解读的书，详细了解各个专业的就业方向和对身体的要求，初步选择出自己比较敢兴趣的专业，不能太少，多选一些。&lt;/p>
&lt;h2 id="初选学校">初选学校
&lt;/h2>&lt;p>回到目的那里。&lt;/p>
&lt;ol>
&lt;li>本科毕业就业：选择东部沿海城市的实力相对较弱点学校的易于就业的专业，保证能报上那种。&lt;/li>
&lt;li>研究生毕业就业：选择西部211（政策性）或者中部985，这些学校易于考研，选择学校实力较强、地域较差的学校，学习氛围较好的学校&lt;/li>
&lt;/ol>
&lt;p>如果你对某方面有强烈的兴趣爱好，不妨报考一所稳上某专业的学校，浪费点分就浪费点呗！
根据以上要点初步筛选分数差不多的学校。&lt;/p>
&lt;blockquote>
&lt;p>注意：宿舍、食堂、商业街等不在考虑范围之内，你要想清楚去大学不是养大爷去了，是学习去了，能上一所实力强点的学校就是睡长椅都行。这些因素我在报考时压根都没有考虑，作为一个农村娃，我觉得所有大学的宿舍都很好，很棒，真的不用过分考虑这些。高中毕业大部分都成人了，应该明白那些重要、那些不重要。&lt;/p>&lt;/blockquote>
&lt;h2 id="再筛学校">再筛学校
&lt;/h2>&lt;ol>
&lt;li>将自己的分数根据今年（2020）的一分一档查到对应的位次，记住这个位次，再根据过去三年（2017、2018、2019）的一分一档查到该位次对应的分数，记下这些数据用于参考。&lt;/li>
&lt;li>根据书上或者学校官网的数据，比较自己和往年的差距，如果分数和提档线不相上下，则可以冲一冲；如果分数高于提档线2~3分，则学校可以上，但是专业无法选择。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果冲的学校不是跨水平的学校（比如二本分数冲一本、一本分数冲211 算是跨水平），则不是很有必要冲。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>提档线是自然形成的而非人为划定的，在录取工作完成之前谁也不知道提档线是多少。按照比例进行调档的最后一个人的分数则是提档线。往年数据里最低分就是提档线。&lt;/p>&lt;/blockquote>
&lt;ol start="3">
&lt;li>排除一些“坑”（就是学校不行分数不少）的学校&lt;/li>
&lt;li>根据自己的专业意向，选择偏该专业的学校&lt;/li>
&lt;li>挨个查看学校的招生章程：是否有分数级差，查看学校招生计划：是否扩招&lt;/li>
&lt;/ol>
&lt;h2 id="专业选择">专业选择
&lt;/h2>&lt;p>将分数较高、自己喜欢、学校侧重的专业排在前面，分数较低但是可以接受的专业写在后面，尽量不被调剂但是一定要服从专业调剂。&lt;/p>
&lt;h2 id="志愿填报">志愿填报
&lt;/h2>&lt;p>不用过于害怕网络崩溃，但是也别过分不紧张。在河北省等不限次数更改的省份，可以先填报，不满意再更改。尽早完成。&lt;/p>
&lt;h2 id="解释说明">解释说明
&lt;/h2>&lt;p>报志愿时遇到的部分概念做解释说明。&lt;/p>
&lt;h3 id="分数级差">分数级差
&lt;/h3>&lt;p>一个志愿（比如山东科技大学）各个专业之间的级差，比如考生考了605分，今年山东科技大学的分数级差是3-0-0-0-0-0，那么第一专业按605分计算，第二第三个专业在录取时按照602分计算.&lt;/p>
&lt;h3 id="专业调剂">专业调剂
&lt;/h3>&lt;p>在考生所填报的专业计划已经满的情况下，服从专业调剂会分配到未填报的其它计划数没有满的专业。服从专业调剂不一定会被调剂到冷门专业，专业调剂是随机分配的（但是热门专业计划数都满了&amp;hellip;调剂的很大可能就是冷门专业）。所以建议考生将分低的可以接受的专业写在后面，尽量避免专业调剂。&lt;/p>
&lt;p>&lt;strong>但是，必须勾选服从专业调剂，因为如果整个学校招生计划没满，被提档，但是所填报的专业计划全部满，又不服从专业调剂会做退档处理！大部分省份一个批次只有一次投档机会，退档后其它志愿作废，到下一批次（期间有一个征集志愿，分数很高的）才能投档。也就是本来能报本科批的滑档到专科批！可没少亏！因此，不要害怕上不了喜欢的专业，至少比滑档到下一批次强。就是十拿九稳的也要服从专业调剂，多一份保障&lt;/strong>&lt;/p>
&lt;h3 id="平行志愿">平行志愿
&lt;/h3>&lt;p>平行志愿是“分数优先，遵循志愿”的原则，不同于顺序志愿，平行志愿退档的概率更低（服从专业调剂的情况下）。整个录取工作只进行一轮检索，因此不用担心把学校报在C志愿会因为A、B两所学校而致使检索C时C被填满。录取的流程是这样的：&lt;/p>
&lt;ol>
&lt;li>将考生按总分排名，分数相同考生比较单科成绩排名（单科成绩全部相同考生比较学考成绩）。&lt;/li>
&lt;li>按照排名检索，先检索全省第一，比方他A志愿填写的“1466 清华大学”，此时系统检索清华大学招生人数，未满，则提档；提档后检索该考生的专业，第一专业人数未满，则投档给清华、录取。&lt;/li>
&lt;li>系统依次检索第二、三、四&amp;hellip;人的志愿，每人都是先检索A，再检索B、C&amp;hellip;志愿。如果A志愿所填报的学校招生计划已经满，则不做提档，检索B学校，直到检索到最后一所学校，如果仍然无法投档则进入下一批次。&lt;/li>
&lt;/ol>
&lt;h3 id="调档比例">调档比例
&lt;/h3>&lt;p>比如调档比例是105%，招生计划是100人，则实际调档105人。其中肯定有因为不服从专业调剂或者身体原因或者自己申请而退档的，那么实际招生也就差不多100人，如果超出计划则使用预留人数。大部分学校即使超出计划但是你服从专业调剂也不会退档，不过还是建议拨打招生办电话进行咨询。&lt;/p>
&lt;h2 id="注意事项">注意事项
&lt;/h2>&lt;h3 id="服从专业调剂">服从专业调剂
&lt;/h3>&lt;p>原因说了，一定要服从专业调剂！！！&lt;/p>
&lt;h3 id="院校代码">院校代码
&lt;/h3>&lt;p>以省教育考试院公布或发行的书本为主，不要使用往年的代码。可能有部分省份使用国标代码，但是大部分省份都是自己省内编排的代码。&lt;/p>
&lt;h2 id="大学推荐">大学推荐
&lt;/h2>&lt;p>说说几个宝藏大学吧！这些学校不是985、不是211，但是非常厉害！&lt;/p>
&lt;ol>
&lt;li>
&lt;p>中北大学
（我报考的就是中北大学）兵工类学校，不是军校。彭德怀创立，解放军第一所兵工院校，有人民兵工第一校的美称。兵工七子之一，国家二级保密单位。位于山西省太原市，由于学校比较低调，知名度很低。在山西省内由于省内招生优惠，分数很低，所以在山西省内也不是很有名。测控技术与仪器、航空航天等专业为王牌专业，国庆展出的军事装备中很多研发都有中北师生的身影。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>燕山大学&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>位于河北省秦皇岛，综合实力超过了很多211学校，在河北省内排名第一。是河北省人民政府、教育部、工业和信息化部、国家国防科技工业局共建的全国重点大学。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>桂林电子科技大学。电子、计算机类实力很强，很多地区是二本、三本招生，受生源和地域影响其它学科发展不是很好。四大电子科技大学之一
（末）。参与北斗卫星研发。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>杭州电子科技大学。实力超过很多211，四大电子科技大学之一。位于杭州阿里巴巴隔壁，工作机会较多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集美大学。位于厦门市集美区。环境优美，办学水平也很高。
最近看到，这所学校航海专业很强势，如果向往星辰大海可以考虑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>石家庄铁道大学，就业率高，土木工程等专业排名靠前。（铁路类院校）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>兰州交通大学，就业率高，车辆、通信等发展较好。（铁路类院校）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&amp;lt;1&amp;gt;排名不分先后&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&amp;lt;2&amp;gt;具体学校数据请以官网介绍为准，本文本部分凭印象所写，难免有偏差。&lt;/p>&lt;/blockquote>
&lt;p>最后，欢迎报考博主所报考的中北大学，一起来碗老陈醋！&lt;/p></description></item><item><title>最新官方版化学元素周期表高清大图下载</title><link>https://blog.gaein.cn/passages/periodictable-of-theelements/</link><pubDate>Sat, 13 Jul 2019 22:55:37 +0800</pubDate><guid>https://blog.gaein.cn/passages/periodictable-of-theelements/</guid><description>&lt;p>来自国际纯粹与应用化学联合会和中国化学会的权威元素周期表高清下载。有最新的元素和最权威的数据&lt;/p>
&lt;!-- more -->
&lt;blockquote>
&lt;p>因为刚好需要元素周期表就找了一下，网上大多数更新不及时而且样式不好看，数据不权威。终于在IUPAC官网和中国化学会找到了英文和中文（中国化学会译制的IUPAC周期表）&lt;/p>&lt;/blockquote>
&lt;h4 id="iupac国际纯粹与应用化学联合会元素周期表英文english">IUPAC（国际纯粹与应用化学联合会）元素周期表[英文/English]
&lt;/h4>&lt;blockquote>
&lt;p>International Union of Pure and Applied Chemistry (IUPAC) 国际纯粹与应用化学联合会，又译 国际理论（化学）与应用化学联合会， 是一个致力于促进化学相关的非政府组织，也是各国化学会的一个联合组织。 以公认的化学命名权威著称。 命名及符号分支委员会每年都会修改IUPAC命名法，以力求提供化合物命名的准确规则。 IUPAC 也是国际科学理事会的会员之一。&lt;/p>&lt;/blockquote>
&lt;p>IUPAC官网:&lt;a class="link" href="https://iupac.org" title="国际纯粹与应用化学联合会官网"
target="_blank" rel="noopener"
>IUPAC.org&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://s2.ax1x.com/2019/07/13/Z4O5i4.md.png"
loading="lazy"
alt="元素周期表英文版(IUPAC)"
>&lt;/p>
&lt;h6 id="图片下载gaeincn--pte-iupacpng--225-kb">图片下载：[&lt;a class="link" href="https://static.cdn.gaein.cn/website_used/files/PTE/PTE-IUPAC.png" target="_blank" rel="noopener"
>Gaein.cn | PTE-IUPAC.png | 225 KB&lt;/a>]
&lt;/h6>&lt;h6 id="pdf下载gaeincn--pte-iupacpdf--236-kb">PDF下载：[&lt;a class="link" href="https://static.cdn.gaein.cn/website_used/files/PTE/PTE-IUPAC.pdf" target="_blank" rel="noopener"
>Gaein.cn | PTE-IUPAC.pdf | 236 KB&lt;/a>]
&lt;/h6>&lt;p>//推荐下载PDF文件，更清晰，方便打印&lt;/p>
&lt;h4 id="ccs中国化学会元素周期表中文chinese">CCS（中国化学会）元素周期表[中文/Chinese]
&lt;/h4>&lt;blockquote>
&lt;p>中国化学会（Chinese Chemical Society，缩写CCS）是从事化学或与化学相关专业的科技、教育工作者自愿组成并依法注册登记的学术性、公益性法人社会团体，是中国科学技术协会的组成部分，是中国发展化学科学技术的重要社会力量。&lt;/p>&lt;/blockquote>
&lt;p>中国化学会于1932年在南京成立。1959年，中国化学会曾与中国化工学会筹委会合并成立中国化学化工学会。1963年，又分为化学、化工两个学会。中国化学会是国际纯粹与应用化学联合会（IUPAC）、亚洲化学学会联合会（FACS）等7个国际组织的成员。&lt;/p>
&lt;p>CCS官网：&lt;a class="link" href="https://www.chemsoc.org.cn" title="中国化学会官网"
target="_blank" rel="noopener"
>chemsoc.org.cn&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://s2.ax1x.com/2019/07/13/Z4XcfH.md.png"
loading="lazy"
alt="元素周期表中文版(CCS)"
>&lt;/p>
&lt;h6 id="图片下载gaeincn--pte-ccspng--217-kb">图片下载：[&lt;a class="link" href="https://static.cdn.gaein.cn/website_used/files/PTE/PTE-CCS.png" target="_blank" rel="noopener"
>Gaein.cn | PTE-CCS.png | 217 KB&lt;/a>]
&lt;/h6>&lt;h6 id="pdf下载gaeincn--pte-ccspdf--638-kb">PDF下载：[&lt;a class="link" href="https://static.cdn.gaein.cn/website_used/files/PTE/PTE-CCS.pdf" target="_blank" rel="noopener"
>Gaein.cn | PTE-CCS.pdf | 638 KB&lt;/a>]
&lt;/h6>&lt;p>//推荐下载PDF文件，更清晰，方便打印&lt;/p>
&lt;p>另外发现一个非常不错的在线元素周期表网站：&lt;a class="link" href="https://periodic-table.io/" target="_blank" rel="noopener"
>periodic-table.io&lt;/a>
这个网站有很多的优点&lt;/p>
&lt;blockquote>
&lt;p>元素：周期表 在一个界面中提供易于理解且有用的关于化学元素的信息。 点击一个元素符号去了解更多的关于其性质，历史，名字来源，图片，应用，危险性和电子层分布的图片。&lt;/p>&lt;/blockquote>
&lt;ol>
&lt;li>令人视觉愉悦的彩色表格&lt;/li>
&lt;li>简单流畅的设计和丰富的信息&lt;/li>
&lt;li>每个元素的详细描述&lt;/li>
&lt;li>使用字母表顺序来浏览元素&lt;/li>
&lt;li>每个元素的电子壳层示意图&lt;/li>
&lt;li>在一个表格中比较两种元素的性质&lt;/li>
&lt;li>用符号，原子序数或者名称来搜索元素&lt;/li>
&lt;li>详情网站的超链接以便进一步学习&lt;/li>
&lt;/ol>
&lt;p>支持多国语言，建议各位使用，当然也存在部分中文元素汉字无法拼写的问题（字库没有字）&lt;/p>
&lt;p>另外 元素：周期表 开发了Windows10应用，请到 [&lt;a class="link" href="https://www.microsoft.com/zh-cn/p/%e5%85%83%e7%b4%a0-%e5%91%a8%e6%9c%9f%e8%a1%a8/9wzdncrfjcm1" target="_blank" rel="noopener"
>Microsoft应用商店 元素：周期表&lt;/a>] 下载&lt;/p>
&lt;h2 id="有关版权的特别声明">有关版权的特别声明：
&lt;/h2>&lt;blockquote>
&lt;p>英文版化学元素周期表版权归国际纯粹与应用化学联合会（IUPAC）所有&lt;/p>&lt;/blockquote>
&lt;p>中文版化学元素周期表版权归中国化学会（CCS）所有&lt;/p>
&lt;p>元素：周期表 网站及应用程序版权归原作者所有&lt;/p>
&lt;p>本站仅撰写此文并转载元素周期表文件以及转换为PNG图片文件，未参与化学元素周期表的制作。向IUPAC及CCS和元素：周期表作者致敬&lt;/p></description></item></channel></rss>