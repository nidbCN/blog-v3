<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on Gaein nidb 的博客</title><link>https://blog.gaein.cn/tags/docker/</link><description>Recent content in Docker on Gaein nidb 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 13 Jan 2025 21:29:00 +0800</lastBuildDate><atom:link href="https://blog.gaein.cn/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>将 ASP.NET Core 应用程序部署到 docker 中</title><link>https://blog.gaein.cn/passages/aspnetcore-docker/</link><pubDate>Sun, 04 Apr 2021 00:10:02 +0800</pubDate><guid>https://blog.gaein.cn/passages/aspnetcore-docker/</guid><description>&lt;h2 id="将-aspnet-core-应用程序部署到-docker-中">将 ASP.NET Core 应用程序部署到 docker 中
&lt;/h2>&lt;h3 id="前言">前言
&lt;/h3>&lt;blockquote>
&lt;p>最近用 ASP.NET Core 随便摸了一些 API 和新博客的后端，为了方便以后迁移和管理准备部署在 docker 中。&lt;/p>&lt;/blockquote>
&lt;h3 id="编译">编译
&lt;/h3>&lt;p>&lt;del>由于使用 docker 相当于已经指定了系统（Linux），因此我们可以使用更多编译选项。&lt;/del>&lt;/p>
&lt;p>docker 中也有 Windows Server 的镜像，不过大部分是 Linux，官方的 runtime 也是基于 debian 的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">dotnet publish -c Release -p:PublishReadyToRun&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> --no-self-contained -r ubuntu.20.04-x64 -o ./Release
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="发布模式">发布模式
&lt;/h4>&lt;p>使用 &lt;code>--configuration&lt;/code> 或者 &lt;code>-c&lt;/code> 来指定发布的模式。默认为 &lt;code>Debug&lt;/code> ，由于我们需要发布正式版所以采用 &lt;code>Release&lt;/code> 。&lt;/p>
&lt;h5 id="r2r">R2R
&lt;/h5>&lt;p>ReadyToRun：在编译的时候除了编译中间码外也编译目标架构的机器码，但是仍然会保留中间码。这样会造成程序体积的翻倍，但是会加快启动速度，不过由于程序体积变大也可能减缓启动速度，&lt;del>是个很玄学的选项&lt;/del>
不过微软文档上表示。&lt;/p>
&lt;blockquote>
&lt;p>For instance, ReadyToRun can be used to reduce the response latency of the first use of Web API in an ASP.NET application.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>比方说呢，R2R 可以加快 ASP.NET Core Web API 的第一次响应速度。&lt;/p>&lt;/blockquote>
&lt;p>更多内容见微软文档&lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/core/deploying/ready-to-run" target="_blank" rel="noopener"
>Microsoft Docs | ReadyToRun development overview&lt;/a>&lt;/p>
&lt;h5 id="非自部署发布">非自部署发布
&lt;/h5>&lt;p>使用 &lt;code>--no-self-contained&lt;/code> 或者 &lt;code>--self-contained false&lt;/code> 来指定不要自部署发布，即不包含.NET runtime。这样做有利于减少发布程序的大小。&lt;/p>
&lt;p>但是在没有.NET runtime的机器上运行时需要先安装.NET runtime。&lt;/p>
&lt;p>不过我的想法是在 docker 里面运行，可以使用 ASP.NET Core 的镜像（通常来说也确实是这样的），包含了 .NET runtime 。所以不需要自部署发布。&lt;/p>
&lt;h5 id="目标平台">目标平台
&lt;/h5>&lt;p>使用 &lt;code>--runtime &amp;lt;RUNTIME_IDENTIFIER&amp;gt;&lt;/code> 或 &lt;code>-r&lt;/code> 来指定目标平台。后面接目标平台标识符，即 Runtime Identifiers (RIDs)。&lt;/p>
&lt;p>RID 列表见微软文档：&lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/core/rid-catalog" target="_blank" rel="noopener"
>Microsoft Docs | Runtime Identifiers (RIDs)&lt;/a>&lt;/p>
&lt;p>因为启用了 R2R 所以需要指定目标平台。&lt;/p>
&lt;p>另外&lt;strong>我觉得&lt;/strong>（并没有根据的胡扯）指定发布平台比全平台编译效果好。&lt;/p>
&lt;h5 id="输出目录">输出目录
&lt;/h5>&lt;p>使用 &lt;code>--output &amp;lt;OUTPUT_DIRECTORY&amp;gt;&lt;/code> 或者 &lt;code>-o&lt;/code> 设置输出目录。&lt;/p>
&lt;h5 id="更多">更多
&lt;/h5>&lt;blockquote>
&lt;p>更多选项见&lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish" target="_blank" rel="noopener"
>Microsoft Docs | dotnet CLI&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h3 id="docker">Docker
&lt;/h3>&lt;h4 id="添加镜像加速">添加镜像加速
&lt;/h4>&lt;p>&lt;del>docker 官方的镜像仓库慢的理解不能&lt;/del> docker hub 已经被防火墙阻断，这边我使用了阿里云的镜像加速服务（因为我是阿里云服务器，这样速度也非常可观）&lt;/p>
&lt;ol>
&lt;li>打开阿里云控制台的容器镜像服务中的&lt;a class="link" href="https://cr.console.aliyun.com/cn-beijing/instances/mirrors" target="_blank" rel="noopener"
>镜像加速器&lt;/a>Tag；&lt;/li>
&lt;li>按照下面的操作文档修改，比如Ubuntu为：
&lt;ol>
&lt;li>进入目录&lt;code>/etc/docker&lt;/code>（如果没有就创建一个）&lt;/li>
&lt;li>编辑文件&lt;code>daemon.json&lt;/code>（如果没有就创建一个）&lt;/li>
&lt;li>写入如下内容：&lt;code>{&amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://&amp;lt;token&amp;gt;.mirror.aliyuncs.com&amp;quot;]}&lt;/code>，网址在上面的“加速器地址”处有写。&lt;/li>
&lt;li>&lt;code>sudo systemctl daemon-reload&lt;/code>重载&lt;/li>
&lt;li>&lt;code>sudo systemctl restart docker&lt;/code>重启docker&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h4 id="dockerfile">Dockerfile
&lt;/h4>&lt;blockquote>
&lt;p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。&lt;/p>&lt;/blockquote>
&lt;h5 id="引用-aspnet-core-镜像">引用 ASP.NET Core 镜像
&lt;/h5>&lt;p>&lt;del>首先我不希望发布自部署应用程序，因为它过于庞大。&lt;/del> 方便起见，可以考虑引用 ASP.NET Core Runtime 的 Docker 镜像：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> mcr.microsoft.com/dotnet/aspnet:5.0&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实际上，使用自部署应用程序+alpine 或许可以发布出体积更小的镜像，但是会稍微麻烦一些。&lt;/p>
&lt;p>这句话引用了 ASP.NET Core 的 docker 镜像，里面有包含 Runtime。&lt;/p>
&lt;h5 id="设置目录">设置目录
&lt;/h5>&lt;p>首先需要使用 &lt;code>COPY&lt;/code> 命令复制我们编译出来的文件，然后使用 &lt;code>WORKDIR&lt;/code> 来指定工作目录（就是启动程序的路径）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Copy Files&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /public&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># Set Workdir&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /public&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>请注意替换成自己编译输出的目录&lt;/p>&lt;/blockquote>
&lt;h5 id="设置时区">设置时区
&lt;/h5>&lt;p>为了确保时间正确，设置一下时区&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">RUN&lt;/span> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Asia/Shanghai&amp;#34;&lt;/span> &amp;gt;/etc/timezone&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，更好的做法是在创建容器时候使用环境变量指定，或在 docker compose 中指定：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">TZ&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Asia/Shanghai&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="开放端口">开放端口
&lt;/h5>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Expose Port 80&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">EXPOSE&lt;/span>&lt;span class="s"> 80&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于 docker 中是生产环境，所以会使用 80 端口而不是默认的 5000 。可以在执行程序的时候更改端口。总之，这里写你要暴露的端口咯。&lt;/p>
&lt;p>当然，你也可以不暴露端口，通过其他手段访问。&lt;/p>
&lt;h5 id="运行程序">运行程序
&lt;/h5>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CMD&lt;/span> ./WebApplication&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>注意替换为你的程序名&lt;/p>&lt;/blockquote>
&lt;p>使用参数 &lt;code>--urls &amp;quot;http://*:6000&amp;quot;&lt;/code> 来设置启动的端口（127.0.0.1为监听本机）。可以使用类似于 &lt;code>--urls &amp;quot;http://*:6000;http://*:6001;http://*:6002;http://*:6003&amp;quot;&lt;/code> 监听多个端口。&lt;/p>
&lt;p>或者你可以使用环境变量和其它方法，可以参考这篇文章：&lt;a class="link" href="https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/" target="_blank" rel="noopener"
>5 ways to set the URLs for an ASP.NET Core app&lt;/a>&lt;/p>
&lt;p>或&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.gaein.cn/passages/set-urls-for-aspnetcore/" target="_blank" rel="noopener"
>为 ASP.NET Core 自定义监听 Url 和端口的五种办法&lt;/a>&lt;/p>
&lt;h4 id="创建容器">创建容器
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker build -t MyWebApplication:v1.4.2 Release/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这句话将会创建一个 docker 容器，命令的格式如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker build -t &amp;lt;container name&amp;gt;:&amp;lt;tag&amp;gt; &amp;lt;directory&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意替换为自己容器名称和标签以及构建出来的目录&lt;/p>
&lt;h4 id="运行容器">运行容器
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run -d -p 6000:80 MyWebApplication:v1.4.2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 &lt;code>-p 6000:80&lt;/code> 的意思是讲容器暴露的 80 端口映射到本机的 6000 端口，而后面的 &lt;code>MyWebApplication:v1.4.2&lt;/code> 则是刚才创建容器时候写的 &lt;code>container name&lt;/code> 和 &lt;code>tag&lt;/code>。&lt;/p></description></item></channel></rss>