[{"content":"A Beginner\u0026rsquo;s Guide to FFmpeg.AutoGen Introduction FFmpeg.AutoGen is an auto-generated unsafe bindings for C#/.NET and Mono. It can be used in C#/.NET to invoke ffmpeg\u0026rsquo;s C/C++ libraries.\nThe usage is the same as C/C++ API so you can refer to ffmpeg official documents. However, in C#/.NET, we need to load the libraries first, which confused me for a long time.\nHere I concluded the some useful information for beginners to start using ffmpeg.AutoGen.\nThis guide addresses the following questions:\nwhich nuget package should I use? how to configure the libraries root path? how to load libraries from system default path? how to solve System.NotSupportedException? which nuget package should I use? - ffmpeg.AutoGen packages packages list FFmpeg.AutoGen has the following packages on NuGet:\nFFmpeg.AutoGen FFmpeg.AutoGen.Abstractions FFmpeg.AutoGen.Bindings.DynamicallyLoaded FFmpeg.AutoGen.Bindings.DynamicallyLinked FFmpeg.AutoGen.Bindings.StaticallyLinked Introduct to each packages FFmpeg.AutoGen.Bindings.DynamicallyLinked FFmpeg.AutoGen.Bindings.DynamicallyLinked uses DllImport to load libraries.\nIt loads libraries from the default path.\nBut the file name passed to DllImport is hard-coded in Windows file naming convention, such as something like \u0026ldquo;avutil-59\u0026rdquo;. That means you can not use this package directly on other platforms. But you can implement a custom resolver to adapt the filename convention from windows to others platforms by using the code below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static class LibraryUtil { public static IntPtr LinuxFfMpegDllImportResolver(string libraryName, Assembly assembly, DllImportSearchPath? searchPath) =\u0026gt; FfMpegDllImportResolverCore(libraryName, assembly, searchPath, \u0026#34;so\u0026#34;); public static IntPtr MacOsFfMpegDllImportResolver(string libraryName, Assembly assembly, DllImportSearchPath? searchPath) =\u0026gt; FfMpegDllImportResolverCore(libraryName, assembly, searchPath, \u0026#34;dylib\u0026#34;); public static IntPtr FfMpegDllImportResolverCore(ReadOnlySpan\u0026lt;char\u0026gt; loadNameSpan, Assembly assembly, DllImportSearchPath? searchPath, string extension) { var partedIndex = loadNameSpan.IndexOf(\u0026#39;-\u0026#39;); // contains 0 or multi \u0026#39;-\u0026#39;, format not ffmpeg library if (partedIndex == -1 || loadNameSpan.LastIndexOf(\u0026#39;-\u0026#39;) != partedIndex) return NativeLibrary.Load(loadNameSpan.ToString(), assembly, searchPath); var libraryName = loadNameSpan[..partedIndex]; // library not in map table, not ffmpeg library if (!DynamicallyLoadedBindings.LibraryVersionMap.ContainsKey(libraryName.ToString())) return NativeLibrary.Load(loadNameSpan.ToString(), assembly, searchPath); var versionName = loadNameSpan[(partedIndex + 1)..]; var styledName = $\u0026#34;{libraryName}.{extension}.{versionName}\u0026#34;; return NativeLibrary.Load(styledName, assembly, searchPath); } } And using thos codes to configure DllImport use custom resolver:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // instantiate the logger before here or change `logger.LogInformation` to `Console.WriteLine` if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) { // not windows var bindingAssembly = typeof(DynamicallyLinkedBindings).Assembly; if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) || RuntimeInformation.IsOSPlatform(OSPlatform.FreeBSD)) { logger.LogInformation(\u0026#34;Linux/FreeBSD platform, use resolver {name} for assembly `{asm}`.\u0026#34;, nameof(LibraryUtil.LinuxFfMpegDllImportResolver), bindingAssembly.GetName()); NativeLibrary.SetDllImportResolver(bindingAssembly, LibraryUtil.LinuxFfMpegDllImportResolver); } else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX)) { logger.LogInformation(\u0026#34;OSX platform, use resolver {name} for assembly `{asm}`.\u0026#34;, nameof(LibraryUtil.LinuxFfMpegDllImportResolver), bindingAssembly.GetName()); NativeLibrary.SetDllImportResolver(bindingAssembly, LibraryUtil.MacOsFfMpegDllImportResolver); } else { throw new PlatformNotSupportedException(); } } FFmpeg.AutoGen.Bindings.DynamicallyLoaded FFmpeg.AutoGen.Bindings.DynamicallyLoaded use LoadLibrary method in Kernel32 library on Windows, use dlopen method in Libdl on Linux and MacOS.\nFFmpeg.AutoGen.Bindings.StaticallyLinked This package use DllImport(\u0026quot;__Internal\u0026quot;) to import libraries, it required you build the library into assembly.\nFFmpeg.AutoGen.Abstractions This package contains definitions about structs and functions. But you can\u0026rsquo;t invoke functions define in this package, because it\u0026rsquo;s only have definitions but no body, you need install others Bindings package and use DynamicallyLinkedBindings.Initialize(); or DynamicallyLoadedBindings.Initialize(); method to initialize.\nFFmpeg.AutoGen This package looks like a combine of FFmpeg.AutoGen.Abstractions and FFmpeg.AutoGen.Bindings.DynamicallyLoaded with a few properties changed.\nThe offical example use ``FFmpeg.AutoGen.Bindings.DynamicallyLoadedBindingsinstead ofFFmpeg.AutoGen, but the README use ffmpeg.RootPath = to set libraries path which is defined inFFmpeg.AutoGen`.\nconclusion of which package should I choose If you\u0026rsquo;re using ffmpeg in Mono, choose FFmpeg.AutoGen.Bindings.StaticallyLinked and FFmpeg.AutoGen.Abstractions.\nIf your app only run on Windows, choose FFmpeg.AutoGen.Bindings.DynamicallyLinked and FFmpeg.AutoGen.Abstractions.\nIf your app running on mult-platform, choose FFmpeg.AutoGen.Bindings.DynamicallyLoaded and FFmpeg.AutoGen.Abstractions or FFmpeg.AutoGen.Bindings.DynamicallyLinked with custom resolver. Use FFmpeg.AutoGen is also a good choice.\nhow to configure the libraries root path? - use prop in DynamicallyLoaded or FFmpeg.AutoGen DynamicallyLinked can\u0026rsquo;t specify a custom root path for libraries.\nIf you want to use the library files which are not in the default search path, use DynamicallyLoaded and set the path to property DynamicallyLoadedBindings.LibrariesPath.\nffmpeg.RootPath from package FFmpeg.AutoGen is the same as DynamicallyLoadedBindings.LibrariesPath.\nBy the way, the libraries root should contains libs like avutil-59.dll on Windows, and libavutil.59.so on Linux.\nhot to load libraries from system default path - just do nothing In the previous section, I explained the libraries load function of each packages. According to Microsoft Docs and Linux manual page we can find the search order.\nSearch order on Windows and Linux On windows, the main search order are:\nApplication directory; System directory; Windows directory; Current work directory; Directories in the PATH environment variable; For more information, see reference:\nDynamic-link library search order - Win32 apps | Microsoft Learn On Linux, the main search order are:\nDirectories in the LD_LIBRARY_PATH environment variable; /etc/ld.so.cache directory; /lib and /usr/lib directories. For more information, see reference:\ndlopen(3) - Linux manual page ld.so(8) - Linux manual page FFmpeg.AutoGen/FFmpeg.AutoGen.Bindings.DynamicallyLoaded/Native at master · Ruslan-B/FFmpeg.AutoGen I have no computer with MacOS, so I haven\u0026rsquo;t figured out the search order on MacOS, but I guess it maybe very like the order on Linux.\nIf you want to use DynamicallyLoaded with default path, just do not modify DynamicallyLoadedBindings.LibrariesPath or ensure its value are string.Empty. This prop will be added to the front of library name and version. Keep it empty and the package will deliver pure library file name to the method which load the library to memory, that will lead the load method use default search path.\nhot to solve System.NotSupportException? - a few debug tips If you invoke a ffmpeg.* function and throw this exception, it is often because you didn\u0026rsquo;t load the libraries successfully.\nFirst, make sure you install the FFmpeg.AutoGen.Bindings or FFmpeg.AutoGen and called the Initialize().\nSecond, make sure your libraries files are in correct path with correct file name. If you use the custom root path, just open it and have a look, If you use system default path, try using the system tools to ensure it can be found, such as ldconfig -p -N | grep lib\u0026lt;name\u0026gt;.\u0026lt;version\u0026gt;.\nThird, make sure all libraries are fine. You can set DynamicallyLoadedBindings.ThrowErrorIfFunctionNotFound to true, then the exception will sent during libraries loading. I suggess you print all libriaries version to ensure they are all loaded with the code below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // instantiate the logger before here or change `logger.Log*` to `Console.WriteLine` try { var version = ffmpeg.av_version_info(); var libraryVersion = new StringBuilder(48 * DynamicallyLoadedBindings.LibraryVersionMap.Count); foreach (var (library, requiredVersion) in DynamicallyLoadedBindings.LibraryVersionMap) { var versionFunc = typeof(ffmpeg).GetMethod($\u0026#34;{library}_version\u0026#34;); var versionInfo = new VersionInfo((uint)(versionFunc?.Invoke(null, null) ?? 0u)); libraryVersion.AppendLine($\u0026#34;\\tLibrary: {library}, require `{requiredVersion}`, load `{versionInfo}`\u0026#34;); } libraryVersion.Remove(libraryVersion.Length - 1, 1); // remove \u0026#39;\\n\u0026#39; logger.LogInformation(\u0026#34;Load ffmpeg, version `{v}`\u0026#34;, version); logger.LogInformation(\u0026#34;Load ffmpeg, libraries:\\n{libInfo}\u0026#34;, libraryVersion); } catch (NotSupportedException e) { logger.LogCritical(e, \u0026#34;Failed to load ffmpeg, exit.\u0026#34;); var appLifeTime = provider.GetRequiredService\u0026lt;IHostApplicationLifetime\u0026gt;(); appLifeTime.StopApplication(); } You can also just add the project source code as a dependency of your project and debug in file FunctionResolverBase.cs or files under Native folder.\n","date":"2025-02-22T00:35:00+08:00","permalink":"https://blog.gaein.cn/passages/beginner-guide-to-ffmpeg-autogen/","title":"A Beginner's Guide to FFmpeg.AutoGen"},{"content":"前言 我发现身边很多朋友确实没有注意过色彩空间的设置，虽然默认的如果全是 sRGB 那足够的稳妥，通常情况下也不会引起任何问题。去深究相机（传感器）、ACR 和 PS 以及屏幕这四个色彩空间也不会提升你的摄影和后期水平。\n当前，不是说这些并不重要，去对显示设备校色和完善工作流程中的色彩空间设置，有助于确保自己所作的后期是有意义的——在另一块校色的屏幕上可以还原出来调色时候自己看到的画面。尽管色彩受到很多方面的影响，不同人有不同的风格，不同人看到的颜色也和其他人脑海中的不尽相同，但是我始终认为，至少应该还原出来调色时候所看到的画面，否则你的创造和成果还只是在你调色当时的那块屏幕上的画面，不具有广泛分发和复现的能力，那创造的成果也是不能分享且不稳定的存在。\n当然，如果你没有耐心也没有任何广色域的设备以及打印需求，请全部选择 sRGB，这样至少不会犯错，总比没有正确设置的准确性要高。\n但是，需要注意的是，如果你没有一台颜色准确的显示器，在所有地方都选择 sRGB 似乎也无济于事，因为计算机不知道如何正确的把颜色转换到你显示器的色彩空间，只能转到 sRGB 然后听天由命吧。\n如果你有这方面的追求、有一个广色域的屏幕或者有一个校色的屏幕，请继续看。\n以下内容全是个人的研究和理解，有错误还请指正。\n举个例子说明下重要性 听说广色域 “更好”？\n当你使用一个没有任何色彩管理的笨蛋软件，在 sRGB 的显示器上打开 Adobe RGB（比 sRGB 要广）的照片之后你发现——他的饱和度甚至还降低了！\n于是，摄影师精心修正的图像，在一个笨蛋软件的手里，变得灰灰暗暗的。\n如下图所示，左侧是支持色彩管理的软件显示的效果（即转换到 sRGB 显示），右侧是不使用色彩管理软件显示的结果（直接将 ProPhoto 当作 sRGB 来显示）。\n更要命的是，如果你是一个没有正确设置色彩空间的摄影师，你看到的是灰灰的，就会把他试图拉回“正常”，而换到正常的软件的情况下，刚刚那张拉回“正常”的图，饱和度已经炸眼了！\n例子中的原因是，软件没有读取 exif 中的色彩空间信息，将 Adobe RGB remap 到了 sRGB，对整张图的色彩范围都进行了一次“压缩”，自然在 Adobe RGB 上正常的在这里就变灰了。\n所以说，全 sRGB 是一个稳妥的选择，至少不会发生以上的情况。\n背景知识 需要对 CIE xyz 以及 RGB 模型有了解，对色彩空间、色域（虽然大多数人都混为一谈了）也有所了解。发现要解释这些绕不开的。\n色域与色彩空间 色域这个词更多在卖显示器的那看见，比如 100% sRGB，不过注意，色域是 “100% sRGB” 而不是 “sRGB”。简单来说，色域是一个设备可以表现的色彩覆盖了某种色彩空间的范围，因此色域也就表现了显示器显示颜色的能力，这里的色彩仅指色度，显示器亮/明度还有另一个指标，准度也是另一个指标，100% 覆盖但是准度不行也是白给。\n而色彩空间，就是算上明度的一个完整空间了，CIE xyz 是最大的，涵盖了所有的颜色，\n景象如何从相机来到你的屏幕 似乎在数码摄影中，这个问题不难回答，把拍摄的 RAW 文件拷贝到硬盘里，打开，就好了。对于你作品的观赏者来说，打开你分发的文件，就好了。\n但是不同相机的传感器前的滤色片是不同的，传感器的摄取色彩的范围是不同的，不同的显示器更是。所以文件的存储、编辑、显示都需要涉及到色彩空间的转换，才能让你看到准确的颜色。\n接下来，就让我们看看这一过程中色彩空间是如何转换的。\n拍摄 光线经过镜头到传感器，经过滤色镜、光电转换、放大后存储在相机内存的 RAW 文件中，通常来说，RAW 文件内是相机特有的色彩空间（由生厂商检测、校正）。同时，如果开启了机内直出，会根据预设调整色调等，然后转换为用户设置的（sRGB/Adobe RGB）色彩空间，并存储在 JPEG 文件。\n将文件从相机拷贝到电脑的过程，由于是复制所以不会进行任何改变。\n此时图片（RAW）的色彩空间是相机特有的色彩空间。JPEG 是用户设置的标准色彩空间。两者内都通过 exif 附加有 icc 校色文件，icc 校色文件可以提供一种色彩空间到另一种的转换，因此无论是否是标准色彩空间，都可以通过其附加的 icc 文件转换为 CIE xyz。\n查看机内直出 JPEG 相机内部存储及查看 相机内部程序将色彩空间从传感器特定的色彩空间转换到 CIE xyz，再转换成你在相机内设置的 sRGB 或 Adobe RGB，存储在文件中。\n查看时通过 icc 文件转换到标准的 CIE xyz，再通过屏幕的校色文件转换到屏幕色彩空间表现出来。\n支持色彩管理的软件 在支持色彩管理的软件中，读取 JPEG icc 并通过其将图片转换到 CIE xyz 空间，再将通过色彩管理中的配置文件（应该配置为屏幕校色文件，如果没有则会使用标准的 sRGB icc），将 CIE xyz 转换到屏幕的色彩空间。\n在 Windows 这种没有全局色彩管理的系统，有可能有软件不使用屏幕校色文件，使用内置的 sRGB 配置进行转换。\n不支持色彩管理的软件 不支持色彩管理的软件不会进行任何的色彩空间转换，直接将其显示，如果此时文件的色彩空间与系统设置的（通常是 sRGB 或屏幕校色文件）不匹配，则颜色饱和度会变低或变高。\nAdobe Photoshop Adobe Photoshop 会读取配置文件，如果色彩空间与菜单“编辑-色彩设置”中的“工作空间”不一致，将询问你的处理方式（如下图）：\n使用嵌入的配置文件（代替工作空间）：不进行转换，使用文件中的色彩空间，并且暂时修改工作空间为文件中的色彩空间； 不会有任何损失 将文档的颜色转换到工作空间：通过配置文件将文件中的色彩空间转换到配置的工作空间；如果工作空间比配置文件中的广，则一般不会有损失，但是如果差的过多而且色深没有增加的话会损失精度 扔掉嵌入的配置文件（不进行色彩管理）：不推荐，行为与 “不支持色彩管理的软件” 的一致，容易引发颜色不匹配等问题。 Adobe Camera Raw 或相机厂商发布的 “解 RAW” 软件 这类软件所作的工作是解码存储在 RAW 中的数据，按照彩色阵列将亮度信息转换为色彩信息。\n首先，将传感器色彩空间转换到 CIE xyz 再转换到到你设置的工作空间，供调色、编辑使用。\n同时，通过校色文件转换工作空间到 CIE xyz 到屏幕色彩空间，供显示、校对使用。\n如何设置色彩空间 在前面的章节中，我们已经提到了在 Adobe Photoshop 和 Adobe Camera Raw 中，色彩空间的转换过程，这涉及到如下四个色彩空间：\n原色彩空间：照片文件中存储的 工作空间：供调色、编辑使用的临时色彩空间 显示空间：供显示器显示所使用的 存储空间：导出文件中的色彩空间 原色彩空间通常在拍摄时候已经决定，没有必要进行修改。如果要编辑直出的 JPEG 的话，可以考虑设置为 Adobe RGB，这样可以存储更广泛的颜色范围供编辑使用。\n工作空间用于处理图像，在调色过程中可能会存在本来在显示器色域范围外的颜色被调整到显示范围内的情况，因此我更倾向于选择更广的 ProPhoto 色彩空间，位深选择 16bit。这样做的好处是可以完全囊括颜色，缺点是内容占用稍多。以及如果编辑的原图是 16bit，由于色彩空间更大但单色的存储空间不变会丧失精度。对于这种情况或许可以修改为空间更小的 Rec.2020 以减少损失，但我使用相机的 RAW 为 12bit，并且我不认为这会带来巨大影响。\n显示空间即显示器的校色文件，未校色的使用标准 sRGB。校色的显示器可以在系统设置中指定校色文件，Adobe 中的 ACM 大概率会使用它（未经考证）。\n存储空间即最终出片的文件中的空间，出于保证最广泛用户的准确考虑，一般使用 sRGB；大部分手机都支持 P3 ，但不能保证因为平台压缩等不会造成色彩的准确性丢失；印刷建议使用 Adobe RGB，但是由于印刷所使用的 Adobe RGB 比 sRGB 要广，成品的颜色可能比 sRGB 显示器上看到的略鲜艳，如果需要严格确保所见即所得请购买 Adobe RGB 显示器。\n系统设置 这一部分主要是确保系统应用了显示器的校色文件来显示颜色。\nWindows 10 打开 “控制面板-色彩管理”，选择工作显示器后，选中 “显示器校色文件” 设置为默认，点击右下角的配置，点击 “将系统默认值重设为当前值”。\nWindows 11 打开 “设置-系统-显示”，在 “颜色配置文件” 处选择校色的配置文件。可以考虑点击配置文件后点击 “设置为系统默认”。如下图。\n可以考虑 “启用自动颜色管理” ，该功能可以将完全不管颜色管理的软件输出的内容从 sRGB 转到屏幕色彩空间。\nAdobe Camera Raw 打开 “首选项（右上角齿轮图标按钮）-工作流程”，色彩空间选择 “ProPhoto RGB” 或 “Rec.2020”，色彩深度选择 “16位/通道”（理由见前文关于工作空间所阐述的内容）。如下图。\nAdobe Photoshop 打开 “编辑-颜色设置”。选择 “北美印前2” ，修改工作空间为你在 ACR 中设置的色彩空间，同时确保 “显示器 RGB” 在列表中并且是正确的（确保正常加载）。如下图。\n图片查看软件 以 ImageGlass 为例，我通常使用该软件来查看图片。\n打开 “设置-图像” ，在 “色彩管理” 一节，“色彩配置文件” 中选择 “当前显示器配置”。\n参考 Manage Adobe Camera Raw settings A Color Managed Raw Workflow——From Camera to Final Print ","date":"2024-12-04T10:54:00+08:00","permalink":"https://blog.gaein.cn/passages/configure-photography-workflow-colorspace/","title":"正确设置摄影工作流程中 Adobe Camera Raw 和 Photoshop 的色彩空间"},{"content":"前言 在尼康大 F 单反所开创的时代中，尼康作为光学大厂同样也推出了非常多款优秀的尼克尔镜头，这些手动镜头全部使用 F 卡口，但由于其标识的变化，令人难以分清。因此本文详细讲解了 F 卡口手动镜头的各种不同型号，旨在帮助读者理清其发展顺序以及方便在购买中进行辨别。\nAUTO/Ai 与 Ai-s 实际上，这些镜头并非是不同的 “口” ，相反，他们同样属于 F 卡口，拥有着同样的尺寸、法兰距与接口结构。但是，由于所采用的光圈耦合技术不同，他们并非完全兼容。\n不同于后期的 AF-D/G 等，此处的 AUTO/Ai/Ai-s 代表的与机器测光联动的方式。最早出现的是 AUTO，之后是 Ai 以及改进的 Ai-s。再之后变过渡到了自动对焦时代。但实际上 AF 系列镜头依旧属于 Ai/Ai-s。\nAUTO-自动测光 AUTO，自动，现在听起来让人感觉像是能够自动对焦的东西。但是那个时候的自动指的可不是对焦，而是测光。\n曝光的三要素：ISO、光圈与快门。ISO 由所装载的胶卷所决定，一卷胶卷为同样的 ISO，因此该值在机身上设置，而快门也由机身调节，但是光圈是由镜头所调节，这时候要测算曝光就存在一个问题——如何让机身知晓镜头上的光圈大小？\n于是尼康在卡口外设置了一个小连杆，挂到镜头的光圈环，其下是一个滑动变阻器，与快门和 ISO 连接，通过模拟电路让合适的电流流经电流表，变指示出了曝光的程度。\n这样当然也有一个问题，快门没有开启的时候镜头始终处于最大光圈（方便你的取景和拍摄），而相机并不知道最大光圈值是多少。于是，所有镜头的联动装置都设置在 F5.6 处，装上后需要先拧到最小光圈，再拧到最大光圈。\n型号标识以及发展 AUTO 的镜头普遍为银色+黑色配色，而且对焦移动的镜组外面是银色、非圆形，所以被称为“菠萝”。\n最早期的镜头，使用的是 “日本光学(NIPPON KOGAKU JAPAN)” 的名字，并且使用厘米作为单位标记焦距，该产品系列的标识使用的是 “Nikkor-\u0026lt;结构\u0026gt;”，通过一个字母来表示当前镜头的结构，比如 Nikkor-H、 Nikkor-S 等。镜头上刻的型号类似于：\nNIPPON KOGAKU JAPAN No.3xxxxx NIKKOR-S 1:1.4 f=5cm\n生成较少产品后，则使用毫米作为单位标注焦距，如：\nNIPPON KOGAKU JAPAN No.6xxxxx NIKKOR-S 1:1.4 f=50mm\n而后，公司改用日本光学生产的第一款相机——“尼康”，镜头上刻的字也从 \u0026ldquo;NIPPON KOGAKU JAPAN\u0026rdquo; 改为 \u0026ldquo;Nikon\u0026rdquo;：\nNikon No.10xxxxx NIKKOR-S 1:1.4 f=50mm\n而后使用了多层镀膜技术后生成的镜头，则标记为 Nikkor-\u0026lt;结构\u0026gt;·C，如：\nNikon No.12xxxxx NIKKOR-S·C 1:1.4 f=50mm\nAUTO 的最后一代为改进了镀膜后的镜头，被称为 “K版”，而官方的说法则是 New Nikkor(新型尼克尔)。\n这种镜头几乎和 Ai 的设计一致：整体呈黑色，只有光圈环为银色，但光圈耦合拨杆为 AUTO 的。上面的刻的型号也和 Ai 的一样，只有 Nikon 和 Nikkor 以及焦距、光圈等，如：\nNikon Nikkor 50mm 1:1.4 2xxxxxx\n当然，也有很多官方和民间从 AUTO 改为 Ai 耦合系统的。\n光学素质 出现多层镀膜技术后的普遍较好，C 版 和 K 版都相当不错。\n具体型号 超广角 小于 14mm Nikon Auto Nikkor 7.5mm F5.6 鱼眼\nNikon Auto Nikkor 8mm F2.8 鱼眼\nNikon Auto Nikkor T10.5cm F4\n14mm-20mm Nikon UW-Nikkor 15mm F2.8 NEW （ファインダー付）\nNikon Auto Nikkor 15mm F5.6 C\nNikon Auto Nikkor 16mm F3.5 鱼眼\nNikon New Nikkor 16mm F3.5 鱼眼\nNikon New Nikkor 18mm F4\n广角 20mm Nikon Auto Nikkor 20mm F3.5\nNikon New Nikkor 20mm F4\n24mm Nikon Auto Nikkor 24mm F2.8 Nikon Auto Nikkor 24mm F2.8 C Nikon New Nikkor 24mm F2.8 28mm Nikon Auto Nikkor 28mm F2\nNikon Auto Nikkor 28mm F2 C\nNikon New Nikkor 28mm F2\nNikon New Nikkor 28mm F2.8\nNikon Auto Nikkor 28mm F3.5\nNikon Auto Nikkor 28mm F3.5 C\nNikon New Nikkor 28mm F3.5\nNikon New Nikkor 28-45mm F4.5\n35mm Nikon Auto Nikkor 35mm F1.4\nNikon Auto Nikkor 35mm F1.4 C\nNikon New Nikkor 35mm F1.4\nNikon Auto Nikkor 35mm F2\nNikon Auto Nikkor 35mm F2 C\nNikon New Nikkor 35mm F2\nNikon Auto Nikkor 35mm F2.8\nNikon Auto Nikkor 35mm F2.8 C\nNikon New Nikkor 35mm F2.8\n标准 35-50mm(不含) Nikon Auto Nikkor 43-86mm F3.5\nNikon Auto Nikkor 43-86mm F3.5 C\nNikon New Nikkor 43-86mm F3.5\nNikon Auto Nikkor 45mm F2.8 GN\nNikon Auto Nikkor 45mm F2.8 GN C\n50-70mm(不含) Nikon Auto Nikkor 50mm F1.4\nNikon Auto Nikkor 50mm F1.4 C\nNikon New Nikkor 50mm F1.4\nNikon Auto Nikkor 50mm F2\nNikon Auto Nikkor 50mm F2 C\nNikon New Nikkor 50mm F2\nNikon Auto Nikkor 55mm F1.2\nNikon Auto Nikkor 55mm F1.2 C\nNikon New Nikkor 55mm F1.2\nNikon Auto Micro Nikkor 55mm F3.5\nNikon Auto Micro Nikkor 55mm F3.5 C\nNikon New Micro Nikkor 55mm F3.5\nNikon Nikkor-S Auto 5.8cm F1.4\n长焦 70mm-105mm(不含) Nikon Auto Nikkor 85mm F1.8 Nikon Auto Nikkor 85mm F1.8 C Nikon New Nikkor 85mm F1.8 105mm Nikon Auto Nikkor 105mm F2.5\nNikon Auto Nikkor 105mm F2.5 C\nNikon New Nikkor 105mm F2.5\nNikon New Nikkor 105mm F4 Micro\n135mm Nikon New Nikkor 135mm F2\nNikon Auto Nikkor 135mm F2.8\nNikon Auto Nikkor 135mm F2.8 C\nNikon New Nikkor 135mm F2.8\nNikon Auto Nikkor 135mm F3.5\nNikon Auto Nikkor 135mm F3.5 C\nNikon New Nikkor 135mm F3.5\n超长焦 180mm Nikon Auto Nikkor 180mm F2.8 200mm-300mm(不含) (变焦最大值) Nikon Auto Nikkor 200mm F4\nNikon Auto Nikkor 200mm F4 C\nNikon New Nikkor 200mm F4\nNikon Auto Nikkor 80-200mm F4.5\nNikon Auto Nikkor 80-200mm F4.5 C\nNikon New Nikkor 80-200mm F4.5\nNikon Auto Nikkor 85-250mm F4-4.5\n300mm-400mm(不含) (变焦最大值) Nikon Auto Nikkor 50-300mm F4.5\nNikon New Nikkor 50-300mm F4.5\nNikon Auto Nikkor 300mm F4.5\nNikon New Nikkor 300mm F4.5\nNikon New Nikkor 300mm F4.5 ED\n400mm-600mm(不含) (变焦最大值) Nikon Auto Nikkor 400mm F4.5 フォーカシングユニット付 600mm-800mm(不含) (变焦最大值) Nikon Auto Nikkor 200-600mm F9.5 Nikon Auto Nikkor 200-600mm F9.5-10.5 Nikon New Nikkor 200-600mm F9.5 800mm-1200mm(含) (变焦最大值) Nikon Auto Nikkor 800mm F8 C\nNikon New Nikkor 360-1200mm F11 ED\n不行怎么尼玛尼康出了这么多镜头，那先咕咕了\n","date":"2024-11-09T15:17:00+08:00","permalink":"https://blog.gaein.cn/passages/nikkor-manual-lens/","title":"尼康手动镜头发展历程及型号解析"},{"content":"基础工具 安装：\nzsh oh-my-zsh vim 7zip git curl 发行版配置 编辑：/etc/apk/repositories ，开启社区仓库\nLAN 侧配置 IP 地址 编辑 /etc/network/interfaces，加入如下内容（以 lan 口为 eth1 为例）：\n1 2 3 4 auto eth1 iface eth1 inet static address 172.26.0.1 netmask 255.255.255.0 DHCP DHCP 使用 kea。ISC DHCP 已经在 2022 年宣布停止维护，kea 为其继任者。\n使用 apk add kea 来安装。\n编辑 /etc/kea/kea-dhcp4.conf：\n注：以下内容中使用 eth1 172.26.0.1 作为路由器的 LAN 口网卡和 IP 地址示例，使用 172.26.0.0/24（子网掩码 255.255.255.0）作为 LAN 子网，使用 172.26.0.100-172.26.0.200 作为 DHCP 地址池。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 diff --git a/kea-dhcp4.conf b/kea-dhcp4.conf index a26ae75..e9c578a 100644 --- a/kea-dhcp4.conf +++ b/kea-dhcp4.conf @@ -31,7 +31,7 @@ // See section 8.2.4 for more details. You probably want to add just // interface name (e.g. \u0026#34;eth0\u0026#34; or specific IPv4 address on that // interface name (e.g. \u0026#34;eth0/192.0.2.1\u0026#34;). - \u0026#34;interfaces\u0026#34;: [ ] + \u0026#34;interfaces\u0026#34;: [ \u0026#34;eth1\u0026#34; ] // Kea DHCPv4 server by default listens using raw sockets. This ensures // all packets, including those sent by directly connected clients @@ -149,7 +149,7 @@ // but it\u0026#39;s a lot of writing, so it\u0026#39;s easier to do this instead: { \u0026#34;name\u0026#34;: \u0026#34;domain-name-servers\u0026#34;, - \u0026#34;data\u0026#34;: \u0026#34;192.0.2.1, 192.0.2.2\u0026#34; + \u0026#34;data\u0026#34;: \u0026#34;119.29.29.29\u0026#34; }, // Typically people prefer to refer to options by their names, so they @@ -159,7 +159,7 @@ // \u0026#34;name\u0026#34;: \u0026#34;domain-name\u0026#34; or \u0026#34;code\u0026#34;: 15. { \u0026#34;code\u0026#34;: 15, - \u0026#34;data\u0026#34;: \u0026#34;example.org\u0026#34; + \u0026#34;data\u0026#34;: \u0026#34;gaein.cn\u0026#34; }, // Domain search is also a popular option. It tells the client to @@ -168,7 +168,7 @@ // foo.mydomain.example.com and if it fails, then as foo.example.com { \u0026#34;name\u0026#34;: \u0026#34;domain-search\u0026#34;, - \u0026#34;data\u0026#34;: \u0026#34;mydomain.example.com, example.com\u0026#34; + \u0026#34;data\u0026#34;: \u0026#34;cn-tvs-alpine-homerouter\u0026#34; }, // String options that have a comma in their values need to have @@ -217,31 +217,6 @@ // Based on the class information, you can then allow or reject clients // to use certain subnets, add special options for them or change values // of some fixed fields. - \u0026#34;client-classes\u0026#34;: [ - { - // This specifies a name of this class. It\u0026#39;s useful if you need to - // reference this class. - \u0026#34;name\u0026#34;: \u0026#34;voip\u0026#34;, - - // This is a test. It is an expression that is being evaluated on - // each incoming packet. It is supposed to evaluate to either - // true or false. If it\u0026#39;s true, the packet is added to specified - // class. See Section 12 for a list of available expressions. There - // are several dozens. Section 8.2.14 for more details for DHCPv4 - // classification and Section 9.2.19 for DHCPv6. - \u0026#34;test\u0026#34;: \u0026#34;substring(option[60].hex,0,6) == \u0026#39;Aastra\u0026#39;\u0026#34;, - - // If a client belongs to this class, you can define extra behavior. - // For example, certain fields in DHCPv4 packet will be set to - // certain values. - \u0026#34;next-server\u0026#34;: \u0026#34;192.0.2.254\u0026#34;, - \u0026#34;server-hostname\u0026#34;: \u0026#34;hal9000\u0026#34;, - \u0026#34;boot-file-name\u0026#34;: \u0026#34;/dev/null\u0026#34; - - // You can also define option values here if you want devices from - // this class to receive special options. - } - ], // Another thing possible here are hooks. Kea supports a powerful mechanism // that allows loading external libraries that can extract information and @@ -294,14 +269,14 @@ \u0026#34;id\u0026#34;: 1, // This is mandatory parameter for each subnet. - \u0026#34;subnet\u0026#34;: \u0026#34;192.0.2.0/24\u0026#34;, + \u0026#34;subnet\u0026#34;: \u0026#34;172.26.66.0/23\u0026#34;, // Pools define the actual part of your subnet that is governed // by Kea. Technically this is optional parameter, but it\u0026#39;s // almost always needed for DHCP to do its job. If you omit it, // clients won\u0026#39;t be able to get addresses, unless there are // host reservations defined for them. - \u0026#34;pools\u0026#34;: [ { \u0026#34;pool\u0026#34;: \u0026#34;192.0.2.1 - 192.0.2.200\u0026#34; } ], + \u0026#34;pools\u0026#34;: [ { \u0026#34;pool\u0026#34;: \u0026#34;172.26.67.2 - 172.26.67.100\u0026#34; } ], // These are options that are subnet specific. In most cases, // you need to define at least routers option, as without this @@ -312,7 +287,7 @@ // For each IPv4 subnet you most likely need to specify at // least one router. \u0026#34;name\u0026#34;: \u0026#34;routers\u0026#34;, - \u0026#34;data\u0026#34;: \u0026#34;192.0.2.1\u0026#34; + \u0026#34;data\u0026#34;: \u0026#34;172.26.66.1\u0026#34; } ], @@ -335,31 +310,32 @@ // It\u0026#39;s a rather simple reservation: just an address and nothing // else. { - \u0026#34;hw-address\u0026#34;: \u0026#34;1a:1b:1c:1d:1e:1f\u0026#34;, - \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.201\u0026#34; + \u0026#34;hw-address\u0026#34;: \u0026#34;DC:65:55:8A:F6:27\u0026#34;, + \u0026#34;ip-address\u0026#34;: \u0026#34;172.26.67.1\u0026#34;, + \u0026#34;hostname\u0026#34;: \u0026#34;h3c-ap\u0026#34; }, // This is a reservation for a specific client-id. It also shows // the this client will get a reserved hostname. A hostname can // be defined for any identifier type, not just client-id. - { - \u0026#34;client-id\u0026#34;: \u0026#34;01:11:22:33:44:55:66\u0026#34;, - \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.202\u0026#34;, - \u0026#34;hostname\u0026#34;: \u0026#34;special-snowflake\u0026#34; - }, + // { + // \u0026#34;client-id\u0026#34;: \u0026#34;01:11:22:33:44:55:66\u0026#34;, + // \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.202\u0026#34;, + // \u0026#34;hostname\u0026#34;: \u0026#34;special-snowflake\u0026#34; + // }, // The third reservation is based on DUID. This reservation defines // a special option values for this particular client. If the // domain-name-servers option would have been defined on a global, // subnet or class level, the host specific values take preference. - { - \u0026#34;duid\u0026#34;: \u0026#34;01:02:03:04:05\u0026#34;, - \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.203\u0026#34;, - \u0026#34;option-data\u0026#34;: [ { - \u0026#34;name\u0026#34;: \u0026#34;domain-name-servers\u0026#34;, - \u0026#34;data\u0026#34;: \u0026#34;10.1.1.202, 10.1.1.203\u0026#34; - } ] - }, + // { + // \u0026#34;duid\u0026#34;: \u0026#34;01:02:03:04:05\u0026#34;, + // \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.203\u0026#34;, + // \u0026#34;option-data\u0026#34;: [ { + // \u0026#34;name\u0026#34;: \u0026#34;domain-name-servers\u0026#34;, + // \u0026#34;data\u0026#34;: \u0026#34;10.1.1.202, 10.1.1.203\u0026#34; + // } ] + // }, // The fourth reservation is based on circuit-id. This is an option // inserted by the relay agent that forwards the packet from client @@ -370,31 +346,31 @@ // reservations-global, reservations-in-subnet, // reservations-out-of-pool (subnet specific parameters) // and host-reservation-identifiers (global parameter). - { - \u0026#34;client-id\u0026#34;: \u0026#34;01:12:23:34:45:56:67\u0026#34;, - \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.204\u0026#34;, - \u0026#34;option-data\u0026#34;: [ - { - \u0026#34;name\u0026#34;: \u0026#34;vivso-suboptions\u0026#34;, - \u0026#34;data\u0026#34;: \u0026#34;4491\u0026#34; - }, - { - \u0026#34;name\u0026#34;: \u0026#34;tftp-servers\u0026#34;, - \u0026#34;space\u0026#34;: \u0026#34;vendor-4491\u0026#34;, - \u0026#34;data\u0026#34;: \u0026#34;10.1.1.202, 10.1.1.203\u0026#34; - } - ] - }, + // { + // \u0026#34;client-id\u0026#34;: \u0026#34;01:12:23:34:45:56:67\u0026#34;, + // \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.204\u0026#34;, + // \u0026#34;option-data\u0026#34;: [ + // { + // \u0026#34;name\u0026#34;: \u0026#34;vivso-suboptions\u0026#34;, + // \u0026#34;data\u0026#34;: \u0026#34;4491\u0026#34; + // }, + // { + // \u0026#34;name\u0026#34;: \u0026#34;tftp-servers\u0026#34;, + // \u0026#34;space\u0026#34;: \u0026#34;vendor-4491\u0026#34;, + // \u0026#34;data\u0026#34;: \u0026#34;10.1.1.202, 10.1.1.203\u0026#34; + // } + // ] + // }, // This reservation is for a client that needs specific DHCPv4 // fields to be set. Three supported fields are next-server, // server-hostname and boot-file-name - { - \u0026#34;client-id\u0026#34;: \u0026#34;01:0a:0b:0c:0d:0e:0f\u0026#34;, - \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.205\u0026#34;, - \u0026#34;next-server\u0026#34;: \u0026#34;192.0.2.1\u0026#34;, - \u0026#34;server-hostname\u0026#34;: \u0026#34;hal9000\u0026#34;, - \u0026#34;boot-file-name\u0026#34;: \u0026#34;/dev/null\u0026#34; - }, + // { + // \u0026#34;client-id\u0026#34;: \u0026#34;01:0a:0b:0c:0d:0e:0f\u0026#34;, + // \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.205\u0026#34;, + // \u0026#34;next-server\u0026#34;: \u0026#34;192.0.2.1\u0026#34;, + // \u0026#34;server-hostname\u0026#34;: \u0026#34;hal9000\u0026#34;, + // \u0026#34;boot-file-name\u0026#34;: \u0026#34;/dev/null\u0026#34; + // }, // This reservation is using flexible identifier. Instead of // relying on specific field, sysadmin can define an expression // similar to what is used for client classification, @@ -405,10 +381,10 @@ // // Note: flexible identifier requires flex_id hook library to be // loaded to work. - { - \u0026#34;flex-id\u0026#34;: \u0026#34;\u0026#39;s0mEVaLue\u0026#39;\u0026#34;, - \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.206\u0026#34; - } + // { + // \u0026#34;flex-id\u0026#34;: \u0026#34;\u0026#39;s0mEVaLue\u0026#39;\u0026#34;, + // \u0026#34;ip-address\u0026#34;: \u0026#34;192.0.2.206\u0026#34; + // } // You can add more reservations here. ] // You can add more subnets there. DNS 待补充\nWAN 侧配置 IP 地址以及上网方式 使用 DHCP 编辑 /etc/network/interfaces，加入如下内容（以 wan 口为 eth0 为例）：\n1 2 auto eth0 iface eth0 inet dhcp 使用 PPPoE 使用 apk add ppp-pppoe 安装包。\n编辑 /etc/ppp/peers/isp，写入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 noipdefault defaultroute replacedefaultroute hide-password #lcp-echo-interval 30 #lcp-echo-failure 4 noauth persist #mtu 1492 #maxfail 0 #holdoff 20 plugin pppoe.so eth0 # WAN 侧网卡 user \u0026#34;ip1**********\u0026#34; # PPPoE 用户名 #usepeerdns # 使用运营商 DNS 编辑 /etc/ppp/chap-secrets，写入以下内容：\n1 2 # \u0026lt;PPPoE 用户名\u0026gt; \u0026lt;服务器\u0026gt; \u0026lt;PPPoE 密码\u0026gt; \u0026#34;ip1**********\u0026#34; * \u0026#34;********\u0026#34; 编辑完后可使用 pon isp 和 poff 来连接和断开 PPPoE。\n如果需要自动建立连接，使用 apk add ifupdown-ng-ppp 添加包，并编写 /etc/network/interfaces 后加入如下内容：\n1 2 3 auto ppp0 iface ppp0 inet ppp provider isp 本小节中 isp 为 /etc/ppp/peers/ 下的文件名，可以自行更改。\n注意： 由于 PPPoE 是将 PPP 协议 “抬旗” 到了 “二层之上、三层之下” 的位置，因此，原本 1500 Mtu 的 Ethernet 内又塞了 PPP，其协议占据了 8 字节，因此对于三层协议来说，Mtu 由 1500 降低到了 1492（典型情况）。此时，由 lan 传入的（Mtu 1500）的超过 PPPoE 网卡的 Mtu 包将无法正常发送，造成 “能 ping 通、能解析却不能打开部分网页” 的现象。**具体解决方案参考防火墙配置中的 PPPoE 小节。**顺便一提，这一做法在 openwrt 的界面中对应的是 “MSS 钳制”。\nNAT、防护墙等中间处理配置 sysctl 开启内核相关参数\nBBR 输入 modprobe tcp_bbr ，该命令无输出\n编辑 /etc/sysctl.d/90-tcp-bbr.conf，写入如下内容：\n1 2 net.core.default_qdisc=fq_codel net.ipv4.tcp_congestion_control=bbr IP Forward 编辑 /etc/sysctl.d/90-IPv4-forwarding.conf，写入如下内容：\n1 net.ipv4.ip_forward=1 完成后使用 sysctl -p 生效。\n防火墙\u0026amp;NAT 使用 apk add nftables 安装防火墙。\n编辑 /etc/nftables.d/90-nat.nft，写入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/sbin/nft -f table inet nat { chain prerouting { type nat hook prerouting priority dstnat; policy accept; } chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ppp0\u0026#34; masquerade } } 编辑 /etc/nftables.d/90-filter.nft，写入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/sbin/nft -f table inet filter { chain input { iifname \u0026#34;eth1\u0026#34; accept } chain forward { type filter hook forward priority filter; policy accept; tcp flags syn tcp option maxseg size set rt mtu } chain output { type filter hook output priority filter; policy accept; } } 其他的如 ICMP 等内容在 /etc/nftables.nft 中已经默认配好，如果喜欢可以移至此文件方便管理。\nPPPoE 或两侧 Mtu 不同 编辑 /etc/nftables.d/90-filter.nft，在 chain forward 中加入如下内容：\n1 tcp flags syn tcp option maxseg size set rt mtu 当然，你可能发现了，这一条是对 tcp 协议设置的，不仅需要解协议而且不对其他协议生效。可以将两个网卡的 MTU 设置为相同值，只会在内网损失少量的利用率。\n全锥形 NAT 参考：Chion82/netfilter-full-cone-nat: A kernel module to turn MASQUERADE into full cone SNAT\n其它软件 这里使用：daeuniverse/dae\n系统要求 uname -r 确保大于 5.8\n执行：(zcat /proc/config.gz || cat /boot/config-virt) | grep -E 'CONFIG_(DEBUG_INFO|DEBUG_INFO_BTF|KPROBES|KPROBE_EVENTS|BPF|BPF_SYSCALL|BPF_JIT|BPF_STREAM_PARSER|NET_CLS_ACT|NET_SCH_INGRESS|NET_INGRESS|NET_EGRESS|NET_CLS_BPF|BPF_EVENTS|CGROUPS)=|# CONFIG_DEBUG_INFO_REDUCED is not set'\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CONFIG_BPF=y CONFIG_BPF_SYSCALL=y CONFIG_BPF_JIT=y CONFIG_CGROUPS=y CONFIG_KPROBES=y CONFIG_NET_INGRESS=y CONFIG_NET_EGRESS=y CONFIG_NET_SCH_INGRESS=m CONFIG_NET_CLS_BPF=m CONFIG_NET_CLS_ACT=y CONFIG_BPF_STREAM_PARSER=y CONFIG_DEBUG_INFO=y # CONFIG_DEBUG_INFO_REDUCED is not set CONFIG_DEBUG_INFO_BTF=y CONFIG_KPROBE_EVENTS=y CONFIG_BPF_EVENTS=y 我使用的 alpine-3.19 满足\n参考：Run on Alpine Linux\n/etc/rc.conf rc_cgroup_mode=\u0026quot;unified\u0026quot;\nrc-update add cgroups boot\n/etc/init.d/sysfs #mount_misc\n安装 wget https://github.com/daeuniverse/dae-installer/raw/main/installer.sh\nchmod +x installer.sh\nmkdir /etc/dae\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 # load all dae files placed in ./config.d/ include { config.d/*.dae } global { ##### Software options. # tproxy port to listen on. It is NOT a HTTP/SOCKS port, and is just used by eBPF program. # In normal case, you do not need to use it. tproxy_port: 12345 # Set it true to protect tproxy port from unsolicited traffic. Set it false to allow users to use self-managed # iptables tproxy rules. tproxy_port_protect: true # Set non-zero value to enable pprof. pprof_port: 0 # If not zero, traffic sent from dae will be set SO_MARK. It is useful to avoid traffic loop with iptables tproxy # rules. so_mark_from_dae: 0 # Log level: error, warn, info, debug, trace. log_level: info # Disable waiting for network before pulling subscriptions. disable_waiting_network: false # Enable fast redirect for local TCP connections. There is a known kernel issue that breaks certain clients/proxies, such as nadoo/glider. Users may enable this experimental option at their own risks. enable_local_tcp_fast_redirect: false ##### Interface and kernel options. # The LAN interface to bind. Use it if you want to proxy LAN. # Multiple interfaces split by \u0026#34;,\u0026#34;. lan_interface: eth1 # The WAN interface to bind. Use it if you want to proxy localhost. # Multiple interfaces split by \u0026#34;,\u0026#34;. Use \u0026#34;auto\u0026#34; to auto detect. wan_interface: auto # Automatically configure Linux kernel parameters like ip_forward and send_redirects. Check out # https://github.com/daeuniverse/dae/blob/main/docs/en/user-guide/kernel-parameters.md to see what will dae do. auto_config_kernel_parameter: true ##### Node connectivity check. # Host of URL should have both IPv4 and IPv6 if you have double stack in local. # First is URL, others are IP addresses if given. # Considering traffic consumption, it is recommended to choose a site with anycast IP and less response. #tcp_check_url: \u0026#39;http://cp.cloudflare.com\u0026#39; tcp_check_url: \u0026#39;http://cp.cloudflare.com,1.1.1.1,2606:4700:4700::1111\u0026#39; # The HTTP request method to `tcp_check_url`. Use \u0026#39;HEAD\u0026#39; by default because some server implementations bypass # accounting for this kind of traffic. tcp_check_http_method: HEAD # This DNS will be used to check UDP connectivity of nodes. And if dns_upstream below contains tcp, it also be used to check # TCP DNS connectivity of nodes. # First is URL, others are IP addresses if given. # This DNS should have both IPv4 and IPv6 if you have double stack in local. #udp_check_dns: \u0026#39;dns.google.com:53\u0026#39; udp_check_dns: \u0026#39;dns.google.com:53,8.8.8.8,2001:4860:4860::8888\u0026#39; check_interval: 120s # G/oup will switch node only when new_latency \u0026lt;= old_latency - tolerance. check_tolerance: 50ms ##### Connecting options. # Optional values of dial_mode are: # 1. \u0026#34;ip\u0026#34;. Dial proxy using the IP from DNS directly. This allows your ipv4, ipv6 to choose the optimal path # respectively, and makes the IP version requested by the application meet expectations. For example, if you # use curl -4 ip.sb, you will request IPv4 via proxy and get a IPv4 echo. And curl -6 ip.sb will request IPv6. # This may solve some wierd full-cone problem if your are be your node support that. Sniffing will be disabled # in this mode. # 2. \u0026#34;domain\u0026#34;. Dial proxy using the domain from sniffing. This will relieve DNS pollution problem to a great extent # if have impure DNS environment. Generally, this mode brings faster proxy response time because proxy will # re-resolve the domain in remote, thus get better IP result to connect. This policy does not impact routing. # That is to say, domain rewrite will be after traffic split of routing and dae will not re-route it. # 3. \u0026#34;domain+\u0026#34;. Based on domain mode but do not check the reality of sniffed domain. It is useful for users whose # DNS requests do not go through dae but want faster proxy response time. Notice that, if DNS requests do not # go through dae, dae cannot split traffic by domain. # 4. \u0026#34;domain++\u0026#34;. Based on domain+ mode but force to re-route traffic using sniffed domain to partially recover # domain based traffic split ability. It doesn\u0026#39;t work for direct traffic and consumes more CPU resources. dial_mode: domain+ # Timeout to waiting for first data sending for sniffing. It is always 0 if dial_mode is ip. Set it higher is useful # in high latency LAN network. sniffing_timeout: 100ms # TLS implementation. tls is to use Go\u0026#39;s crypto/tls. utls is to use uTLS, which can imitate browser\u0026#39;s Client Hello. tls_implementation: tls # The Client Hello ID for uTLS to imitate. This takes effect only if tls_implementation is utls. # See more: https://github.com/daeuniverse/dae/blob/331fa23c16/component/outbound/transport/tls/utls.go#L17 utls_imitate: chrome_auto } # dns sniff see: /etc/dae/config.d/dns.dae # node and group: see /etc/dae/config.d/nodes.dae # routing: see /etc/dae/config.d/route.dae ","date":"2024-10-06T21:22:00+08:00","permalink":"https://blog.gaein.cn/passages/setup-apline-as-router/","title":"将 alpine 系统配置为软路由"},{"content":"功能 定期检查阿里云CDN所使用的SSL证书是否临近到期，如果临近到期则使用本地的签发的证书进行更新。\n证书的签发仍由 certbot 或 acme.sh 等工具完成，这里只涉及到将本地的证书文件部署到 阿里云CDN。\n项目地址：nidbCN/AliCdnSSLWorker: 自动读取证书文件并上传到阿里云CDN\n使用场景 没错，阿里云ECS、阿里云DNS、阿里云CDN，但是问题来了——签不起阿里云的证书了。\n之前阿里云的免费证书随便签，再后来改成一年20个，这都没啥，毕竟在阿里云的控制台里面手动签一个也没啥麻烦，但是从今年开始，证书的有效期变成了仨月，加之这么多证书签发的时间也不尽相同，这就让我不得不经常性的去签发、更新证书。\n在懒得换证书导致网站宕了一阵时间后，准备把证书换到 Let\u0026rsquo;s Encrypt 签发的 SSL 证书了。签发之类的自然有脚本，也可以用阿里云DNS进行验证。我使用的是 Nginx Proxy Manager 里面内建的 ACME，由于我不想破坏这个程序的环境，不愿意再里面再去植入签发完成后去调用我的程序上传等，因此我决定使用挂载证书目录，定期检查实际部署证书的有效期实际再扫描内部证书文件并上传的方法。\n当然，也预留了 HTTP 接口，可以在证书签发完成后通过 curl 等命令调用去更新所有受管理的证书。\n使用方法 安装 使用二进制 Github 上没有提供预编译的二进制 因为我懒 有空传好吧 因此需要使用 .NET SDK8 进行编译。\n进入项目目录后使用\n1 dotnet publish -c Release 即可编译并创建发布，当然如果临时调试等使用可以使用 dotnet run 运行。\n使用 docker 使用 docker build -t \u0026lt;tag\u0026gt; . 即可编译容器。\n或使用 docker pull registry.cn-beijing.aliyuncs.com/nidb-cr/alicdn-ssl-worker:git 拉取编译好的镜像。\n按照 “配置” 章节的内容配置好选项。\n拉取完成后使用 docker run 运行即可。参数自行编写，如果不会推荐使用下面的 docker compose。\n使用 docker compose 以下为示例 docker compose 文件，将其内容写入到 docker-compose.yaml。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 volumes: ssl_data: driver: local driver_opts: type: none o: bind device: \u0026#39;/data/example/letsencrypt\u0026#39; configs: alicdn-ssl.conf: file: \u0026#39;./alicdn-ssl/appsettings.json\u0026#39; services: cdn-ssl: image: \u0026#39;registry.cn-beijing.aliyuncs.com/nidb-cr/alicdn-ssl-worker:git\u0026#39; environment: TZ: \u0026#39;Asia/Shanghai\u0026#39; ports: - 5057:5057 depends_on: - nginx restart: unless-stopped volumes: - ssl_data:/data/ssl configs: - source: alicdn-ssl.conf target: \u0026#39;/app/appsettings.json\u0026#39; 需要修改的地方为 volumes.ssl_data.driver_opts.device ，将 /data/example/letsencrypt 改为存放你 acme.sh 签发证书的目录，该目录下通常有 keys 和 lives 等子目录。\n按照 “配置” 章节的内容配置好选项。\n使用 docker compose up -d . 启动服务。\n配置 配置使用标准的 .NET IConfiguration 框架，配置文件由命令行参数、环境变量、.NET secret以及配置文件等提供，详细内容可见微软文档：配置 - .NET | Microsoft Learn。\n推荐使用命令行参数、环境变量和配置文件 appsettings.json。其中命令行参数比较多用于临时调试等。多种方式可以组合使用且配置节点名称（即 key-value 中的 key）一致。当某个参数被重复配置时，优先级为 “命令行参数 \u0026gt; 环境变量 \u0026gt; 配置文件”。\n以下为配置文件 appsettings.json 的样例和说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, // Logging 参考 https://learn.microsoft.com/zh-cn/dotnet/core/extensions/logging?tabs=command-line#configure-logging-without-code \u0026#34;CertConfig\u0026#34;: { \u0026#34;CertFileName\u0026#34;: \u0026#34;fullchain.pem\u0026#34;, // 证书公钥文件 \u0026#34;PrivateKeyFileName\u0026#34;: \u0026#34;privkey.pem\u0026#34;, // 证书私钥文件 \u0026#34;CertSerchPath\u0026#34;: \u0026#34;/data/ssl/live\u0026#34;, // 证书文件的目录（挂载在docker里面的目录），程序会扫描该目录所有子目录中的文件，查找在以上两个选项中配置的证书文件名 \u0026#34;IntervalHour\u0026#34;: \u0026#34;12\u0026#34;, // 每次检查的间隔，每隔{IntervalHour}执行一次检查，若当前HTTPS证书在{IntervalHour}内过期则会更新（小时） \u0026#34;CacheTimeoutMin\u0026#34;: \u0026#34;30\u0026#34;, // 文件缓存间隔，若上次读取证书文件超过{CacheTimeoutMin}则重新读取（分钟） \u0026#34;DomainList\u0026#34;: [ // 交给程序管理的域名列表 \u0026#34;blog.gaein.cn\u0026#34;, \u0026#34;img.cdn.gaein.cn\u0026#34;, \u0026#34;static.cdn.gaein.cn\u0026#34; ] }, \u0026#34;AliCdnConfig\u0026#34;: { \u0026#34;AccessKeyId\u0026#34;: \u0026#34;LTA*********************\u0026#34;, // 阿里云 AK ID \u0026#34;AccessKeySecret\u0026#34;: \u0026#34;*****************************\u0026#34;, // 阿里云 AK Secret \u0026#34;Endpoint\u0026#34;: \u0026#34;cdn.aliyuncs.com\u0026#34; }, \u0026#34;ApiConfig\u0026#34;: { \u0026#34;IpAddress\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, // HTTP API 监听地址 \u0026#34;Port\u0026#34;: 5057 // HTTP API 监听端口 } } 以上所有配置节点均可通过命令行和环境变量复写，如不改变配置文件将 HTTP 端口更改为 8001：\n环境变量：export ApiConfig_Port=8001 (bash) 命令行参数：./AliCdnSSLWorker --ApiConfig:Port 8001 或 ApiConfig:Port=8001、 /ApiConfig:Port 8001。使用 dotnet run 启动同样也可以使用命令行参数。 详见：配置提供程序 - .NET | Microsoft Learn\n使用 其实不用干什么哒！让它跑着就行了。\nWeb API 为了方便控制，该项目启动了一个 HTTP 服务器并暴露了 WebAPI\n强制上传所有证书 1 HTTP GET \u0026lt;IpAddress\u0026gt;:\u0026lt;Port\u0026gt;/force_refresh/ 你可以使用你喜欢的 HTTP 客户端发送请求，如：\n1 curl http://\u0026lt;ipaddress\u0026gt;:\u0026lt;port\u0026gt;/force_refresh/ 或使用命令行参数 --refresh 或 -r 启动二进制发送更新指令，如：\n1 sudo docker exec alicdn-ssl dotnet AliCdnSSLWorker.dll -r 该命令会从之前的配置中读取 HTTP API 监听的 IP 地址和端口，并向该端口发送请求。\n如刷新成功你将会获得一个 HTTP 200 OK 的响应。\nexport Ali_Key=\u0026quot;\u0026quot; export Ali_Secret=\u0026quot;\u0026quot;\n./acme.sh \u0026ndash;issue \u0026ndash;dns dns_ali -d gaein.cn -d www.gaein.cn -d v4-cn-bjs3.gaein.cn -d api.gaein.cn -d img.cdn.gaein.cn -d static.cdn.gaein.cn\n./acme.sh\n","date":"2024-07-02T19:54:27+08:00","image":"https://img.cdn.gaein.cn/website_used/blog/Auto-Deploy-Cert-to-AliCdn/banner.webp","permalink":"https://blog.gaein.cn/passages/auto-deploy-cert-to-alicdn/","title":"将 Certbot/ACME.sh 自动化申请的证书自动部署到阿里云 CDN"},{"content":"提要 本篇博客为2023暑假日本大阪旅游的流水账。有关魔法未来攻略请见 初音ミク「マジカルミライ」魔法未来2023大阪之行\n注意：多图警告！\n日程 8.9 Day -1　太原 虽说才刚刚结束暴走一天的古交之行，但是东西总不能不收拾的嘛。\n——于是我找了一天没找着我的单反充电器。\n干脆破罐子破摔了，到日本买个原装充电器算了，时间也不早了。\n因为是第一次出行，多少有点紧张，因此时间上留的很充足。按照计划来说，是坐 8.10 早起的 T8 次列车前往北京，不过由于学校折腾到车站怎么着也得1小时，所以和朋友约定前一天晚上去他家里住。\n把背包装到行李箱里面，再三确认了各种证件之后，出发！\n熟悉的公交车一个小时，然后又转车又换地铁的坐了好长时间，和朋友碰面去他家。\n晚上狠狠的旋了一顿他家楼下的山西菜，之后躺在床上就开始睡不着了，非常希望抓紧能睡着好一睁眼就开始旅程，可又异常兴奋。\n8.10 Day 0 太原-北京西站-明城墙-大兴机场 机票是厦门航空早起 7:30 的，对于北京人来说也许是起个大早，但是对于我来说则是前一天去机场睡大觉！\n如果是自己的话我可能会更特种兵一点，坐傍晚的车，凌晨到京赶去机场。不过考虑到和朋友一起，就把时间留的充足一些，去找个大饭店旋一顿。\n当然，目的还有一个，就是去明城墙拍车，反正一整天也没事做嘛！机场还有一晚上逛呢。原想着去拍国列 K27，但是朝鲜方面的原因这车只跑到丹东，车底也是刷绿25G，想想算了，随便蹲蹲得了。\n朋友的母上也是很赶早的人，8点多发车的天府之星 T8 次 5 点多就送我们去太原站了。说来有趣，朋友虽是太原人却没怎么来过太原站，进了站还是我带他过去检票排队。\n我倒是个很少坐高铁的人，一是票价高我不差时间，二是家里和学校都离高铁站太远了，路上折腾的时间都能把普速车的时间填回来。另外总感觉气氛有些压抑，小时候坐惯了东北进京的车，倒是感觉一车人聊天扯淡嗑瓜子更有烟火气。\n到了检票时间，拿着身份证跑去人工检票口，最后一个屁股离座第一个过闸机就是爽。\n下了月台，便是 天府之星 T8/7 次列车，车底 25k。\nT8/7 次水牌。\n说实话，因为 25k 车底太旧，乘坐体验并不好，乘务也不管收垃圾，让我们自己扔QAQ\n一路有说有笑，进了北京西。路过园博园时候还在感慨，上次从这里过见风景旖旎，没想到一场台风给霍霍的乱七八糟的。\n到了北京西朋友就开始懵圈了，记得12年时候和爷爷奶奶去广州，我爷爷还说这地方是“马蜂窝”。作为枢纽车站连通性高的同时自然复杂，不过现在看来也就还好，标志也算清晰。\n由北京西坐七号线再转五号线到崇文门就到了——新侨饭店！由于暑假时候体验过了前门饭店，不贵好吃又高端，所以决定继续旋点好吃的。以前去同仁医院经常在崇文门这边走，倒是还没发现新侨饭店在这，只知道地铁站旁边的崇文门饭店。\n北京新侨饭店正门。\n到了新侨饭店后已然不是饭点，不过人一点也不少，大概是老爷们用下午茶的时间。新侨饭店的西点非常好，但是价格属实劝退，权衡半天只敢点一个烧鹅和咕噜肉，算下来200，一人100也就勉强接受了。谁叫咱囊中羞涩捏QAQ。\n贵死了的烧鹅，但是好吃。\n不行不行下次还是前门饭店吧\n吃完饭便骗着朋友去了明城墙遗址，其实是来拍车的（x\n转了一大圈，买票，上城楼，感觉这个机位也就还好，东便门似乎效果更好一些。\n上面还有一小孩在拍车，看起来也许是小学或者初中，见我上来便跟我嚷嚷着说错过了“好货”——DF11G和好几节原色，俺寻思俺像他那年纪还没刷绿这回事呢。\n蹲了一下午，其实是消磨时间，这个机位说实话不是特别特别好，看火车倒还算好地方，拍照的话接触网太多了，角度也不好。挺好，正好符合我消磨时间的需求了。\n一下午也没看到什么稀奇东西，熬到晚上就算正式“启程”了。\n复兴双源 1 号车，2 号在牵引 T5687 时候坐过一次。\nDF4C-5012 青年文明号牵引客车入站。\nSS9-0146 牵引客车入站。2016 年去 MIKU EXPO BEIJING 时候我坐的客车 K340 次的本务还是韶山9，如今大部分已经换成和谐电了。\n曾经满街都是的25G的靓丽红色，现在已经难得一见了。\n什么，你问我一下午就照仨？都说了是来消磨时间的啦，另外看一下午的 HXD1D 了。\n混到晚上了，启程前往北京西坐高铁上大兴国际机场！\n大兴机场是我高中语文上的常客了，那时候刚修，现在也运营才没几年，一定程度上代表了我国的基建顶尖水平。上次坐飞机还是12年从广东揭阳飞北京首都，而且这次是第一次自己坐飞机，APP上值机还有些问题，其实还挺紧张的。\n车应该是 CR400 系的，非常高级的复兴号，什么叫复兴号啊（战术后仰\n乘坐舒适，就是在市区一直跑不起来，我都替大车憋屈。\n然后，恭喜我，买错票了。我直接搜的“大兴”，买的站是“北京大兴”，是大兴区内的一个高铁站，而北京大兴国际机场在下一站“大兴机场”。\n过了北京大兴站我还在纳闷，都到手机上的时间了怎么还在中间站？恍然大悟发现买错票了，朋友慌的不行问我要不要下车，我只好找车长去补票。妈的高铁还是贵啊，这么短的距离花了我俩一人40，索性最终胜利到达大兴机场。\n到了大兴机场就是乡下人进城，刘姥姥进大观园了！\n厦门航空/南航值机柜台。\n因为一直在担心随身行李额度的问题（因为单反+电脑超过了厦门航空规定的 5kg），所以值机去 -1 层值机柜台询问工作人员，好在晚上这个时间的人并不多，所以有人有时间回答我的问题，答案是随身的其实你拿的动多少都无所谓，别背两吨铁块就行（x\n顺便问了下托运的问题还有值机以及海关手续，便溜开逛机场了，反正时间还有的是嘛！\n大兴机场首先是大！-1层的大厅已经和很多小的国际机场差不多大小了，而上了地上后，仅仅是值机的大厅就超乎想象。加之开放式的设计，更显得宽阔。\n笑死根本不会构图。\n之后挨个楼层逛了逛，大兴机场里面的店铺繁多，而且大兴机场打出口号“同城、同质、同价”，使得东西一点都不贵，比起其他机场来说，极具性价比。\n最后，收拾好东西，因为去程东西不多，不准备托运，就把相机电脑放在箱子里，随身带上飞机，可以免去等行李的苦衷。\n看了看表，晚上 11 点，直接开卷！明天 7:30 的飞机大部分人会 6 点多到吧，咱直接半夜值机！\n由于是联航的国内段，还需要到国内出发层值机，到了柜台有工作人员在值班，而且也没有人排队（笑死，谁大半夜值机啊），递交护照，便给了我登机牌。问了下 APP 上值机的问题，我 APP 一直处于薛定谔的值机，你点开看之前他显示未值机，点进去想值机又显示已值机，柜台的答案是没值上，顺便帮我把明天厦门高崎飞大阪关西的机值了，不过还需要我去领登机牌。\n登不登机牌排不排队无所谓，咱就是怕和朋友分开了。\n厦门航空/中国南方航空在大兴机场的登机牌。\n然后到了安检，电脑、相机、剃须刀乱七八糟一堆东西全要拿出来单独检查，主打一个白收拾了\u0026hellip;\n过了安检进了值机到了候机厅，有 A-D 四个区，其中 B 区有休息区，也不管什么登机口了，反正大屏和登机牌上都没有，便直接冲着 B 去了。\nA、B、C 三个登机口是三个不同方向的巨大连廊，可能有数公里长，不过好在终于走到了休息区，给手机充了下电。\n由于这次旅行没告诉父母，为了人身安全考虑我将详细行程告诉了我表弟，并约定定时上报行程及位置。\n毕竟是第一次出远门\u0026amp;出国\u0026amp;自己坐飞机\u0026hellip;很多第一次，心里是慌的，甚至还买了保险，寻思寄了就爆点金币。\n手机充好电一回头，休息区没位置了\u0026hellip;朋友决定坐椅子上睡，我在蹲躺椅，蹲了半天总算是有了。拉着行李跑过去，往上一躺——然后发现根本睡不着。\n大兴好多基础设施都非常棒，唯独这个躺椅，他非常的反人类。首先是硬的，算是易于清理可以理解。但是它反人体工学：椅子是斜的，而头部的凸起很高，导致我躺在上面时候头会滑下来（因为是硬塑料所以没什么摩擦力），然后会拧着脖子，又只能冲天躺着对着房顶的射灯。\n睡了两分钟，根本没办法睡，还没睡着脖子就不舒服了，这么躺一宿脖子不断了也得落枕，一起之下提着箱子溜回朋友身边，想当年咱也是张家口睡过公园长椅的人！然后大兴的椅子——不能睡。可能是疫情时候装的，每个座位之间都是隔开的，看了看脚底下的地毯，软软的也不冷，那就这了！我直接躺平（物理）。\n身上的衣服是专门为了这两天旅行不能洗澡穿的用来摁造的速干衣，直接开躺，然后从箱子里掏出毛巾，往脸上一盖，我再往椅子底下一钻，耳朵一捂，上了个6点半的闹钟，直接呼呼大睡。\n8.11 Day 1 北京-厦门-大阪 睡睡醒醒，醒了三次之后终于到了早上5点半，一睁眼发现不对了，我眼前的大白腿呢？？\n起来一看，朋友不在座位上了，俺寻思别是让人贩子拐了去，抓紧问问他，索性只是去厕所洗漱了。\n朋友睡意全无，我一折腾也不困了，干脆起床候机呗。跑过去一看大屏，屏幕转了三页，还是没有咱的航班。估计是候机口还没定，只能先收拾东西咯。 这时候就看出来大兴机场的大了。两个登机口差了有好几里路，走了好长时间才过去，然后一看——没人。\n果然还是太卷了吗？\n旁边庆丰包子吃了顿，虽然同城同价了，但是感觉不同质，皮黏了吧唧的不好吃，因为这趟航班没有餐食，勉强算是先吃饱了。\n上面的好吃，下面的黏了吧唧。\n第一次坐飞机难免还是有些紧张的，毕竟这么大一块铁在天上飞。不过，看了一车的空中浩劫，哪个空难不是一堆必然的巧合堆积在一起才发生的？我选择相信机组的专业素养，也就安心多了。\n吃完饭终于差不多了，登机！\n厦门航空 B737-800 经济舱。\n怀着激动的心情走上了廊桥，顺便给空乘递上了我的 flight log。\n经济舱的座位比我记忆里的更窄、更硬一些，不过倒也能接受，只要便宜我咋都行。\n我还认真的翻看了逃生的指南，安全面罩等东西的那张单子。\n飞机达到巡航高度，发了小点心，大学生嘛，主打一个吃吃睡睡，开旋！\n其实没想睡，实在是忍不住，毕竟奔波了好几天了。\n一觉醒来空乘把 flight log 放在我小桌板上了。\n北京大兴-厦门高崎段的 flight log。\n中午落地厦门高崎机场，有了之前和大兴的对比感觉小了好多。看了下海关的开关时间还有一阵子，决定去吃顿肯德基。\n这时候才发现大兴的好，厦门机场的K记就很贵了，反正勉强吃了下。\n吃完时间也就差不多了，准备出发！\n厦门高崎 国际/港澳台出发\n真的要出国了！好兴奋！\n先是安检，然后边检和海关一般也会放你走的，自助通道那边一开就很快了。边检小姐姐盖章我还以为是扫码，手指垫在机票下面，她戳的好疼QAQ。\n盖着边检章的登机牌\n之后是漫长的候机，航班延误了一个多小时，简直是急死人了。中间还换了一个登机口，不过一开始谁都没广播，只是听说要去那边候机，到处找人也没找到，最后才问到的。\n飞机起飞，沿着中国的海岸线飞，从杭州附近向东北方向飞离陆地。\n海岸线。\n漫长的飞行并不无聊，机上的显示屏放了部电影，有关香港律师打案子想办法救无辜的，降落时正好放完。\n中间发了一张入境的申报卡，个人感觉在这个纸上写比日本政府搞那个网站方便多了。卡是中日英三语，不过都是汉字，看日语也没问题\u0026hellip;\n日本的入境申报卡。\n再见到陆地时候，已经是在日本境内了。\n眼看着都快落地了，过了巡航阶段了， flight log 也没给我，寻思着可能是机长没空填了，准备作罢了。不过在降落前空乘奇迹般的交给了我，好耶！\n机长还附上了舱单。\n厦门高崎-大阪关西段的 flight log。\n可能是因为关西机场航班较多，飞机盘旋了一会才顺利降落，落地时候已经黄昏了。短短的几个小时航程却令我十分焦灼。\n关西机场的摆渡车还挺好玩的，是一辆有轮子的车，但是侧边卡在轨道里面，当轨道车用。\n下了摆渡车之后就是边检啦！\n禁止拍照的日本边检。\n我知道边检不能拍照，但是我没想到出来就是边检了\u0026hellip;\n日本这边拍照的默认值是禁止，在景区等地方大街上拍照其实还好，如果到一些店铺里没有写又想拍照的话最好问一下啦。\n走到“外国人入境”的地方排队，然后摘眼镜拍照按指纹。\n后面的日本老爷爷一直在跟我比划什么，想说又没说出来，直到排在我后面的朋友看到了喊了声眼镜，老爷爷才想起来眼镜的中文怎么说，也跟着喊了一句。\n进去之后把护照递给里面的工作人员，他翻了半天才找到签证页，然后在旁边的页上贴上一个“上陆许可”的小纸片。\n别看了，懒得拍照。\n之后还是排队，过海关，其实只要那个二维码或者飞机上发的小卡片就行了，结果前面有个不知道哪的人反正不是亚洲的，人家前面一直说要填纸片，到处也贴着多国语言的牌子，结果他啥也没弄就过去了，家人们谁懂啊，太下头了。堵在那里一直不走，磨叽了半天拿了个纸条又堵回去了，导致我们这一队比旁边慢了半个小时\u0026hellip;\n终于终于出来了，我到那就给他看了俩二维码。\n之后就到了机场的大厅，因为关西机场是填海造陆成本较高，所以也很小，感觉比中国好多机场都要小。之后我们找关西游客中心想着兑一下之前买的大阪地铁两日券。\n大厅里面的国际航班到达牌子。\n然后转了一圈发现，下班了\u0026hellip;\n不是你们不能安排点人24h值班吗？\n之后就直接出了机场，出了之后是二楼，下去是巴士，往前走是电车/地铁站。\n从机场回去坐的是南海特急（谷歌地图的结果是这个），我俩研究了半天才看明白咋买票，到机器那里塞了张 10000 日元。\n实际上南海特急要比南海本线贵好多，也没见快到哪里去。南海本线从关西机场到天下茶屋（中转站）的价格是 970JPY，而南海特急是 1490JPY，时间只差了8分钟。纯纯大怨种了。\n南海特急上面的指示牌\n不同等级的车走同一条线路，停站不同。\n坐了非常非常漫长的一个多小时，终于到达了换乘站　天下茶屋（てんがちゃや）。\n天下茶屋是大阪南部的交通枢纽，位于治安去较差的西成区，之前早就听说过西成区这个地方，定民宿时候还绕开了这里，后来才知道天下茶屋在西成区的。\n下了地铁找了家 seven-eleven ，抓紧去兑演唱会的票，已经忍不住了！\n天下茶屋站台\n出车站就是一家 7-11，用邮件顺利拿到票。\n可惜是座位比较靠后，和 16 年去 EXPO 时候的座位几乎一致，今年海外区的座位都很偏，我这还算偏的里面靠中间的了。\nSS票，23列26番是23排26列的意思。\n看地图 7-11 好像很远（如果是中国地图绝对就是走一个路口那么远）没想到就是出站口里面。\n之后从站前穿过一个停车场，沿着大路走去在四桥线上的岸里站。\n街边挂着控告日本政府的牌子。\n从天下茶屋出了站直接往西走，再往南去地铁站，并没有走谷歌地图给出的路线。\n终于在坐了一站后到达了北加賀屋（きたかがや），本来原计划是到了之后吃个晚饭，再去附近转转的。由于航班晚点再加上在海关堵了一段时间，已经不早了，而且两天的奔波已经疲惫不堪。并且之前在西成区的路上走了一条街，发现这个点大部分商店已经关门休息了，所以直接准备回去躺。\n到了民宿 check-in，这才发现老板（娘）是欧美人，之前还以为是日本本地人开的店。之后问了我名字，要求我扫码登记信息，她说扫码说的是让我打开 camera 对着二维码 \u0026ldquo;take a photo\u0026rdquo;，她相机是带扫码功能的。我打开微信准备扫码，朋友却觉得是拍照。我问她是不是让我 \u0026ldquo;scan QR-code\u0026rdquo;，她也没回我，给我拿手机演示了一下，这下双方才明白了。\n不过她那个网站寄了，提交不了，最后干脆给她护照拍了张照，就算入住了。给了我一张小卡片，是密码锁。\n房子是日本的一户建，非常小的木质房屋，处处需要低头，楼梯也很窄，而且因为是木头做的，脚踩在地板上能够感觉陷下去，我俩小心翼翼的上了楼，找到了自己的房间。\n定的是三人间，因为有一个朋友不来了所以只有我们两个人住，还算宽敞。厕所和浴室等是公用的。\n房间里面也是踩一下陷下去一下，搞得我俩怂的只敢先坐下再慢慢躺下，不敢直接蹦跶。\n已经累得不行了，定个闹钟洗澡也不想洗了，直接开躺！收拾了一下也没搞明白榻榻米怎么铺，干脆乱铺了。被褥还是有些脏的。空调倒是很带劲。\n累得不行了，本来还想弄下照片，不过想着明天还要逛好多地方，所以只能早睡了。\n原定于明天的行程如上所示，不过由于没取到地铁卡，所以明天还得去趟难波站的的关西游客中心。\n8.12 Day2 梅田/本町/心斋桥/难波/道顿堀/日本桥/通天阁 写完标题就笑了，什么速通。\n早起起床后去洗了个澡，然后哥们手机卡进水用不了了（恼\n之前在国内洗澡也会把手机放浴室，怎么就没有被水汽进了卡槽不能用的事情呢？\n洗完澡准备出门，背着相机主打一个健身（x\n北加贺屋附近的街道\n日本居民区大部分也都是这种小路，倒是自行车比起汽车更多一些。\n食其家的牛肉饭\n早就物色好了车站附近的 すき家（すきや），过去吃早饭。朋友点了一个早餐的套餐，我想了想点了通常午饭吃的牛肉饭。\n我点的是大份，大概 800JPY，小份的会便宜一些。\n大学生嘛，吃吃吃怎么了？\n酒足饭饱之后坐地铁先去难波站拿一下大阪地铁卡，从北加贺屋坐四桥线到了难波站，下了车人就傻了，难波站也太大了，但是也不是中国车站那种面积大，而是岔路多、出口多。\n深色的部分，是巨大的难波站。\n难波游客中心在南海CITY里面，是个巨大的电车站+商场，而谷歌地图导航又没有具体走路的路线图，而且还不知道在商场几层\u0026hellip;\n之后转啊转啊，找了几乎一个小时才在二楼商场里面找到了难波游客中心，结果一看——门口排了几十米的长队。\n放弃了，不差这一天两天的（虽然原定行程才3天）。\n之后想了想，大阪城是没时间去了，最近初音未来 16th 有一个主题店，大阪的在梅田，干脆过去看看好了。\n坐地铁到了梅田，到了 hep five 之后却找不到上去的路，电梯只能坐到 1 层，楼梯那边门也锁着，就很让人摸不到头脑。\nhep five 旁边由梅田站驶出的 JR 西日本。不过图片是后来照的。\n兜兜转转上上下下跑了好几圈，才发现，原来人家 11 点才开门啊！\n多少有够懒狗的\u0026hellip;\n无奈，只能去旁边随便转转咯。周围是阪急的商店街，不过有很多店铺也没有开业。大路上则是梅田的高楼大厦。\n早上的阪急商店街。\n梅田的高楼。\n回来时候有好多人在门口等，还有好多jk，终于蹲到了11点开门，从 -1 楼卷上电梯直上 6 楼，冲进联动的店。门口的牌子上写着吧唧卖空了，但是实际上还是有的。\n然后发现，好多想买的还没发售，不过摆出来的东西也——统统想要！\n谷子真的好贵，买了一个吧唧一个亚克力立牌就收手了，顺手薅了一张魔法未来的海报。\n店铺里面是有抽奖机器的，不过好像是够 10000 日元起，显然我俩没那财力。（哭哭\n买到的谷子，开心！\n亚克力立牌。\n门口的牌子，上面写着“完贩”。\n联动的店铺，朋友笑得超级开心，可惜只能化作马赛克。\n店门口的超大海报！\n逛完了之后，想着来都来了，我看攻略 HEP FIVE 商场是顶上有个摩天轮的，寻思着也没到饭店呢正好俯瞰下大阪的风景，结果七拐八拐上了楼，发现摩天轮在维护没有开，无奈只能作罢，但是来都来了，一层一层逛呗。\n最上面有一层貌似是什么活动，我俩过去了被服务员小姐姐拦下来问我们两个需要什么，我想说我就瞎逛逛，最后我俩英语日语谁也没说清楚，只能开了翻译软件，好尴尬啊！\n再往楼下走走，有一家 jk 制服的店，在门口转了114514圈还是觉得进去太怪了，就没去看。\n楼下有一家万代的店，本来说想去看看的，结果咕咕了。（为什么咕咕了我也忘了）\n转了一圈突然想起来答应给别人带的一件 POLO。想着这么大的商场应该有，搜了一下在隔壁的一栋 HEP 里，然后就开启了尴尬的买衣服之行。\n顺着导航跑到了 POLO 的专卖店，给店员看照片问衣服的样式有没有，结果店员一个劲的问我是不是 XS 尺码的（因为图片上是 XS），微信问对方又不回我了，搞得我俩整个一个尴尬。\n问了半天终于回复了，和店员又沟通了半天，最后才明白，他家只有 M/L/XL，而 X/XS 在他家的楼下有卖。\n另外，有趣的一点是，日本管 S 叫 small 的，而不是像中国一样直接读字母，同理 XS 是 very small，沟通中的困难也有一部分是因为这里。\n跑到了楼下，开始问店员衣服，索性我也恼了，直接微信视频呼过去，然后左挑挑右捡捡，混合上我的答辩英语和朋友的社恐日语，在闹了一车误会后终于成功买到了想要的衣服，然后去楼下退税时候还遇到了中国的店员，刚刚被折磨了一通后，能说两句汉语太舒服了。\n然后就想好了，一毛钱没挣折腾半天，再也不给别人带东西了QAQ。\n出来时候时间已经过了 12 点了，今天的计划本是吃鳗鱼饭，不过因为不去大阪城了，想着要不要换一家近点的？然后谷歌地图一搜还是同一家店，真是缘分到了。\np.s. 缘分太到位了，到位过头了。\n鳗鱼饭之前总是看柯南里面元太吃，而且一尺就是好多好多碗。我本人是不太喜欢吃水产的，不过想象中的鳗鱼饭应该是香香软软浇汁的，来都来了不尝一下太可惜了。\n看了几家攻略后，选择了连锁店 宇奈とと，“宇奈”在日语中与“鳗”同音。这家店价格不贵，而且质量也有保障，人还不算太多的。而且离得近（x\n坐上地铁，到本町下车，心疼死我了，9块钱啊可是。要不是那个该死的堵海关的人，我早就拿到两日券了，可恶。\n到了之后点单，套餐 50 块，可比国内一些奇怪日料便宜。而且量很足，够吃，尝了一口，偶以西！\n我的鳗鱼饭套餐。\n味噌汤看着奇奇怪怪的，里面的东西像软软的，感觉是海里的或者内脏。不管了，喝完再说！味道还可以。\n摆出来谷子拍了张照（见上上上\u0026hellip;图），吃饱喝足收拾走人！这顿饭吃的我俩都非常满意。\n看了眼地图，其实梅田、本町、难波、心斋桥、道顿堀、日本桥、通天阁（新世界）本来就是在南北一条线上，所以决定直接逛街啦。\n从本町站往南走一个大街便是心斋桥啦，这里可能是绝大多数人打卡大阪的地方，也会有很多人在这里买药妆、买衣服，不过我嘛\u0026hellip;没钱！\n远远的发现前面就是心斋桥了。\n不得不感慨日本人好浪费，空调对着大街吹也不做密封，各个店铺开着门，把整条路都吹的凉快了些，正好拯救下被晒得不行的我们。\n左看右看，大阪的建筑真的好日式啊！（划）大部分街道都很窄，上面挂着乱七八糟的电线和各种招牌。在心斋桥的中间一条街上照了张相片，看起来和动漫中一样一样的。\n心斋桥一侧的小路。\n走近写着心斋桥的牌子，过了这条大马路就心斋桥商店街了。\n心斋桥前马路侧面。\n之后在心斋桥看到了一家POLP，本来是想着在这里给带衣服的，不过已经历尽千辛万苦买好了。所以就继续转啦。\n心斋桥中国人多的很，路边的药妆店中也有很多中文的照片，有些店甚至只做了中文和英语的牌子。\n朋友在路边看到了一家卖二手漫画/DVD和电器之类的店，我也顺便进去问了下有没有我单反的charger，不过答复是没有。\n然后朋友就在二手书店里发现了宝贝，我俩在一堆书之间一本挨着一本的看，很多在国内找不到的、或者很贵的漫画和设定集之类这里都有。\n我朋友基本上是快高兴疯了，跟到了天堂一样，黏在书架上不想动，最后终于劝着给拽走了，毕竟日本桥还有很多嘛！\n来自朋友的照片，他真的好开心啊。\n转着转着上面的盖子突然没了，出了商店街豁然开朗，原来这里就到了道顿堀了，眼前则是地标性的广告牌。\n心斋桥与道顿堀的路口。\n走上了桥对着侧面，蓝天、不高的高楼、蓝水，太美丽了家人们。\n道顿堀河。\n左侧的楼上有个圆弧四方的摩天轮，下面的船之前看可以坐，凭两日券还能打折来着，不过看了看也没准备坐。\n之后沿着道顿堀那条河往左走了一个街区，再往南走一点就是日本桥啦。\n日本桥本桥。\n挨着日本桥，马路边的是近铁/大阪地铁的日本桥站。\n日本桥站。\n再往南过一个小路口，就算是日本桥啦。\n也是在这里找到了一家卖摄影器材的店铺（毕竟曾经也是电器街嘛）买到了我的充电器。\n店铺里还挺多人购物的，一个不大的小店，老板收二手卖二手，也卖全新的单反。店铺不大但是各种品牌和大部分型号都有。因为有人排在我们前面，所以不得已等了好一会时间。\n终于排到我啦，三脚猫英语还是能凑合用用的，付款，拿到了我的充电器。\n不出意料的是 MADE IN CHINA。不过总算是拿到了，不至于后面几天单反完全变成负载了。\n往南走的途中，左手边就是黑门市场，号称大阪最大的美食市场，据说物美价廉。\n我俩在黑门市场略微看了一下，因为两个人都不喜欢吃海鲜，所以在旁边上了个公共厕所，找个背阴凉快了一下就继续走啦。\n再走过一条大路，就是满大街的二次元店。第一家店就是一家手办店，门口柜子里面摆着价格不菲的高达，里面则是各种各样的手办。\n炮姐的手办。\n这个炮姐之前在太原钟楼街也见到过一次。\n葱葱的手办。\n还是朋友眼睛好用，一眼就看到一堆初音的手办。中间这个秋季为主题的手办脸捏的实在太可爱了！\n不过 5980 JPY 的价格有点劝退，上淘宝搜了搜才70，但是淘宝那个图看着好奇怪，不像同一个，就很难过。\n盯着看了半天最后放弃治疗，继续逛！\n然后就发现了一只可爱的小岛风，一脸很屑的表情。\n水到群里，果然群友也觉得非常可爱，问了下价格让我帮忙带一下，虽然要垫付一下，不过咱也买啦，只要我拍照了就是我的（x。\n结账时候的屑岛风。\n结账时候才发现店员是中国留学生，那问起来就方便了——既然我都买东西了把那个可可爱爱的初音拿出来给我拍张照不过分罢！\n又拍了一张葱葱的手办，价牌拿下来了。\n喜欢这个手办主要是脸捏的很生动，肉乎乎的，不过头发的发梢渐变感觉有些不自然。\n出了手办店，旁边是一家涩涩的店，临街放着招牌，上面是各个厂牌的当红女优和代表作等。\n之后挨家挨户去转了，有一个“日本最高级的模型店”，不过对高达不感兴趣。帮朋友看了看也超出他经济承受范围了，之后没走两家店就是一个 K-BOOK。在国内并没有见过这么大的二次元店，总之朋友都快笑疯了。\n吧唧挂了一面墙属实壮观又令人难以抉择，蹲下一个一个看。\n途中还有一家 cospa 的服装店以及一些其它店铺，都转了一转。\n天气实在是太热了，大阪三十七八度的天，我俩背着大书包，我还装了单反，整个后背完全就是泡在汗里的。\n所以一直往店里钻\n找家店买应援棒（日本叫 pen light），结果打开地图来了个台风警告，真是怕啥来啥，之前还专门查了下地图应该不会有台风。\n谷歌地图的台风预警，正从我头顶路过。\n这下可是烦恼了，不知道航班能不能正常起飞，不知道会不会影响到 live，第三天的行程感觉是泡汤了\u0026hellip;\n主要在国内刚刚经历过台风，从南方都能刮得北京发水，作为北方孩子没实地经历过台风，还是怕的不行的。\n巨大的A店巨大的招牌巨大的广告。\n来 A 店的目的其实是买应援棒，朋友并没有带棒子来，场贩的又不太喜欢而且怕抢不到。所以决定来 A 店看一看。\nanimate 足足有 5 层，第一层是一个小电梯上去，门口还放了一个波奇酱的小吧唧，超级可爱，本来想着给朋友带一个，但是六七十的价格太劝退了。\n门口贴着禁止摄影的牌子，我怕被误会，就去问我背着相机进去有没有问题，然后小姐姐理解错了，把他上级拉过来，和我说“camera OK, NG NO”，意思是可以拍照不让录像。\n结果我就成了整个 animate 里面唯一可以照相的人了（不是\n不过嘛，咱也没拍什么（已经快透支了）\n小寻子的全套书，不过应该不是 animate里面的\n舰队COLLECTION中的晓\n朋友买了应援棒，当时时间已经5点多了，肚子也开始叫了，没办法，先吃饭咯，再不吃是真挺不住了。\n至于晚饭记不清是食其家还是吉野家了，惠美须町地铁站附近都有。吃了份最大份，吃完大概也饱了。\n走过惠美须町地铁站便是通天阁\u0026amp;新世界了。通天阁算是新世界娱乐区的象征，也算是稍微老一些的大阪城区了。\n站在路口就可以远远的望见通天阁，通天阁现在看来并不高，不过放在建造的那个年代，还算是“通天”的。\n在路口就可以看到通天阁，可惜中间有根路灯。\n在新世界商业街看通天阁。\n其实新世界的核心区域在通天阁的南面，这里到处都是娱乐设施，还有很多“射的”以及各种各样的小吃。\n不过我俩刚刚吃饱，又没有多少精力，所以就无缘啦。\n下次旅行不能安排这么紧张了。\n到了通天阁下，得知上去需要排队40分钟，于是两个懒狗就放弃治疗了，也算是草草参观了一次了。\n然后远远的让朋友给我拍了张合影，然后完美的眼镜反光挡住了眼睛。\n走到新世界的南头，有一座楼的台阶可以上到高一些的地方，拍照很合适。只可惜通天阁没有开灯，所以照的不是很清楚。\n好啦，今天行程算是结束了。看了下地图，发现最近的能直接回去的车在花园町，\n谷歌地图推荐的路线，在大国町坐车会近一点。\n当时想着，都走到通天阁南边了，去下一站花园町也不会太远吧？\n于是看了眼大概方位，反正日本的道路挺多的，很多小路，也不差那个路口的。\n不过远离了喧嚣的新世界，看到的确实另一幅场景。地铁站门口有闹事的醉鬼，路边也睡着一些流浪汉。整条街上要么是矮小的居酒屋门店，要么是什么都没有。大街上除了偶尔路过的摇摇晃晃的醉鬼，也没什么人。\n俺寻思日本好歹也算发达国家，大阪也是日本第二大的城市，怎么晚上还不如太原呢（x\n走了一趟街，小路是没法走，太害怕了，转到了一条大街上情况好了很多。\n晚上西成区的小路。\n之前有在网上看到过说大阪的西成区，平民窟之类的，据说治安很乱。劝人不要去或者白天结伴去。我定旅馆时候也避开了西成区，没想到竟然两次半夜路过，刚到时候在天下茶屋也是西成区的，我说怎么晚上这么荒凉呢。\n在好长时段时间内我都不知道走过了西成区，后来在b站刷视频看到了一个up讲大阪民宿的杀人案件，日本女生被分尸，然后头颅被犯人藏在了花园北一町目的民宿。我一听，花园北？因为花园町这个词我专门问过朋友读音，所以印象还比较深，加之本身也比较记路，就发现是坐车的地方。\n看了看地图似乎就在我们走过的路附近。\n好家伙我说怎么看视频到处眼熟呢。\n好在没有发生什么危险。西成区也没有想象中和描述中那么可怕，另外这个地方真的交通方便，从两次坐车就能看出来。\n当然还是建议非必要不要来，西成区相比其它地方还是要乱的，来的话也千万不要走上图中的小路，大道要好很多。\n人都快累死了，终于到了花园町，坐上了回亲爱的北加贺屋的地铁。\n到了民宿，往地板上一趟，坚持着导了一下相片，人就倒了。看了下衣服，后面全是一圈一圈的盐渍，汗浸透了又干，浸透了又干，书包上也是一样。\n刚躺，就和朋友说台风的事情，又看了下新更新的通知，飞机起飞时正好在台风中间，于是肯定得延误，我俩计划是在机场睡一觉，然后买个延误险先，这个时间还来得及，结果我发现——\n衣服呢？！我 POLO 买的衣服呢？！手上没有，包里也没有，这不坏了，小1k呢！\n于是我俩又蹦起来开始找衣服，确认了没有带回来，印象里是他在商场给了我，我拿着装了包里，但是包里并没有，又开始想放在哪了\u0026hellip;\n第二天有 live，又不能误了 live 去找衣服，最后都想陪人家一件了。\n不过，随着我俩复盘一天的行程（我翻包的次数不是很多）最终确认了衣服很可能是落在了中午吃饭的鳗鱼饭，想着第二天过去找，突然想起来可以打电话问啊！\n看了一眼时间，还在营业的时间，不算太打扰，做好了准备拨打了店里的电话。\n好在接电话的还是当时的店员，对我们两个外国人也有印象，并且告诉我们衣服还在他们那里放着。\n这我就谢天谢地了，毕竟接近上千的东西真被人拿走了也有很大可能。我俩想了想，给店铺写了张感谢信，他写日语我写中文。原句是他写，ChatGPT 润色，朋友检查好再给我翻译，我再润色中文。还好要写 fligh log 带了笔，从之前打印的住宿单（没用到）中撕下了空白页。\n写好了就已经过了12点了，延误险算是没戏了（得提前3天订）。所以作罢，准备好我的痛衣、应援棒和电池，明天，出发魔法未来！\n8.13 Day3 マジカルミライいえと 这天起了个大晚，这几天的行程实在是太赶了，好不容易爬起来洗漱又耽搁了一会，看了看 Google Maps 的估计，希望能赶上车在早排开始的时候赶到会场。\n实在实在是想早起，但是实在是爬不起来。6点出头就醒了，洗漱完抓紧穿好衣服跑去地铁站门口的全家买个饭团吃。\n然后大概花了人民币接近 15 元这样买了个夹了火腿肠片和鸡蛋的三明治，大概是能一口炫完的样子。于是我俩开始怀念唐久超市低廉的物价\u0026hellip;\n到了地铁站，从四桥线坐一站到终点——住之江公园，再坐南港新城县就能到会场附近啦。\n进了地铁站，看地图是到住之江公園再转车南港新城线做到中阜头，所以只买了到中间车站的票，以为会和之前坐的地铁一样出站再买票进一次（这时候还完全没有搞明白 OSAKA METRO 的逻辑）。\n日本有些地铁是需要出站再进站，这时候我也没弄清楚（其实就南海电车到大阪地铁两个系统出站再买票了，不过这时候还没坐过两次地铁，以为线路不一样就得这样呢，实际上两条线都是大阪地铁的）。\n所以不需要出站换乘！\n南港新城发车间隔比较大，应该是10分钟左右一趟，因此赶得上这趟车就是能赶上整队，赶不上就是赶不上整队，赶不上整队的话就会排在后很多的位置。\n结果到了住之江公园，一顿换乘，发现没走出站闸机，但是我们票买的是一站（到住之江公园）的啊，这就很难受了。\n小跑着上了车，等待发车时候又有些纠结。我的想法是到了地方去找站里的工作人员，和他们说这事然后补一张。俺寻思俺一个外国人也河里罢。\n然后在等待发车的时候开始炫那个小饭团，打开包装啃了一口，感觉地铁上吃东西是不是不太素质？转念一想，开都开了，又没地方放，况且这东西味道不大。吃吧，不行就当我是没素质的韩国人好了。\n不过朋友比较社恐（毕竟解释还要他来），终究还是放心不下车票的问题，结果发车前我俩还是决定下车再出一次站，结果本来赶上的车、或者说我们上车前就出一次闸机也能赶上，被耽误了。\n都怪机场那哥们，堵了半天，不然我们拿到地铁两日券肯定不会出这事\n车上很多是去岛上工作的员工，我俩是罕见的二次元(x\n虽然是“大阪地铁”，不过也是高架的电车，旁边是建筑和大阪湾。\n出了地铁站，按着背好的地图（x\n出站，右转，走！沿着他们那的通学路走到场馆门口，右手边映入眼帘的是 INTEX 大阪标志性的圆顶棚。\n清晨的 INTEX 大阪，在谷歌街景中来过无数次的地方。\n之后抓紧跟到队尾。好在来的不算太晚，排到了场馆里面。\n在 INTEX 大阪排队入场馆等待开始。\n在队伍侧面放着魔法未来 2023 演出的广告牌。\n然后就坐下玩手机啦，毕竟 9 点才会开始入场。\n还和群友互拍了照片找他在哪，不过没找到就是了（x\n大家穿着自己喜欢的衣服或痛衣席地而坐，都很开心。\n等待的时间在水群之中不快也不慢，终于到了入场时间了！\n拿好票准备入场。\n检票处，staff 小姐姐给了我特典，细心的帮我把副券整整齐齐的撕开。\n跟着队走，检票，进！就和做梦一样进入了在网上见到过无数次的地方。\n顾不上逛，撒腿先往场贩区跑，然后就开始漫长的排队。\n队伍拐了个弯出了门，有 staff 发无料（一个纸折的主视觉同款小喇叭），另外一个 staff 发一根笔和场贩商品的单子，可以在上面勾选，买的时候递过去。\n今年的主视觉图真的不怎么喜欢，因此之前在网上看的时候购买欲望不高，到了现场又想着不买以后八成后悔（笑）\n应援棒就算了，手里有 17 棒纸的 lumica 棒子。\n毛巾先勾上，这个挺好看的而且算便宜的；还有小旗子和挂扣，挂扣真的很不错，好看又有意义。\n当然还有法批！16年没有批法批看live有点小遗憾，因此看好了miku的单人批，比主视觉好看一些。\n之后呢发现相比网站上，今年拿出了2022(10th)的专辑再贩，纠结了一下勾选了一个。10th的专辑歌很多，除了当年live的之外，还有10曲主题曲，专辑也很大个，算是比较值。\n说个好笑的，当时后面有两个日本人觉得我俩韩国的，在后面讨论，我朋友能听懂，所以在大声念发的无料上的日语（告诉他们老子听懂了）。之后后面两个日本人羞愧的跑掉了。\n要我说既然他们觉得我是韩国人那我就插队了嘛，又不丢中国人的脸（x\n排队买场贩的大家。\n终于，排队又回到了场子里，终于还差两三排就能买到了！\n左侧一个巨大的桌子放着所有出售的场贩商品。\n展示的桌子旁边挂着角色法批。\n然后这时候，初音的单人批切了！其它单人批也相继卖光。我纠结了好一番，因为上次 live 没有法批遗憾过（虽然当时也不知道那是啥），最终决定入他妈的，反正亏不了！\n看着前面的人一个接一个进去买了，终于轮到我了，走到了最左面的柜台，递给小姐姐我的纸，然后发现桌子上贴着 10th 专辑也卖光了，还挺遗憾的。\n不过等她拿过来时候很惊喜，居然有 10th 的专，怕不是我买的最后一个（笑）\n朋友买的倒是少一些，他要了一个购物袋一个，还有一个T恤（他说这东西算是有用的，不过后来也没见他敢公开穿出去过几次（逃））\n因为在最边上，干脆我就在空桌上整理了下东西，正好等朋友出来。我TM直接穿上法批！\n之后从出口处出来，后面便是各年的大旗子摆在一次，准备照一张，无奈可能是因为挡路了被 STAFF 驱离了，因此只留下了这一张图。\n旁边则是 DIGITAL STAR 的 STAGE，11:00-11:30是有活动的，不过之前记得 DIGITAL STAR 是要买票的，这里看他也没围起来，岂不是能在外面蹭？（x\n走了两步之后旁边的雅马哈的展示台，顺便在这里面基了群友——一位浑身散发着金钱光芒的帅气老哥。\n哎为什么我又穷又肥宅呢，哭哭。\n之后雅马哈的展台除了嫖无料的传单之外就只剩下羡慕，毕竟乐器咱是真买不起啊，联名就是贵上加贵了。\nESP 倒是有一些吧唧和立牌之类的，不过当时实在是没舍得买，而且排队人好多啊QAQ\n当然啦，这附近也都是音乐相关的，除了雅马哈外还有 ESP。\n都没有钱就是了。\n后面的顺序就混着的，也记不清那里是那里了\n旁边还有一个是一个屋子的小模型，可以带着自己的可爱手办放里面拍照，我像个憨憨一样看个半天才明白要带自己手办过来QAQ，白排队x1。\n走了走附近还有一个卖挂画、卖吧唧的，非常非常多，不过看了一眼排队的人，还是饱饱眼福算了吧。\n左面则是一个现场画的巨大画，不过还没有完工，旁边的小牌子提示拍照不要拍到画师。\n转过去之后是画画的地方！之前经常在活动的各种页面上看到的涂鸦墙。STAFF 给我们一人发了一个蜡笔，就可以开始涂鸦啦！\n墙上满是大佬的作品，只可惜俺不会画画，想写一些什么也是语无伦次了。\n朋友倒是照着手机上的图画了一幅不错的出来。好羡慕会画画的人啊呜呜。\n化作马赛克的好朋友在画画\n当然啦，作品有点丑就不贴了（x\n画完画之后附近是贴贴纸的地方，可以给巨幅初音贴上不同颜色的贴纸，我抽到了一根有点紫的贴到了マジカルミライ这几个字上。\n旁边是一个很有意思的照相墙，上面写着 FLASH。只要启动闪光灯拍照的时候就可以照到V家全家福。不过当时心里顾虑着台风并没有什么心情玩，就错过了。\n走到最前面是 16th 的展台，还有各种周边。不过 fufu 和其它一些东西都在预定中，16th 其实在东京场（9.1）才算是鼎盛。\n16周年主题的摊位\n16周年主图的原画\n看到了几个很可爱的手办，有个拿着小笼包的。还有本次活动的fufu和16th的fufu，不过我没注意到，很是可惜。\n中心区域就是关于本次魔法未来和主办方的东西啦！中间照例放着等身的巨大手办。上次见这么大的还是在 EXPO 2016 上。\n主视图大手办\n企划展内容待补充 必须继续写了，咕了快半年，再不写就要忘了。- 24/3/26\n边上有角色的介绍、各种活动的介绍，还有一面墙是中国的未来有你系列。\n还有一面巨大的地图墙，可以领取贴纸贴一下从哪里来，\n指示你从哪里来的地图，可以看到台湾、韩国、上海的密度很高，其次算是北京，我俩在山西摁了俩小绿/黄点。\n走过来有一面 SONOCA 的墙壁。\n虽然我也不知道 SONOCA 是什么就是了\n边上是个可爱的小MP3相框，用来拍照片的，给朋友拍了一张qwq\n另一边有面墙是画师现场作画的大图，旁边的牌子提示不要把画师拍进去。\n画师现场作画的大图\n隔壁的小场馆是卖P主签售的，大阪今天比较有名气的P主大概就匹老板，然后场馆内90%的人都是排匹老板的专辑，大概转了一圈，好多P主愁眉苦脸，看起来像是emo了，感觉他们这和大学坐场差不多了。\n匹老板的签售我哥们是真想要，不过再三纠结，因为中午还要回市中心本町那快拿忘在那的衣服，就回去了。\n中午的 INTEX 大阪\n回去是从岛北面的车站坐的电车，中间还走错了一次路，大阪中央线。时间大概也是20分钟到30分钟，可以说这个岛、我住的地方和市中心是个等边三角形。\n然后哥们穿着法批像个nt一样上了电车一直坐到人家餐厅，感谢过后拿到了丢在那里的衣服，然后店员又追出来冲着我们鞠躬然后阿里嘎多，我是真担心俩人能在这对鞠一下午，再次谢过后就跑路了。\n路上就困得不行了，本来出展子的时候还想着回去再逛逛展子，万一匹老板那边人少了还能排一排，结果一上闹钟直接犹豫了，一觉昏睡到下午4点，爬起来头疼的不行，不过马上就要去看live辣！还是起床罢！\n中午还有一点担心，明天台风就到了，总不会因为台风演一半取消或者出什么事吧，不过看情况好像问题也不算大。确认在三票没有丢掉，还在朋友手里，就出发了。\n这次不能再买错车票了，直接买够了票，坐电车到岛上，然后沿着熟悉的路走进去，顺便在路边的贩卖机买了瓶柠檬水，免得等会喊渴了。\n到了 INTEX 大阪基本已经开始进场了，激动的排队，然后就是进场了！\n演唱会场内部\n场馆其实说小也不算小，但是也不大。很令人失望的是我这个排数基本已经在中间的位置了，再往后一些就是S席的座位。到了座位之后，因为岛上比较潮湿，看前面甚至还有一些朦胧的雾气。\n很快人就多了起来，左面是两个妹子，后面一个，旁边还有个哥们，在那扯着一圈都是群友。渐渐的开始有人拿着应援棒喊着玩，跟着热场曲，喊着喊着灯就关了，热场曲的声音调大，大家便跟着热场曲打call，居然在我还没做好准备的时候不知不觉开场了！\n开场前几分钟\n今年的主题是 黑咯 HERO，所以不像是 10th 那种温馨的动画，而是日本人认为很帅的动画，之后第一首歌是《\tカルチャ》，今年的 OFFICAL ALBUM 中也有收录。我还顺便仔细盯了下模型，是C社新出的模，比之前那个很尖的下巴模好多了，之前的模还有个问题是大锯齿，不过作为中间排观众也看不出来就是了。\n需要很努力的盯才能看出来做的动作，真的很谢，我就该让欧皇朋友开票的好吧！\n第二首《像神一样》，之前听了半嘴说的是什么还以为是《神のまにまに》，我说这个曲子不太可能上mm的样子。\n第三首就炸裂了，有听过日场的群友沙哑着和我说（他嗓子喊哑了），和我说下一曲很炸裂，然后笑了笑不说是什么。\n然后是——《初音未来的消失》，几乎是入坑曲，在16年的 EXPO 还曾经期待过来着，虽然很多很多年没听过了，一听到熟悉的旋律响起，就想起七八年前的一个下午，在我奶奶家，那会我还没有智能手机，只能靠着我奶奶的红米2和10块钱300M的套餐下载歌听，也没有耳机，就把手机和头捂在被窝里，这样循环一个下午。\n然后我朋友在歌前奏起来的一片哇哦中喊了个“卧槽”。\n之后就是开场，不过嘛，我只听得懂“大家晚上好”和“マジカルミライ２０２３”，之后的歌曲就是双子的，我就摸了一半，至少坐下稍微休息一下，毕竟2小时真连着蹦跶恐怕撑不住。不过倒是没有像边上大哥一样直接玩手机，人家推另外五位的也在给葱打call，我多少也晃晃就是了，整的跟要分家似的搞的那么饭圈干嘛。\n不过对C社也有点不满的，一是葱的独唱曲太少了，今年大概只有一半左右，往年能到15/22首左右；二就是海外的位置越来越烂，17年是给到一个正中间的，后来就是一个不好不坏的位置，结果今年直接给扔到角落里，我的座位还是最靠中间的。\n中间时候加上了老哥，因为我成了群友的话这一圈就全是群友了，中间《ヘッジホッグ》我还是印象挺深的，喊了半天~~“痛い、痛い”和“思い、思い”~~\n再上初女士的歌的时候几乎过了半场，中间还是扣了会手机的，曲子是今年的优胜曲《king妃jack躍》，也很嗨！后来朋友的解释是，扑克牌里面的字和什么欢喜雀跃意思的同音，所以起了这个名字。\n看了下 BD，声音差很大，在台下听到的应援声几乎和舞台上一样大。\n之后的曲子是《ツギハギスタッカート》，也就是拼凑的断音，因为经常听mm17的关系，这首歌也算很熟悉，不过很明显能听出来重新调和编曲过，和17不太一样。\n然后就是大姐和大哥的时间，平心而论还挺好听的，不过大哥的必杀技有点让我绷不住，但是伞村的歌是真的好棒啊！\n然后大哥上场的时候，旁边的妹子直接防空警报启动，干穿耳膜直达灵魂。两位还拿手机录了一些，然后被后面小姐姐出警了，我一想，那我就站起来挡挡视线呗，两位真喜欢就拍吧，虽然确实不合规。然后我往那一站，后面出警的小姐姐就被我挡住了，看不见那两位的动作了。\n之后的几曲都是合唱，然后就是，乐队介绍——\n果然之前看 EXPO 时候说吉他手自带鬼畜是真的，这次拿了个电钻来弹吉他，超级搞笑。\n乐队介绍之后的歌曲大部分都是魔法未来的主题曲，说实话我感觉每年的主题曲质量都很不错。\n第一曲是 《ネクストネスト》\t(Next Nest)，当然，我个人的话如果日替是《39みゅーじっく！》会更满意，毕竟真的很能调动气氛，当然，Next Nest 也很嗨！\n第二曲是《ブレス・ユア・ブレス》，这首歌应该是19年的主题曲，中间的 \u0026ldquo;hello, hello, hello!\u0026rdquo; 对应的是砂之惑星中的 \u0026ldquo;bye, bye, bye\u0026rdquo;，当时下面大家跟着一起喊 \u0026ldquo;hello, hello, hello\u0026rdquo;，非常震撼。不过我个人更喜欢的日替是20年的《愛されなくても君がいる》。\n第三曲是《グリーンライツ・セレナーデ》，绿光小夜曲。虽然之前看 live 的时候觉得这个声音有些尖锐，当然也有风评说 omoi “炸厕所”。我个人认为这首歌调动气氛的能力相当强。可能是疫情憋了几年的原因，里面的很多歌词都有应援，比如“きいと、いつか” ，总之是嗨到了极点。\n这歌还是18年的主题曲，一晃竟然都过去了6年。绿光小夜曲5周年时候，omoi 作了一曲旋律一样，歌词不一样的歌曲叫《トゥー・ユー・グリーンライツ》（献给你的绿光），收录在专辑《初音ミク「マジカルミライ」10th Anniversary メモリアルソングCD》中，感觉调教的要比绿光小夜曲好，这么多年P主也收获了很多。\n大家在台下一起的挥舞着应援棒，结尾大家一起喊出震耳欲聋的 “マジカルミライへと”。\n之后的曲子是难忘今宵《Hand in hand》，这曲子比起前面几首更加熟悉，个人也很喜欢，kz的歌向来格局很大，比起39music来说，这首歌能感动全世界的葱粉。\n然后我在台下落泪了，不知道为什么，就是有些想哭，气氛到了，也有可能是就这首能听懂歌词。朋友倒是在我边上从头哭到尾。\n本来就在后排，泪水又模糊了眼睛，更看不清台上了。虽然舞蹈闭上眼也能脑补出来。我又总是按到切光的键，又时不时低下头去切回绿光。\n总之气氛比起绿光小夜曲不同的是，在嗨之中还加载着快乐。本来《Hand in hand》也是很快乐的旋律。\n之后又是一段“致辞”，无奈我听不太懂。\n下一首歌是完全没听过的，我还不知道这是 16th 请 DECO 的新曲，建模非常精细，发量终于回来了，DECO 一贯的高质量。这首歌大家的应援也很多，包括中间的\u0026quot;woah~\u0026quot;。\n总之这么壮观的应援BD是感觉不太出来的，可以听最后音乐落下那个\u0026quot;woah\u0026quot;在场内的回音。\n之后就是安可了！我没想到会这么快，因为我基本上从下半场才开始嗨，感觉就像刚嗨上来就要结束。\n安可的第一曲是米奇头作的，合唱的 《Brithday Song for ミク》，结束后又将初女士请出来，啊这个笑容真的可爱。\n之后又是一段话，然后就是最后一首歌，准备好了嘛！\n本次活动的主题歌——《HERO》。最后一次嗨，全场回荡着“H-E-R-O”in japanese english。\n这个真的挺帅的！\n结束后是在SEE YOU AGAIN，乐队的鞠躬和退场，之后大家又意犹未尽地跟着音乐应援了很长一段时间。\nLIVE结束的时候\n人走了小一半才依依不舍的离去。门口的STAFF给我们每个人都发了一份 BD 的传单。\n我当时还和朋友说一定一定要买，不过后来也没买，太贵了而且没设备放。\n日本人还是不会，如果是我就当场预售，保证能卖一大半。\n休息了一下，顺便买了饮料喝。\n之后看到群里说要合影，就蹭过去了，有人一起玩一起疯的感觉太棒了！\n顺便有群友送给我了一条彩带，当然，上是没有「マジカルミライ２０２３」的字样的，不然估计就要打起来了\n至于群友，他们还要聚餐，我俩看着时间不早，就回去了。\n人还沉浸在 live 中，应援棒都不想关。不过到了电车上朋友提醒我还是关了。因为好像确实有点迷惑\n晚上吃饭了吗？忘了，如果吃了应该就是车站附近的すき家。\n晚上干了什么呢？其实忘掉了。这天应该是回去循环了 \u0026ldquo;hello hello hello\u0026rdquo;，有在期待 BD 出了可以回顾，也有在遗憾快乐的时光转瞬即逝，也在担心台风天怎么回去？是早早跑机场看台风，然后看取消了住机场（我天真的以为第二天可以飞）还是说续住的地方？如果不能飞的话票钱怎么办，这会已经开始毫无头绪了。\n之后，航空公司的短信来了，航班由于天气原因取消，和我说重新定一班航班，我主要是怕他直接退款我买不到便宜的票，或者买不到回去的票。然后电话的客服一直是排队或者没人接，我和朋友就在排在线客服的队，取消的航班肯定不止这一班，所以人还是很多的。\n然后排了退出去他还会重来，太蠢了！\n排了应该是有一个小时，终于问到了，答案是可以换一天的同样航班的机票。台风影响到直到18号才有飞机回来，所以，现在是被迫多玩了！\n8.14 Day4 再逛日本桥 一觉睡醒终于休息过来一些了，按照原定计划来说，这天应该去奈良的，无奈明天台风登陆，看着地图上一点点接近的圈圈还是挺害怕的。在住处摆烂到了小中午，看着外面大太阳也不像台风快来了啊？\n早起的天气\n干脆再去趟日本桥好了，顺便买我的手办！\n没错，就是之前脸捏的超级可爱那个，想着还是拿下来吧，不然回去没准就是个遗憾。\n其实咱真没买过什么手办\n坐之前同样的地铁到难波站，巨大难波站原本熙熙攘攘的商店好多都关着门，有些店铺贴着告示是因为台风歇业。\n这地方有点像学姐家那边的情况，地下一个莫名其妙的“CITY WALK”，然后外面是地下通道外面是一圈商铺。不过他这个是和地铁连着的，看谷歌地图甚至能够从难波站都到近铁日本桥！\n出了日本桥，就一路往南过了一片银行的街，到了那家卖手办的店，一看没开门，以为关了。\n想着估计是拿不到手办了，应该是台风天关门了，有些失望，不过来都来了，当然是继续再逛一遍！\n之前我们看的是中间一条街，西面和东面还个有一条街，那边应该还是没有去过的。\n西面那条街最大的店当属——animate！\n电梯在门口，一楼进门就是很大的波奇酱吧唧和立牌，本来想给朋友买，不过将近100的价格确实不低了，买葱的时候怎么没觉得贵\n一楼里面有二手CD区，本来我们想买一个超电磁炮的CD，来了个国人二次元老哥劝我们说CD带不进去，还分享了他带本子的经历，= =\n不过这么一说确实就不太想带了，真带不进去太亏钱了，虽然二手CD不贵但是也有两顿饭了啊。\n当然这里还有很多很多很多的漫画！\n天使降临到我身边的漫画\n别当哥哥了的漫画\n高校舰队的全套BD\n然后在旁边的贩卖机里面搞了瓶生可乐，那阵子这东西很火，头一天还找了一次没找着。\n生可乐\n至于生可乐的味道嘛\u0026hellip;我也说不太上来，当时就说不清，何况现在快忘了，好像是比普通的可乐要“棉”很多？\n这边真的好多扭蛋机啊~\n朋友买了一摞书，我买了本真寻和HSF的小册子。然后他结账了，我觉得超10000日元可以退税，又推着他去问了。然后店员给我们办了退款，又重新扫码购买了一遍，省了很多税！\n在另一家店看到了碧蓝的柜子，准备买些东西送给可爱群友，不过AZ不知道他喜欢那个，买了张随机的色纸。\n碧蓝航线的柜子\n然后又发现了很多葱的吧唧，纠结了好长时间买了一个。\n还有一个是盲盒吧唧，不过难不倒我，他那个就是一个不透明的袋子，里面隔了一层纸，我直接捏着给摸形状摸出来了想要的款式。\n吧唧和盲盒！\n出来时候天就开始阴蒙蒙了，淅淅沥沥下起了小雨，他再不下我都开始怀疑这台风是假的了。\n然后我俩在大街上骂杂鱼台风，突然意识到路人的眼神有些不对。\n然后我俩就直接往回赶了，4点多回到住处我好好看了看手办和战利品\n可爱吧？我的！\n给谷子拍了张合影\n晚上去附近的すき家吃了饭，顺便走了两步。已经下起了淅淅沥沥的小雨。作为北方人我其实是没经历过啥台风的，感觉比电视上看的南方的台风小很多，也有可能是日本的评级不一样？\n在 booking 上看了一家道顿堀的酒店，虽然是比目前这个小木屋贵，但是有独立的洗澡间，我俩终于可以好好洗洗澡了！\n晚上干了啥？不知道，反正是很担心台风的，也非常担心明天受台风影响地铁会停运，甚至已经做好了破费打车过去的准备（悲\n我真的忘了好多啊\n8.15 Day5 台风天搬家 凌晨4点多醒了一次，外面大风呼啸，房子也有一些颤，不过看起来倒问题不大。\n还是起不来，睡到了大概九点、十点这样，看了看外面天气其实比凌晨时候要好得多，雨的程度放在国内其实是小到中雨，感觉自己白担心了\u0026hellip;\n杂鱼台风！\n拉上行李，和老板告别，打着伞开始往地铁站走。不过担心时间问题所以早饭还是没吃就跑了。\n好在地铁都在，我看这雨才这么大也没多担心，之前还害怕搁车里被水灌了，现在看来问题不大。\n到了难波站，原本很热闹的地下商业街店铺也都关门了，人也少了很多。\n好像还给台湾人换了钱\n到了日本桥站之后按着导航继续走，中间还路过了大阪市剧院还是什么玩意来着。然后有趣的来了，后来才发现这边好像是华人片区，路边各种店都是中国食品，路上见了什么网红烤毛肚啊，大连烧烤啊\n到了之后在旅馆门口等着，他那没有前台，全网上的处理。我就问客服能不能提早入住，在下面蹲着搓手机。\n中间还碰着一个新加坡人，我还以为是中国人。\n正巧碰上了大连的大妈来打扫，发现她打扫的就是我们那个屋子，我俩就直接把东西放进去了，去吃一个午饭+早饭。\n一路走过去，还走错了沿着河走人家后门去了，又绕回来从daodunku的正街走。这边门口就是一家大阪熟食城，卖延边特色、哈尔滨红肠，然后隔壁是卖煎饼油条手抓饼烤冷面的早餐店，不过价格确实吓人。过了马路有叫了只炸鸡、有周黑鸭有西安泡馍\u0026hellip;我俩都想着在这租个房子开蜜雪冰城算了。\n人特多，好在还算有位置吧，然后吃\n下午累得不行，回去洗澡，终于有独立的洗澡间了，内饰也是和中国酒店差不多，只不过很小\n哎还是中国人懂中国人\n8.16 Day6 大阪城 台风终于走啦！开启大阪城之旅！\n8.17 Day7 到处找 GIGO 店与 fufu 自从晚上瞎逛发现 GIGO 店居然有 fufu 后，决定到处找 fufu！\n晚上去唱了日本的 KTV（他们叫卡拉OK），结果没有原唱，然后两个人瞎唱一通。\n8.18 Day8 大阪-杭州-北京 回家了\n8.19 Day9 北京经典买错车票 欸哟喂，地道！\n8.20 Day10 回太原 开躺\n","date":"2023-09-06T17:29:22+08:00","image":"https://img.cdn.gaein.cn/website_used/blog/Travel-of-OSAKA/river-of-dotonnbori.webp","permalink":"https://blog.gaein.cn/passages/travel-of-osaka/","title":"2023 日本大阪游记 道顿堀/日本桥/魔法未来"},{"content":"前言 最近一个月在叔叔那直播动画，但是被封了。寻思自己随便找个服务器播着玩，搭了个开源的又对延迟什么的不满意，于是走上了折腾这一车直播协议的不归路。\n前置：编码、编码器、格式与容器？ 心里不是特别有底，可能有部分地方有疏漏或错误之处，还请谅解。\n编码(encode)/解码(decode) 我们说到多媒体时候，经常说什么 mp4 辣，avi 辣，同时又经常听到什么 H.265、H.264 这种“奇怪”的词。\n编码代表了如何去将视频变成二进制，解码代表了将编码出来的二进制在变成视频。\n为什么要编码呢？以一个 YUV 4:2:2 像素格式的 1080p 60FPS 视频为例，每秒的大小为 1920*1080*2*60=237Mb ，一个俩小时的电影就是小俩TB\u0026hellip; 这显然是不可接受的。编码在方便视频存储的同时根据相邻的帧相似的地方等进行压缩。\n什么？你说怎么实现？他很厉害，他不是一个有形的。所以你读《心经》，《心经》里面讲什么\u0026hellip;\n编(encoder)解(decoder)码器(codec) 此前说的编码是一种规范或者说算法，比如说 H.264 编码，要先这样再那样再那样，诶就好了。\n编解码器(codec)就是具体干这个的。\n比如 H.264 编码常见的编解码器有 libx264、nvenc 等等。\n如果你使用 ffmpeg 的话，不妨输入 ffmpeg -codecs 来看看 ffmpeg 支持的那些编解码和器。\n格式(format) 现在编码器已经可以根据编码把视频变成一大堆二进制了，如何存储他们？\n显然，直接将这一坨二进制写入磁盘不太合理，这样的话谁知道他用的什么编码，该如何解码？另外一个多媒体文件还可能会有音频，怎么区分开这一坨二进制里面的视频和音频？字幕怎么办？分章节的怎么办？\n显然，问题太多了，所以才有了格式，以比较简单的 avi 为例：\navi 嘛，全称是音频视频交错格式，这玩意就是一截音频，一截视频，一截音频，一截视频\u0026hellip;\n而 flv 是一个 header（标识有下面的内容有多少个字节之类），然后是一个tag，一个二进制，一个tag，一个二进制\u0026hellip;这种能够读一点、放一点的格式就很利好直播（毕竟有些格式二进制堆在一起，你放个电影得全下完才能播）\n注意，以上举例经过简化，实际格式比起文章内缩写复杂。这样写方便大家理解，如果需要了解这些格式的细节请自行查阅资料。\n容器(container) 很多时候“容器”与“格式”用的一个名字，比如 flv、mp4 等，容器便是你能看到的文件。容器可能会支持多种格式，比如著名的 Matroska ，支持几乎所有常见的格式。容器内除了多媒体内容外，还有一些 metadata（章节信息、标题等）。\n都有那些直播用协议？ 经典推拉流协议：RTMP/RTSP 对于如何做直播流这件事，最简单也是最好办的方法就是——\nRTMP RTMP 全名为 Real Time Messaging Protocol，开发后被 Adobe 收购。\n目前在各种领域应用广泛，几乎所有的直播平台都支持 RTMP 协议推流。\nRTMP 采用 TCP 连接，优点是稳定、延迟低。\nRTMP 采用经典广泛的 H.264 和 AAC，格式为 flv。\n缺点也很简单：现代浏览器不能使用 RTMP 拉流。也就是说浏览器不能直接播放 RTMP 直播流。\n目前通常只使用 RTMP 推流，各种直播客户端\u0026amp;APP可以使用 RTMP 拉流播放。\nRTSP RTSP 虽然名字和 RTMP 很像，但并不是一家的。RTSP 的特点是：使用 TCP 发送控制请求、使用 UDP 传输媒体数据。其使用 RTP 协议分视频块传输。\n有点是嘎嘎低延迟，但是在 Android 和 iOS 上似乎没有开箱即用的库。\n广泛应用于监控领域。\n基于HTTP的拉流协议：HTTP-Flv/HLS/MPEG-DASH 由于现代浏览器并没有直接办法发起 TCP 请求等（以前 RTMP 使用类似于 Java 浏览器插件等方式工作，但是由于安全原因现代浏览器并不支持这么干），所以需要将 RTMP 直播流进行简单的处理，将其变成浏览器能拿到的。\nHTTP-Flv 前文介绍过 Flv，它文件体内除了头，存储媒体信息的是一小段、一小段的，也就是说你不需要下载整个文件，就可以解码出其中的、你已经获取到的音视频。这种特性使得 flv 非常适合做直播。\n并且，由于以前 flash 插件的高流行度，使得使用 HTTP 获取 flv 文件边获取边播放的方式更加流行了。\nHTTP-Flv 相比较与其它方法来说延迟不高，但是缺点是——现代浏览器不支持 flash player 辣！\n噔噔咚，然后你就不能放 flv 了。HTML5 原生支持的只有 webm 和 mp4 等。\n解决办法总是有的嘛，还记得在 flash player 停止支持前 bilibili 的 HTML5 播放器 吗？没错，叔叔给他开源出来了，而且协议是 Apache-2.0。\n叔叔怎么解 flv 的？ 既然浏览器不支持 flv，那么叔叔怎么做的 flv.js 呢？难道是摁写 js 或者用 wasm 解析 flv 然后解码然后在浏览器上画？\n当然不是。有一个神奇的东西叫做 MSE ，video 标签不是只支持 mp4 吗？那我把 flv 变成小 mp4 总行了吧！Media Source Extension 支持在代码中构建 MediaSource 对象并将其作为 src 传递给 video 标签。\n简而言之，你只需要把东西变成 mp4 格式，不需要自己解码，然后交给浏览器就好了！\n当然，对于 h.265/HEVC 这种浏览器不支持的，叔叔那真就拿 wasm 开了一堆线程搁用户浏览器上软解，前阵子骂的沸沸扬扬的。\nflv.js 项目对于该实现的原文：\nflv.js works by transmuxing FLV file stream into ISO BMFF (Fragmented MP4) segments, followed by feeding mp4 segments into an HTML5 element through Media Source Extensions API.\n于是，有了叔叔的帮助，我们就可以在浏览器播放 flv 了，当然也可以看直播了。\n另外，注意 flv.js 项目首页上写道的：\nFor FLV live stream playback, please consider mpegts.js which is under active development.\nThis project will become rarely maintained.\n推荐我们使用 mpegts.js 来播放直播流，该项目开发者也是 flv.js 开发者之一，其对直播进行了优化。\nHLS HLS 全程是 HTTP Live Stream ，是水果公司整的。\n其具体工作原理是先获取一个列表文件，然后挨个请求里面的 ts 文件挨个播放。\n目前来说 HLS 支持在 IOS、Safari 及安卓上最新版本的浏览器/Chrome 浏览器。通过 js 也可以在其它现代浏览器上播放。\n目前可以播放 HLS 的 JS 播放器有：\nhls.js MPEG-DASH DASH 的意思是 “基于 HTTP 的动态自适应流”，DASH 技术很新，设计的很棒，其原理也是 XHR 请求视频数据块，再添加入 video 标签。\n不过据 SRS Github issue 说，DASH 的设计很棒有点“想得很美”的意思，似乎协议写的不是特别清除，实现的有些迷糊。\n目前可以播放 MPEG-DASH 的播放器有：\ndash.js shaka-player 新技术：WebRTC与SRT 除了以上几种经典方案外，近年来出现了 WebRTC 和 SRT 协议。\nWebRTC WebRTC 是一项实时通讯技术，建立点对点连接并实现任意数据传输。适用于浏览器的摄像头直播会议等场景。\nWebRTC 算是一种较新的技术。目前看来其前景广阔。但是经过测试不知道是 SRS 问题抑或是 WebRTC 问题，推流直播效果不够好。\nSRT SRT 为了解决 RTMP 的问题（旧、延迟高等），开发出了基于UDT（UDP的传输协议）的新协议。\n特点是快速连接以及按照时间发送音视频数据等。\n小缺点是 URL 不太容易看懂，另外就是其拥塞控制有些简单。\n使用 SRS 接收 RTMP/SRT 推流 推流工具 在b站直播，我们可以使用b站直播只因等工具。当然，大家也注意到了，有很多up主或者其它平台在使用 OBS Studio 这款软件。\nOBS Studio Open Broadcaster Software | OBS\nOBS Studio 更合适一般在电脑上的直播（比如各种游戏直播），可以实时看到反馈，使用方便。\nffmpeg 在无GUI环境下，更适合用 ffmpeg 进行推流。\nffmpeg 适合无人值守直播（比如7x24的动画片之类），易于编程和调用，性能要求低。\n浏览器端实现拉流播放 HTTP-FLV/HLS/DASH DPlayer Dplayer 是 DIYGOD 开发的播放器。支持多种媒体，且可以通过自定义 type 来支持其它 MSE 播放器来实现各种协议的视频播放。为了风格统一，使用了该播放器来做直播播放。\n编码实现 首先先在 vue 上初始化 Dplayer 播放器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;playerContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {computed, onMounted, onUpdated, ref} from \u0026#34;vue\u0026#34;; import createVideo from \u0026#34;@/utils/videoEngine\u0026#34;; import DPlayer, {DPlayerDanmaku} from \u0026#34;dplayer\u0026#34;; import {options} from \u0026#34;@/utils/request\u0026#34;; const props = defineProps\u0026lt;{ streamName: string }\u0026gt;(); const player = ref({} as DPlayer); const srsAddress = ref(options.serverAddress); const playerContainer = ref(); const videoItem = computed(() =\u0026gt; createVideo(liveType =\u0026gt; liveType.flvJs, srsAddress.value, props.streamName) ); onMounted(() =\u0026gt; { player.value = new DPlayer({ container: playerContainer.value as HTMLElement, live: true, autoplay: true, theme: \u0026#34;#F19EC2\u0026#34;, video: videoItem.value }); player.value?.play(); }); // 当源地址值更新时，切换视频。 onUpdated(() =\u0026gt; { player.value?.pause(); player.value?.switchVideo(videoItem.value, {} as DPlayerDanmaku); player.value?.play(); }); \u0026lt;/script\u0026gt; 其中，createVideo 方法是自己编写的工具方法，用于生成含有对应 customType 的 video 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 import mpegts from \u0026#34;mpegts.js\u0026#34;; import Mpegts from \u0026#34;mpegts.js\u0026#34;; import FlvJs from \u0026#34;flv.js\u0026#34;; import flvjs from \u0026#34;flv.js\u0026#34;; import Hls from \u0026#34;hls.js\u0026#34;; import dashjs, {MediaPlayerClass} from \u0026#34;dashjs\u0026#34;; enum MesPlayerName { HttpFlvByMpegTsJs = \u0026#34;mpegTsJs\u0026#34;, HttpFlvByFlvJs = \u0026#34;flvJs\u0026#34;, HLSByHlsJs = \u0026#34;hlsJs\u0026#34;, DASHByDashJs = \u0026#34;dashJs\u0026#34;, DASHByShaka = \u0026#34;dashShaka\u0026#34; } interface IMsePlayerInfo { name: MesPlayerName; player: any; extension: string; title: string; // 创建播放器 createPlayer(video: HTMLVideoElement): void // 加载直播流 loadPlayer(video: HTMLVideoElement): void hasStream(): boolean // 卸载直播流 unloadPlayer(): void } const _mesPlayerList: Array\u0026lt;IMsePlayerInfo\u0026gt; = [ { name: MesPlayerName.HttpFlvByMpegTsJs, player: null as Mpegts.Player, extension: \u0026#34;flv\u0026#34;, title: \u0026#34;HTTP-FLV(mpegts.js)\u0026#34;, createPlayer(video: HTMLVideoElement) { const streamUrl = video.src; this.player = mpegts.createPlayer({ type: \u0026#39;flv\u0026#39;, isLive: true, url: streamUrl, }); }, loadPlayer(video: HTMLVideoElement) { console.log(`[videoEngine,flvJs,unloadPlayer]detach and unload mpegts.js player.`) this.player.attachMediaElement(video); this.player.load(); this.player.on(mpegts.Events.LOADING_COMPLETE, () =\u0026gt; { this.player.play(); }); }, unloadPlayer() { console.log(`[videoEngine,flvJs,unloadPlayer]detach and unload mpegts.js player.`) this.player.detachMediaElement(); this.player.unload(); }, hasStream() { return this.player.isPlaying(); } }, { name: MesPlayerName.HttpFlvByFlvJs, player: null as FlvJs.Player, extension: \u0026#34;flv\u0026#34;, title: \u0026#34;HTTP-FLV(flv.js)\u0026#34;, createPlayer(video: HTMLVideoElement) { const streamUrl = video.src; this.player = flvjs.createPlayer({ type: \u0026#39;flv\u0026#39;, isLive: true, url: streamUrl, }); }, loadPlayer(video: HTMLVideoElement) { console.log(`[videoEngine,flvJs,unloadPlayer]detach and unload flv.js player.`) this.player.attachMediaElement(video); this.player.load(); }, unloadPlayer() { console.log(`[videoEngine,flvJs,unloadPlayer]detach and unload flv.js player.`) this.player.detachMediaElement(); this.player.unload(); }, hasStream() { return this.player.isPlaying(); } }, { name: MesPlayerName.HLSByHlsJs, player: null as Hls, extension: \u0026#34;m3u8\u0026#34;, title: \u0026#34;HLS(hls.js)\u0026#34;, createPlayer(video: HTMLVideoElement): any { this.player = new Hls(); }, loadPlayer(video: HTMLVideoElement) { const streamLink = video.src this.player.loadSource(streamLink); this.player.attachMedia(video); }, unloadPlayer() { console.log(`[videoEngine,hlsJs,unloadPlayer]nothing todo with hls.js player.`) }, hasStream() { return this.player.isLevelLoaded(0); } }, { name: MesPlayerName.DASHByDashJs, player: null as MediaPlayerClass, extension: \u0026#34;mpd\u0026#34;, title: \u0026#34;MPEG DASH(dash.js)\u0026#34;, createPlayer(video: HTMLVideoElement): any { this.player = dashjs.MediaPlayer() .create() }, loadPlayer(video: HTMLVideoElement) { const streamLink = video.src this.player.initialize(video, streamLink, false); this.player.updateSettings({streaming: {delay: {liveDelay: 10}}}); }, unloadPlayer() { this.player.reset(); console.log(`[videoEngine,hlsJs,unloadPlayer]nothing todo with hls.js player.`) }, hasStream() { return true; } } ] export function getPlayerInfo(playerName: MesPlayerName): IMsePlayerInfo | undefined { const playerInfo = _mesPlayerList.find(player =\u0026gt; player.name == playerName); if (!playerInfo) { console.log(`[videoEngine,getPlayerInfo]can not find player named ${playerName}.`); } return playerInfo; } export default function createVideo(playerName: MesPlayerName, srsAddress: string, streamName: string) { const playerInfo = _mesPlayerList.find((player) =\u0026gt; player.name == playerName); if (!playerInfo) { console.log(`[videoEngine,createVideo]can not find player${playerName}.`); return; } const streamUrl = `//${srsAddress}:8080/live/${streamName}.${playerInfo.extension}`; return { url: streamUrl, type: \u0026#34;streamPlayer\u0026#34;, pic: \u0026#34;./PM5644.webp\u0026#34;, customType: { streamPlayer: (video: HTMLVideoElement) =\u0026gt; { if (!playerInfo.player) { playerInfo.createPlayer(video); } else if (playerInfo.hasStream()) { playerInfo.unloadPlayer(); } playerInfo.loadPlayer(video); } } } } 完整实现见：live_room\n参考 指南 | DPlayer 实时传输 Web 音频与视频 - Web 开发者指南 | MDN video-dev/hls.js: HLS.js is a JavaScript library that plays HLS in browsers with support for MSE. Dash-Industry-Forum/dash.js: A reference client implementation for the playback of MPEG DASH via Javascript and compliant browsers. shaka-project/shaka-player: JavaScript player library / DASH \u0026amp; HLS client / MSE-EME player xqq/mpegts.js: HTML5 MPEG2-TS / FLV Stream Player ","date":"2023-07-11T19:05:15+08:00","image":"https://img.cdn.gaein.cn/website_used/blog/Live-streaming-protocols/cover.webp","permalink":"https://blog.gaein.cn/passages/live-streaming-protocols/","title":"直播推流常见协议及网页端实现 RTMP/STR/FLV/HLS/WebRTC"},{"content":"初音ミク「マジカルミライ2023」魔法未来2023 大阪攻略 契机 2023年，疫情就这么悄无声息的结束了。从上初中开始就一直有去日本看魔法未来的愿景，自己也一直在看魔法未来的蓝光 BD。舞台效果确实也比初三时候看的 MIKU EXPO 要好。\n最近翻了一下 17 和 18 的未来有你，发现糟心事真的多，虽然当时就有耳闻没想到这么离谱，还是咱看的 EXPO 巴适。\n问题在于出国这件事情有亿点麻烦，而且早就听说魔法未来的票需要抽选，一直以为票就要花上几千大几，感觉要花个好几万才能去一次，就想着大学去——然后我的大学就在宿舍和家的床上度过了。\n3月时候和朋友闲聊聊到这件事，他也很想去，干脆我们就点进魔法未来的官网然后票价是——9700JPY（约合人民币500）！这还是SS的价格，相比于国内的未来有你或EXPO来说价格非常便宜了，我俩干脆就直接开整！\n不过说实话今年的主视觉图不太符合我自己的审美，不过抽票先辣！\n票务 在我想去魔法未来的时候正好是日本本土抽票一轮开始的日子，因此我参加了正好两轮抽票。\n魔法未来的抽票活动在 PIA 上进行。\n抽票需要一张 VISA 卡组织或者万事达的卡。\n关于抽票难度，往常是 日场难度\u0026gt;夜场，SS\u0026gt;S\u0026gt;A，千秋乐（最后一天）\u0026gt;其它，东京\u0026gt;大阪。魔法未来 2024 新增了福冈，并且将大阪调到东京的后面，大阪的千秋乐成了真千秋乐，有可能会更难抽。\n第一轮-本土票 抽票结果与提交时间无关，只要在抽票时间内提交即可。\n本土票只有在日文的网页上才会有链接，其它语言的网页只有海外票的链接。\nPIA 的网页是全日文的，还好朋友是大罕见，所以看起来没什么问题。\n从官网点击进入抽票页面，就是各种注意、须知之类的。\n其中有一条的意思是：“抽票需要注册 PIA 账号，抽票使用的手机号必须和 PIA 上面注册的一致，不然抽中了也没法给你”\n想要抽选日本本土票需要一个日本手机号，因为注册PIA需要语音验证，所以手机号必须还是能打电话那种，各种接码平台自然就不能用了。\n然后也尝试了各种虚拟号码，用不了。最终是找在日本留学的朋友接了一下才成功注册好。\n注册完成自然是抽票，抽票的话每次抽选可以选择一场的不同座位（有 A/S/SS ，A是听个响、S是看个影、只有SS才有可能看清楚（悲）），可以抽选不同日期的不同场次，有可能会中多场。\n意思是每个手机号可能会中不同场次的票，但是不会重复中同一场同座位席别的票。\n另外，日本本土票的 SS 是很难抽的，大阪相对来说还好一点，东京更难。\n我这种非酋自然也是——全空。\n如果需要找卖日本手机号或者什么代抽票的话要尽早，在开抽时候就完全没有了。\n取票 可以在 PIA 的 CLOK 平台上选择取票方式，有电子票和纸制两种。纸制票可以去7-11便利店取。\n取票的日期在演唱会开始前一两周。\n抽票结果 插在二轮之前说一下抽票结果。\n抽票结果时间在日本时间 18:00（也就是东八区的下午5点）。不过这个时候是公布结果，使用信用卡的话，扣款工作其实已经完成了。扣款是从前一天的下午（大概）开始的，如果你发现信用卡被扣款了，那么恭喜你中了！如果一直到出票当天的下午也没扣，那八成是寄了。\n当然要以最终公布的结果为准辣~\n据群友们说，有重复扣款再退款的。比如说你申请了很多场的SS，然后扣款了2wJPY，不一定是中了两张SS哦，有可能是中了一张扣了两次然后在退回去。这也太笨蛋了吧！\n然后在等第二轮抽票开始之前这段时间里我把我珍藏的两根 魔法未来2017 的应援棒丢了，出去玩的时候带过去了，然后回来时候忘了（悲\n结果愣是找不到了，店家也说没看见过，估计是被谁家小孩捡走或者拿去卖破烂了。（因为我翻了好几个小时的垃圾堆，把他们那的垃圾堆翻了个底朝天也没看见）\n两根棒子花了我大概800块钱，最难受的是自己心爱的东西被别人当成垃圾了。比较官方棒子的做工看起来就值30块钱的样子\n最后没办法，权当献祭了来安慰自己了。表弟来山西找我玩顺便拉着去五台山拜了拜五爷庙。\n第二轮-本土/海外票 抽票结果与提交时间无关，只要在抽票时间内提交即可。\n海外票的链接显示在非日文的网页上（比如简体中文），本土票依旧是只有日文网页才有链接。\n海外票可以用任意手机号，相对日本本土票来说更方便（日本手机号太难搞了呜呜）\nPIA 海外票是英文页面，本土票依旧是日文页面。按照上面的提示来就可以了。\n然后我海外票单抽了最后一天的夜场SS两张。结果中了，看来还是要献祭的。\n关于海外票的座位，群友说的是一般“不好也不坏但是可能偏好一点”，集中在不前也不后的位置，中间稍微偏一点的地方。\n所以海外票就别想着第一排辣~\n取票 本土票依旧是可以在 PIA 的 CLOK 平台上选择取票方式，有电子票和纸制两种。纸制票可以去7-11便利店取。\n海外票只支持到7-11便利店领取，需要打印（hard copy）中票的电子邮件。\n取票的日期在演唱会开始前一两周。\n宿泊 宿泊就是官方卖的酒店+票的服务，然后还有一些特典。\n宿泊非常贵、而且一些好的场次会直接抢空。可能适合一些富佬专门蹲好的场次\u0026amp;特典罢。\n咱因为过于贫穷没有参加。\n第三轮-本土 二轮结束的时候，官网多出来了一个“チケットぴあ　特別先行”。看样子是又抽了一轮？\n这次可以选择单线下票、单展子票等。\n取票 仅支持在7-11便利店取纸制票。\n取票的日期在演唱会开始前一两周。\n护照\u0026amp;签证 首先说一下这两个东西：\n护照是国籍国发给公民的、在外面证明身份用的东西。也就是中国外交部发给你这个本本，告诉外国人，这位是合法的中国公民。\n官网的介绍是：中华人民共和国护照是中华人民共和国公民出入国境和在国外证明国籍和身份的证件。\n而签证（大概）是外国允许你进入、短暂/长期停留的凭证。\n护照办理 本过程可以参考 国家移民管理局政务服务平台-普通护照签发服务指南\n护照属于个人身份证件。普通护照一般都给办理的。（除疫情期间）\n我查询了下出入境管理机构，呼了个电话过去问了问东西，他说就带身份证和活人就可以。\n办事机构查询\n政务服务平台的APP\u0026amp;小程序似乎可以在线办理，不过我学校附近的出入境管理那边说人不多让我直接过去就OK。\n然后过去、拍照、排队、填单子然后交钱，回去静等护照发过来就行了。\n护照有邮递、自取两种，我选择了邮递，然后EMS从杏花岭区邮到尖草坪区用了两天还要了我20\u0026hellip;\n关于异地办理 护照现在不需要在户籍所在地办理，我的护照就是在山西办理的。不过民警会询问为什么异地办理，我的理由是在太原上学，然后向我索要了学生证，我提供了学校的学生卡也没有问题。\n所以如果是异地办理除了身份证最好还带上其他证件罢，比如居住证或者是学生证等。\n签证办理 日本大使馆不受理个人赴日个人旅游签，签证由指定的旅行社代办。全国分为多个领事馆区，据说南方（广州、上海）等拒签率更低一些，但是异地办理似乎需要氪金。\n具体地区对应的使馆见：关于使馆 | 日本国驻华大使馆\n指定的代办旅行社查询：赴日观光旅游业务指定旅行社 | 日本国驻华大使馆\n然后你只需要一个电话呼过去问他就行了。\n然后我3月、4月、5月得到的答复都是——不太好办、六月再问问。\n资料准备 需要准备的资料见官网：所需材料\n作为带学牲、申请个人旅游单次签证，需要的材料有：\n护照 签证申请表 个人信息处理同意书 户口本等，能确认本人居住地的资料 大学出具的在学证明书或毕业证书 注：大学生指：中国国内的高校，中国教育部公布的名单中所列的所有普通本科高校的在校本科生、研究生（博士及硕士在读）或者毕业于该校三年以内的毕业生。\n不是带学牲的话需要准备“能确认经济能力的资料”\n申请表之类的旅行社似乎会帮你准备哦。\n现在刚刚到6月，明天准备呼旅行社去，看看怎么样吧QAQ\n问了下大使馆指定的旅行社（太原）结果要求我提供父母双方各自的10万年收入流水、20万存款证明，我直接呃呃。\n在淘宝上找了几家旅行社，有加钱送上海的、有不能送的、有原价送北京的\u0026hellip;.\n奇怪是有些旅行社并不算大使馆指定的代办旅行社，也能办而且也不贵。\n最后我选择了一家北京的非大使馆指定的旅行社，价格为 390 元，需要准备并邮寄以下材料：\n护照原件； 户口本首页、户主页、个人页复印件； 学信网的教育部学籍在线验证报告； 近三月白底证件照（深色衣服）； 送签 按照旅行社说的递交他们需要的材料，旅行社会帮你审查、准备更多申请材料。寄过去后旅行社送到领区大使馆，然后大使馆再去处理签证。\n出签时间为 10 个工作日内，实际上我的第 6 个工作日就出了。\n6月19日后日本开放电子签证，具体情况请关注官网或咨询旅行社。\n最近签证政策有些紧缩，不太容易过。\n出签 拿到签证！日本的单次签通常是一张小卡片，随便粘在护照的某一页。\n机票 目前看了下，飞大阪有大概以下几种：\n北京(BJS)-大阪(OSA)：优点是在北方、离得近，而且北京相对来说熟悉一些。 上海(SHA)-大阪(OSA)：优点是部分直飞比较便宜。\n我是比较倾向于北京飞大阪的，因为 70 块钱能润去北京而不能去上海（悲）\n北京(BJS)-大阪(OSA) 以下方案约在 3200 左右（往返）\n国泰北京转香港飞大阪：优点是便宜，缺点是国泰态度据说恶心、还有转机。 海航北京直飞大阪：优点是便宜，缺点是不算超级便宜。 南航北京转大连飞大阪：优点是可以去大连蹭饭，缺点是不算超级便宜。 上海(SHA)-大阪(OSA) 春秋上海直飞大阪：优点是大概会便宜。 办完签证后立刻开始看机票，正好厦门航空往返 2300 的机票，剩余两个座位，于是就和朋友直接买了。\n因为实在不知道机票什么时候便宜，就直接冲了。\n住宿\u0026amp;出行\u0026amp;通讯 住宿 因为大阪的演唱会在 INTEX 大阪 举办，在一个稍微有点小偏的人造岛上，因此我在 booking 上预定了大阪空气旅社（在住之江区）。\n这家旅社是双人间、价格还算便宜，正好我和朋友两个人住。\n住完补充：旅社、INTEX 大阪、大阪市区正好在一个三角形，旅社到 INTEX 大阪只需要坐四桥线一站到终点，然后坐电车直达那个岛。岛上也可坐中央线直达市里。\n这家旅社的具体环境不算太好，日式的榻榻米，木质的小房子我俩都不敢蹦跶，正好赶上台风房子还在晃。浴室、厕所等都是公用的。\n订旅社一定要留意周围的车站以及怎么过去，要不要转车等。离能够直达的车站近才是真的近。\n出行 日本的地图非常有迷惑性，看上去感觉很远的地方实际上也没有超级远。大阪空气旅社看起来离那个岛就像隔了某城市的一个区，一眼看也有几十公里，但是地图一量不到半个小时的电车就能过去了。\n据说有卡，什么大阪一日卡之类的，可以免乘车费。\n卡券 主要的是大阪地下铁一日/两日券，由 OSAKA METRO 发行，大阪市地下铁的价格基本坐就是十几块，这个卡可以无限坐还是非常值的。当然，有一些线路不能免费还需要注意。\n另外这个券不同于大阪周游卡，在难波站的 27 出口附近取而不是在难波旅客中心。\n如果逛的经典比较多的话，大阪周游卡/关西周游卡也是很不错的选择。具体来说看你的出行安排。\n通讯 手机卡？还不知道怎么办。据说能办香港的然后漫游？\n我个人来说办了两张 IIJ 和香港 JOYTEL 的 SIM 卡。淘宝价格差不多 50 元 / 10 G。\n体验上 IIJ 的并不如香港的 JOYTEL，我的淘宝写着 IIJ 的还需要手动设置 APN 等，实际信号、速度也不行。\n至于使用方法，下飞机插上卡就行了，更详细的卖家会告诉你的。\n带什么东西？ 生活用品 日本很多民宿或青年旅社和国内不一样，可能不会提供免费的毛巾或一次性牙刷等。\n除此之外也可以考虑带上卫生纸，日本那边的纸很薄，多少有些不能适应。你也不希望漏了罢！\n另外日本街上是没有公共垃圾桶的，大部分地方的垃圾桶你也不能扔，垃圾只能带回自己居住的地方处理，所以带上几个垃圾袋或者塑料袋是很好的选择。\n供电 日本的市电是 100v 不同于中国的 220v，不过我的神奇新华三充电器（没错，新华三的氮化镓充电器，办活动送的纪念品）支持100v-240v输入，对于我这种 typec 可以充大部分设备的人来说应该也够用了。\n另外日本的电网频率有 50Hz 和 60Hz 两种，具体历史渊源希望了解的可以自己查。检查下自己的设备需要支持这个。\n单反的电池充电看了一眼也是 100v-240v 宽幅输入。所以我没带任何电源转换设备。\n当然，如果不放心的话带一个旅行的电源转换器也不错，大概就在100元左右。\n哦对了，我还需要为我们俩的应援棒备上 114514 节电池。\n小马扎（x 排队必备！企划展要从7点排到9点，虽然有点怪，但是可以考虑带一个。\n不能带的东西 除了枪支弹药毒品之类的，限制主要在机场、航空公司的要求和两国的海关。\n不能带上飞机的东西：液体，超过100wh的（大概3w+ mAh）以及你觉得不能带的（x\n不确定的上网查或者打电话呼过去问问\n不能出中国海关的东西：除了常见的不能出的之外，没啥特别注意的。\n不能入日本海关的东西：动植物制品、种子、盗版东西。所以各种食物需要注意一下了，那种带包装的点心或者糖果应该没问题。\n不能出日本海关的东西：没啥特别注意的。\n不能入中国海关的东西：色色不行，书籍10本及以下免税，CD重复的不超过两张，烟两条及以下免税。\n带本子只能提醒大家别侥幸，被海关抽查到多少有点丢人的。\n企划展 企划展在 7:00 开始整队，在此之前的排队无效。整队后会带入空会场等待开场（今年为了防止中暑特地将候场更换到了有空调的3号馆）\n9:00 准时检票入场，入场后可以跑去排官方场贩，我因为坐错电车（悲）7:13才到，当时已经排了很多人，到场之后单人的法批基本全部卖光，好在主视觉的法批还有。10th 专辑也很快卖光了。\n如果有你非常想要的，或者主视觉图非常好看的，请一定要记得提前到！\n之后便是快乐的逛展子，当然有很多好看的周边也需要排队QAQ。STAGE 区域还有一些演出，这个看当年的官网即可。\n企划展中间可以出去，会发给你再入场的手环。我的计划是中午出去吃了个饭，顺便回住处放了下东西，休息了下才来看 LIVE。\n演唱会 LIVE 的入场非常快，所以大家不需要担心排不上，差不多提前半小时来就肯定没问题！\n截止 魔法未来2023 大阪场，没有人会查验票上的名字。\n入场后找到自己的位置。a列b番 的意思为 a排b列，之后尽情享受演出罢！\n如果你和我一样是高强度蹦跶用户，全蹦跶下来可能不太行，建议健身或者适当休息。\n演唱会结束后已经黑了，可以坐电车回市里吃。\n关于拍照 整场禁止拍照，请自觉。被 STAFF 出警可能会被请出去。\n","date":"2023-05-30T20:27:11+08:00","image":"https://img.cdn.gaein.cn/website_used/blog/Travel-of-OSAKA/magical-mirai-flags.webp","permalink":"https://blog.gaein.cn/passages/magical-mirai-2023-osa/","title":"初音ミク「マジカルミライ」魔法未来2023 大阪攻略"},{"content":"玉田公交线路图 概览 点击图片可查看大图，更多缩放功能使用下文的查看器或独立页面的查看器\n查看器 {% raw %}\n{% endraw %}\n独立页面的查看器\n数据来源 玉田生活 腾讯出行服务 附 使用 railmapgen.github.io 绘制，转载请附上本文链接。\n","date":"2023-02-11T15:10:18+08:00","permalink":"https://blog.gaein.cn/passages/yutian-bus-map/","title":"玉田公交线路图"},{"content":"前言 自从大一坐到 AimerNeige 身边以来，就见到他的双系统 Linux。后来自己也装了一个 ubuntu server + i3wm 日常用（虽然后来因为臭打游戏的原因回 windows 了），不得不说 Linux 的命令行以及各种命令行工具用起来非常的爽啊，相比较而言，用 windows 几乎很少用到命令行，cmd 和 powershell 都很丑，而且默认字体对眼睛很不友好 :D。以及各种工具并不多导致我不怎么用。\n美化 个性化你的Windows Terminal终端与PowerShell 其实以前写过一篇文章来记录如何安装配置 Windows Terminal 和 Powershell 7（后改名 Powershell Core，现名 Powershell）（谢谢微软改名部）\n至于字体方面选择了 Cascadia Code。\n注意，oh-my-posh 需要使用 Nerd Font 字体，否则不能正常显示各种图标。\n包管理 Linux 各种发行版通常有着一个包管理，pacman 也好、apt 也好、傻逼 snap 也好，总之有一个。Windows 这边没有一个中心化的包管理器，不管是微软的 win-get 还是第三方的 choco 和 scoop，都是直接从软件发行商那边进行下载的。不过我比较喜欢 scoop 的 portable 的思想，所以使用了 scoop 作为我的包管理器，配置各种环境非常舒适。\n至于 scoop 的安装，参考其官网即可。顺带一提，scoop 的“软件源”在 Github 上，你可能需要某些技术来解决连接性问题。\n当然，对于某些 scoop 内没有的软件包，可以使用 win-get 来安装。\nscoop 常用指令 scoop help 查看帮助 scoop update 更新软件源 scoop update * 安装所有包的更新 scoop search \u0026lt;keyword\u0026gt; 搜索包 scoop info \u0026lt;package name\u0026gt; 查看包的详细信息 scoop cleanup * 清理软件包\n更多命令：自己看吧。\n使用 scoop 配置环境 平时会用到各种语言的环境（虽然我是远程编译人但是本地还是有环境罢）\n哦其实好像根本不用怎么配，你只需要：\nscoop install gcc scoop install nodejs scoop install python\n\u0026hellip;\n之类的。\n怎么样，是不是非常爽？终于不用找到官网然后点 download 然后疯狂 next 了。\nCLI 工具 命令行美化 oh-my-posh —— prompt 美化 lsd —— 列出文件\n网络工具 nmap —— 扫描 tcping —— 测试端口连接性 clash —— 代理分流 wireshark —— 抓包 nexttrace —— 路由追踪\n系统管理 btop —— 资源任务管理 neofetch —— 让我看看（系统信息）\n当然，还有很多例如 ffmpeg 这种多媒体处理、7z、 tar 这种压缩解压以及各种其它工具。\n自定义脚本 bash 使用 .bashrc 作为用户启动 shell 时执行的脚本，而 powershell 则会执行一个 .ps1 脚本，这个脚本的位置可以保存在 Powershell 中名为 $PROFILE 的变量。\n可以使用 Write-Host $PROFILE 来查看路径。\n这个脚本在我那篇 Window Terminal 也提过。不过在那个玩意的基础上，我最近又添加了一些自己用的实用函数：\n比如先对于“在 Windows Terminal 中打开” 的 “在文件资源管理器中打开”：\n1 2 3 4 5 6 7 8 9 function Get-Exploere { param( [string]$Path = $PWD ) explorer.exe $Path; } Set-Alias -Name open -Value Get-Exploere 用于测试命令是否存在：\n1 2 3 4 5 6 7 function Test-Command { param( [string] $CommandName ) return $null -ne (Get-Command $CommandName -ErrorAction SilentlyContinue) } 当然还有很多别名，比如将 ls 改为使用 lsd：\n1 2 3 4 5 6 7 8 9 function Get-Item-Line { lsd -lh } if (Test-Command lsd) { Set-Alias -Name ls -Value lsd Set-Alias -Name ll -Value Get-Item-Line } 除此之外，为 ffmpeg 的常见操作也写了一些函数：\n比如如下代码可以将图片转为 webp 格式并且调整大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Get-Webp { param( [string] $FileName, [int] $Width = -1, [int] $Height = -1 ) $file = Get-Item $FileName; if (($Width -ne -1) -and ( $Height -ne -1) ) { ffmpeg -i $file.FullName $file.Name.Replace($file.Extension, \u0026#34;.webp\u0026#34;); } else { ffmpeg -i $file.FullName -vf scale=${Width}:${Height} $file.Name.Replace($file.Extension, \u0026#34;.webp\u0026#34;); } } 另外，powershell 中 mv、ls 等命令的用法和 Linux 下的 shell 极为相似，上手也很快。\n","date":"2022-11-09T10:26:22+08:00","permalink":"https://blog.gaein.cn/passages/use-cli-in-windows/","title":"在 Windows 下舒适的使用命令行"},{"content":"原来的虚拟机是一台实验用的设备，因为过度耦合，所以准备迁移到一台新开的专门提供服务的虚拟机，系统为 Ubuntu server 22.04 LTS。\n本博客实际上是由旧的服务器向新的服务器迁移并且重新部署的过程中写的，因此 InfluxDB 没有使用最新的 2.4 版本而是使用了 1.8.10。\n非常的帅气\nInfluxDB 安装 InfluxDB 参考 influxdata | 清华大学开源软件镜像站\nTUNA 这里并没有适用于 Ubuntu 22.04 LTS 的选项，不过问题不大。\n向 /etc/apt/sources.list.d/influxdb.list 写入：\n1 deb https://mirrors.tuna.tsinghua.edu.cn/influxdata/ubuntu/ jammy stable 添加公钥：\n1 wget -qO https://repos.influxdata.com/influxdb.key | sudo tee /etc/apt/trusted.gpg.d/influxdb.asc 为什么不用 apt-key ？因为已经废弃辣，详见 man apt-key\n之后使用 apt install influxdb 安装即可。\n配置 InfluxDB 主要目的就是两个：开放 udp 和 http 连接。\nPromox VE 使用 udp 连接，Grafana 使用 http。\n修改 /etc/influxdb/influxdb.conf\n[http] 部分修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 [http] # Determines whether HTTP endpoint is enabled. enabled = true # Determines whether the Flux query endpoint is enabled. # flux-enabled = false # Determines whether the Flux query logging is enabled. # flux-log-enabled = false # The bind address used by the HTTP service. bind-address = \u0026#34;:8086\u0026#34; 取消 enabled 和 bind-address 的注释即可。\nudp 部分修改如下\n1 2 3 4 5 [[udp]] enabled = true bind-address = \u0026#34;:8089\u0026#34; database = \u0026#34;proxmox\u0026#34; # retention-policy = \u0026#34;\u0026#34; 也是取消两个注释，然后将 database 节点设置为 proxmox 。\n还需要创建用户，因为我是从以前的迁移过来的，所以不需要再创建。\n启用 InfluxDB 使用命令\n1 systemctl start influxdb 即可。\n如果报错类似于以下的\n1 run: open server: open tsdb store: mkdir /var/lib/influxdb/data/_internal/_series: permission denied 可能是因为使用过 root 用户运行 influxd。\n执行\n1 sudo chmod -R influxdb:influxdb /var/lib/influxdb/* 即可。\nProxmox VE 点击 DataCenter，再点击 Metric Server。\n依次点击 Add，InfluxDB，在 server 处指定提供 InfluxDB 的虚拟机的 IP。\nGrafana 安装 Grafana 依旧是参考 grafana | 清华大学开源软件镜像站 。\n首先使用\n1 wget -qO- https://packages.grafana.com/gpg.key | sudo tee /etc/apt/trusted.gpg.d/grafana.asc 将\n1 deb https://mirrors.tuna.tsinghua.edu.cn/grafana/apt/ stable main 写入 /etc/apt/sources.list.d/grafana.list。\n然后执行：\n1 2 sudo apt update sudo apt install grafana 配置 Grafana 大部分配置都是从原服务器上恢复（因为实在不想重新设置面板了）\n/var/lib/grafana/grafana.db # 数据库文件 /etc/grafana/grafana.ini # grafana配置文件 /var/lib/grafana/plugins # 插件目录 设置匿名访问 编辑配置文件，找到\n1 2 3 [auth.anonymous] # enable anonymous access enabled = true 取消注释并改为 true。\nNginx grafana 默认监听在 3000 端口，这样用起来非常的 low，这里使用 nginx 把 localhost:3000 反向代理到 http://grafana-server/monitor/ 。\n修改配置文件 /etc/nginx/sites-enabled/default ，在 server 块内添加：\n1 2 3 4 5 6 # Grafana location /monitor/ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://localhost:3000; } ","date":"2022-10-03T19:11:23+08:00","permalink":"https://blog.gaein.cn/passages/pve-with-grafana/","title":"使用 Grafana 监控你的 PromoxVE 集群"},{"content":" 一定要勤备份配置\n前言 我似乎好久好久没写过博客了\n怎么感觉一不小心写成流水日记了\n树莓派 server 时代 上学期疫情在家整整呆了半年，越看家里网络越不顺眼。以前是电信的光猫+华为路由器，不能用zt连学校资源，也不怎么好挂pt，也没有代理服务器（clash 跑在本机有些太费电）。于是着手弄我朋友送我的一个树莓派，刷单臂软路由，无奈 DHCP 一直配不好\u0026hellip;结果就鸽子了，跑个 ubuntu server 当内网服务器用了\u0026hellip;\n折腾 OpenWRT 与 小米AC2100 后来在 TJUPT 内部群唠嗑90收了一个小米AC2100，我家的旧华为路由器海鲜市场卖了110，还挺神奇的。\n于是，小米AC2100开始刷 OpenWRT，最开始在恩山上面找了许多包，不过都有些小问题（WLAN 得手动开的、配置防火墙卡死的\u0026hellip;）直到用了我同学推荐的 OpenWRT固件下载与在线定制编译，一个大佬适配的固件，貌似是用 GithubAction 在线编译。虽然一些功能需要赞助才能开（自定义主机名之类的）不过也就无所谓了。光猫桥接、开 ipv6、拨号上网一气呵成，舒服多了。\n公网IP 与 3965U 软路由 之后我家的网络大抵稳定了一段时间，直到看见同学找电信客服（或许是安徽电信）要了个公网IP，想了一想似乎也挺方便，我也去问问。不过河北的在线客服不能直接办，要留你的联系方式等着当地的维修师傅打电话。当时已经傍晚了，没想到过了一个小时师傅来了电话，和我谈妥了。他说明天上午保电信局审批，到时候告诉我，我重新拨号试试。我一觉呼呼大睡起来就有了。\n关于公网 IP ，似乎电信要起来更方便一些。至于端口是 REJECT 了 80、 443、8080 ，应该是工信部的要求。\n寻思着都这样了，不如再搞个软路由挂 PT？正好很久以前拖欠的黑工工钱到了，就去海鲜市场买了个 3965U 软路由，4t HGST 的机械硬盘，一台 H3C 铁壳千兆交换机（问就是“企业级”）、AMP 的网线、mPCIE 千兆网卡\u0026hellip;\n外壳切了，把 mPCIE 网卡的 RJ45 口引出来。\nmSATA 的硬盘没法插电脑，传统的镜像写入软件写不了硬盘，最后弄了个 WTG 在软路由本机刷机。\n后来因为手贱更新之类又炸了两次，终于一切弄好装进弱电柜——电源炸了，连带主板一起开不开了。拔下电源万用表测输出 AC 12V，可能是整流器坏了\u0026hellip;？\nJ1900 软路由，一体化供电 弄都弄了，干脆又买了一台 J1900 （因为实在买不到那么便宜的 3965U 了），刷系统、小米 AC2100 刷系统做 ap\u0026hellip;\n另外有一点非常神奇的是，我所有的设备全是 12v 直流供电，因此直接买了一个 12v 直流电源（100W 的大概二三十）。服务器电源改 比较便宜但是弱电柜放不下，看了半天尺寸只好买了一个明纬的二手电源。\n顺便 3.5 寸的 SATA 硬盘也需要一个 12v 供电，改了一个上去，5v 和 GND 依旧用软路由自带的供电。\n看上去好危险啊（小声）\n软路由 OpenWRT 安装 为了更方便的刷写 mSATA 硬盘，我买了一个 mSATA 转 SATA 的硬盘盒，再接一个 SATA 转 USB 的\u0026hellip;\n使用 balenaEtcher 可以刷写硬盘而不仅仅是 U 盘，当然，使用 Linux 系统的 dd 命令、或者在 WinPE 下使用 physdiskwrite.exe 来写入：\n1 physdiskwrite.exe -u openwrt-21.02.0-x86-64-generic-ext4-combined.img.gz -d 0 安装完后直接进入系统即可，我在这遇到了一点小问题：我的机器无法进入 UEFI 固件设置，没办法改启动项，所以只好在 EFI 分区中编写 startup.nsh 脚本。\n内容如下：\n1 fs0:\\efi\\boot\\bootx64.efi 配置软路由 OpenWRT 安装完系统后连接到软路由（网线、无线皆可）\n拨号上网 更改 WAN 口为 “PPPOE”，输入宽带账号密码即可。IPv6将会自动分配。\n如图，WAN 口显示的 IP 地址中，如果在 192.168.0.0/16、172.16.0.0/12 或 10.0.0.0/8 中的话，则是“私有地址”，即你运营商的大内网，除此之外分配给你的地址基本都会是“公网IP”。\n连接到光猫设置页面 因为需要用路由器拨号，所以将光猫改为成“桥接模式”，光猫的 IP 地址为 192.168.9.1，因此我无法直接访问光猫的设置界面。\n解决方案是在 WAN 口的设备上新增加一个 IP 在 192.168.9.0/24 子网的接口，通过该接口访问 192.168.9.1。\n新建接口，命名为 “lan_wan” ，协议为“静态IP”，地址为 192.168.9.2 （子网内的任意 IP 地址均可）。设备处选择“以太网适配器eth0”。\n设备名可能会不同，留意一下 wan 口的连接设备即可。IP 地址仅作示范，具体还需要根据网络情况设置。\n添加完成后在“高级设置”中，找到“使用网关跃点”项，填写为 64 （或者任意一个较大的数字）。这样可以避免默认流量从非上网用的接口走。\n网关跃点可以解释为类似于“优先级”的东西，跃点数越大代表“从这个网络走的代价越大”，即效果是优先级低。\n配置完后路由器的路由表中将多出 192.168.9.0/24 via 192.168.9.2 这样类似的条目。以后再使用 192.168.9.1 访问光猫配置页面时候就会从这个口走了。\nArgon 主题设置 没想到吧接下来居然要说这个。\nOpenWRT 官方的主题并谈不上好看，Edge 这个主题我又不是很喜欢。之前用过 Infinity Freedom 这个主题，不过不是特别兼容我的系统，所以只好选择了经典的 Argon 来用。\n在“软件包”中安装插件 luci-app-argon-config ，可以在 luci 中添加一个设置主题的界面。\n然后来到设置界面中上传自己喜欢的壁纸，和更改自己喜欢的主题色。\n我设置了 #F19EC2 作为我的主题色，不会有人不喜欢樱花粉吧？\n首页效果：\n对网段进行限速 有些莫名奇妙的需求，因为我家里所有设备全分配了静态 IP 地址：\n网络设备（路由器等） 192.168.8.1 - 192.168.8.31； Windows 设备（台式笔记本等） 192.168.8.32 - 192.168.8.47； 移动设备（手机） 192.168.8.48 - 192.168.8.63； DHCP地址 192.168.8.64 - 192.168.8.127； 所以在 192.168.8.64 - 192.168.8.127 段的设备基本都是客人之类的——总之不是家里的固定设备，所以想要进行限速。使用的插件如下：\nluci-app-eqos 在插件后台启用，然后填写 IP段 进行限速就可以了。比如我需要限制的是 192.168.8.64/26\n配置 AP OpenWRT 前前后后不知道配置了多少次\u0026hellip;主要问题还是如果弄错了很可能就直接连不上后台了:D\n主要的办法就是把 WAN 和 LAN 全接在一个接口上，WLAN 也接上去就行了，没有像厂家固件那样方便的改一个什么 “有线中继” 那么方便。作为 AP 的话真的很推荐使用原厂固件（但是 MiWiFi 一直在那请求 api.miwifi.com 在后台看 log 看的我实在心烦）\nNAT模式 能上网也是最省心的模式，构建的时候设置好一个不同于上面的 LAN IP 即可（比如 192.168.7.1），WAN 口设置 DHCP地址。\n太不优雅啦（大声\nAP模式 参阅：\n[OpenWrt Wiki] Wireless Access Point / Dumb Access Point 网络 \u0026gt; 接口 \u0026gt; 设备中选择 br-lan 的 “配置”，将接口中加入 wan 口。\n关闭 LAN 口的 DHCP 服务器（我是根本没安装 Dnsmasq ）\n将 WAN 口协议改为 “DHCP客户端” 或 “静态地址”\n如果你的上级路由（比如软路由）配置好了静态地址给这台 AP，就可以用 “DHCP客户端”，管理起来也更方便； 如果静态地址没配好，那就选择“静态地址”并且填写一个同网段的地址（比如 192.168.8.2）； 将 WAN 口的防火墙区域改为 lan\n将无线设置中接口由 lan 改到 wan\n禁用防火墙\n保存确认设置无误后删除 lan 接口（留着也可以，以备万一）\n硬件改造 其实很多精力还花费在对弱电柜内部的改造上\n改3.5硬盘供电 绝大多数工控小主机的 SATA 供电是为2.5寸硬盘设计的，2.5寸硬盘供电和3.5寸硬盘供电的主要区别就是2.5的少了一对 +12v 。所以我们只需要一个 12v 的直流电源，并且接到供电口就可以。\n至于带有 12v 的 SATA 供电口，我手里有一个以前 ITX 用的，实在没有也可以考虑从旧的台式机 ATX 电源上面剪下来一个。\n至于引脚定义详见下图：\n正好接到我前言中说的 12v 开关电源上。\n至于 SATA 线，我依旧是用锉刀挫开了一个槽，把线走了出去，千万注意不要太勉强，不然盖子把线压坏然后短路——后果不堪设想。\n弱电柜里的铁架子 角钢真的是一种非常好的东西，便宜、而且非常容易 DIY，之前我的宿舍床上也是用这种角铁打了一个框架。至于价格的话，淘宝找那种卖二手角铁做货架的定制一下，我记得也就几十块钱。\n只需要量好尺寸，想好放什么，比如我：\n第一层：H3C 交换机 第二层：软路由 第三层：光猫 而且上面密密麻麻的孔洞非常适合绑扎带和走线\n虽然这还不是完全走好了之后的图，不过这么绑起来也很舒服\n具体的各种配置有很多，前前后后也折腾了十天半个月，一些复杂一点的配置我就分开写博客再说（）\n","date":"2022-08-14T00:23:38+08:00","permalink":"https://blog.gaein.cn/passages/home-network/","title":"J1900软路由+小米AC2100 / OpenWRT —— 我的家庭网络方案"},{"content":"前言 最近实在太摸辣！ 前景提要：收了个 小米AC2100 刷了 OpenWrt 系统，那个固件带了一个微信推送，但是我觉得不是特别好用，准备自己弄一个 基于 linux netlink、ASP.NET Core 做后端，使用 MQTT 或者 Google FCM Mi Push 做推送。Luci 用 lua 脚本编写插件，反正也没什么事就来看看 lua 吧！ 为什么叫lua不叫rua\n关于 lua Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\nlua 很轻量、与 C/C++ 交互方便、支持 面向过程 or 函数式 编程。\n环境安装 直接摁包管理器！\nScoop: scoop install lua\n如果包管理器没有就解压扔环境变量呗\n运行方式 脚本运行 lua 脚本是文本文件\nscript:\n1 2 3 #!/usr/local/bin/lua print(\u0026#34;Hello world\u0026#34;) script.lua:\n1 print(\u0026#34;hello world\u0026#34;) 还可以在命令行中输入 lua -i 来使用 lua REPL\n数据类型 lua 语言有如下几种数据类型\nnil: null，未定义的变量为 nil，同样，可以给变量赋值 nil 来“销毁” 它 boolean: true / false，条件表达式中只有 nil 和 false 为否，其余（包括数字 0 皆为是 number: 数字类型，双精度浮点实数，所有的数字都是 number 类型 string: 字符串，使用 \u0026quot; 或 ' 包裹，.. 连接。多行字符串可以使用 [[ 和 ]] 包裹 function: C 或 lua 函数（可以类似于委托来使用） userdata: 用户类型 thread: 用于协程 table: 表，类似于 PHP 中的 “数组”，可以存储数组或键值对之类的 获取类型 在 lua 中，可以使用 type() 函数来获取类型，比如\n1 2 3 4 type(\u0026#34;str\u0026#34;) -- string type(114514) -- number type(unknow) -- nil type(0 \u0026lt; 1) -- boolean 在上述案例中，unknow 未定义，所以输出为 nil\n注意，判断 nil 时候应该加上引号，因为 typeof 的结果是字符串类型：\n1 2 3 if typeof(x) == \u0026#34;nil\u0026#34; then print(\u0026#34;x is null!\u0026#34;) end string 类型 string 就是字符串，很正常的一个字符串。转义字符也都一样。\nstring 初始化 前面说过了，可以用双引号也可以用单引号：\n1 2 3 4 5 6 str = \u0026#34;hello\u0026#34; str = \u0026#39;hello\u0026#39; str = [[ { \u0026#34;message\u0026#34;: \u0026#34;hello\u0026#34; }]] 当然，用 [[ 和 ]] 包裹显示 “多行字符串” 或者 “原字符串”，类似于 C# 中的 @\u0026quot;\u0026quot; 或者 python 中的 r\u0026quot;\u0026quot;。\nstring 相关函数使用 字符串连接：..； 大小写转换：string.upper(str) 和 string.lower(arg)； 替换：string.gsub(str, search, replace, [times])，次数省略为不限次数； 查找：string.find(str, search, [init, [regxp]])，返回两个值：起始位置和结束位置； 反转：string.reverse(str)； 格式化：string.format(...)，格式化规则类似于 printf； 字符与 ASCII 代转换：string.char(nums) 字符串中的字符转 ASCII 码返回，string.byte(str, [index])； 计算长度：string.len(str) 或 #，例如 #str； 重复字符串：string.rep(str, times)，重复 times 次字符串 str； 正则字符串：string.match(str, pregxp, init) 只寻找源字串str中的第一个配对并返回结果，找不到时返回 nil； 你说 number 转 string? 使用数字运算符的时候会自动尝试将 string 转为 number，所以可以写类似于\n1 2 3 4 result = \u0026#34;3\u0026#34; + 5 -- 8 result = 3 + \u0026#34;5\u0026#34; -- 8 result = \u0026#34;3\u0026#34; + \u0026#34;5\u0026#34; -- 8 result = \u0026#34;test\u0026#34; + 5 -- stdin:1: attempt to add a \u0026#39;string\u0026#39; with a \u0026#39;number\u0026#39; 当然，单纯需要转换的话可以使用 tostring() 和 tonumber() 函数。\n更多字符串操作参考 Lua 5.4 官方文档\ntable 类型 这个 table 很神奇，反正类比一下 PHP 的 “数组”，这玩意也是一个 “什么都能塞” 的角\ntable 的初始化 table 使用初始化器 {} 来初始化，如下代码初始化了一个 table:\n1 t = {} 在初始化时候，如果需要指定索引的键，则可以使用 [] 索引器，说起来有点抽象，看看代码：\n1 2 t = {[\u0026#34;k\u0026#34;] = \u0026#34;value\u0026#34;, [\u0026#34;arr\u0026#34;] = { 1, 2, 3, }, [3] = 0, } print(t[\u0026#34;k\u0026#34;]) -- \u0026#34;value\u0026#34; 没错，[]不仅在索引时候用，在创建的时候还可以用来表示键，虽然我不知道这时候他叫什么。不过，为了方便起见，索引 key 为字符串的时候，可以省略掉 [] 而使用 .，比如\n1 print(t.k) 创建的时候也可以省略 []，比如\n1 t = {k = \u0026#34;value\u0026#34;, arr = { 1, 2, 3, }, [3] = 0, } 哦对了，还有一个很生草的事情，在 lua 中，索引是从 1 开始的，这一点也不反人类但是反程序员。\n其他类型不再赘述\ntable 相关函数使用 连接各元素：table.concat(table, [sep , [start ,[end]]])，实际上有些像 string.Join 的功能，将各元素连接起来； 插入元素：table.insert(table, [pos] ,value)，在 pos 位置插入 value，省略默认为尾部插入； 删除元素：table.remove (table, [pos]) 删除 pos 位置的值，并返回，省略默认为尾部删除； 排序：table.sort (table, [comp]) 默认为升序排序； 或许大概没准是由于 table 存的东西奇奇怪怪，Lua 并没有提供计算长度的函数，用 # 运算符也会有问题，那就手搓遍历罢（悲\nfunction 类型 函数作为一个基础类型出现在这里，可以类比委托或者类似于 js 的 function 那样，既可以调用也可以作为一个变量/参数传递。\n首先是函数定义：\n1 2 3 function writeLine(arg) print(arg..\u0026#34;\\n\u0026#34;) end 需要局部函数可以在 function 前面加修饰符 local，返回值可以有多个。\n可变参数 function：\n1 2 3 4 5 6 7 8 function printf(...) local arg={...} if #arg == 1 then -- 或用 select(\u0026#34;#\u0026#34;,...) 获取参数数量 print(arg) else print(string.format(arg)) end end 将函数赋值给变量：\n1 2 3 4 5 func = function(a) print(a) end func(114514) 基础用法大概差不多这样，其它类型留到以后再说或者不再赘述。\n运算符 算术运算符 除了常规的 + - * / % 之外，还有 ^（幂）和 //（整除）\n关系运算符 常规的 == \u0026lt;= \u0026gt;= \u0026lt; \u0026gt; 之外，不等于用 ~=\n逻辑运算符 不是 || 这些符号，而是类似于 python，用 and or not\n其他运算符 一个是计算长度用的 #，一个是连接字符串的 ..（其实这大概也算是算术运算符？）\n流程控制 流程控制嘛其实说白了就是 if-else，具体使用代码如下所示：\n1 2 3 4 5 if type(x) == \u0026#34;nil\u0026#34; then print(\u0026#34;x is null\u0026#34;) else print(\u0026#34;x not null\u0026#34;) end 有些类似于 SQL 中的判断嘛\nLua 的 if-else 可以嵌套使用 废话\n循环 while 循环 如下所示\n1 2 3 4 while(true) do refresh() end for 循环 1 2 3 for i=0,100,1 do print(i) end 说说这个 for 吧，for 后面是 var=exp1,exp2,exp3 其中表达式1是初始值，表达式2是终止值，表达式3为步长，比如我要输出 100 以内 可以被 3 整除的数，可以这么写：\n1 2 3 for i=3,100,3 do print(i) end 另外很重要一个用途就是遍历 table 之类的，这玩意叫“泛型 for 循环”，实际上很类似于 foreach：\n1 2 3 4 studentList = {\u0026#34;Wang\u0026#34;, \u0026#34;Li\u0026#34;, \u0026#34;Zhang\u0026#34;} for i, name in ipairs(studentList) do print(i, name) end 至于这个 ipairs() 函数，是 Lua 的一个迭代器，后续细说怎么个回事。\nrepeat\u0026hellip;until（类似 do-while 循环） 1 2 3 repeat refersh() until(stop == true) 很类似 do-while 的一个玩意\n果然各种语言里面最花的都是 for 嘛 pythone: 喵喵喵？？\n变量 标识符的规则和关键字不再赘述了，各家都大同小异的\n另外就是 Lua 有全局变量和局部变量，默认的变量是全局变量，用 local 关键字修饰后才是局部变量，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function homo() var1 = 114514 var2 = 1919810 end function test() var1 = 9 local var2 = 10 homo() print(var1) print(var2) end test() 写的有点乱反正就是这么回事（摆烂\n","date":"2022-07-26T12:25:44+08:00","permalink":"https://blog.gaein.cn/passages/lua-note1-basic/","title":"lua语言编程基础 - lua笔记"},{"content":"首先恭祝大家新春快乐！\n前言 事情的起因是这样的，我 surface 上装了一张 TF 卡作为存储盘，年头重装家里系统的时候莫名其妙格式化了 TF 卡（选错了盘的屑）。想到很多环境都在 TF 卡里，surface 这个系统也用了一年半了，索性就重装然后再配环境。\n有很多类似于 git 这种命令行软件，需要在环境变量的 PATH 中加入它的目录（比如 D:\\Tools\\Git\\cmd\\）才能方便的执行。如果每个软件都这样的话，PATH 中势必会有一大坨，很混乱也难于管理。\n类 Unix 系统中部分软件的做法是，把这些文件软链接到 /usr/bin/ 目录下。那么我们是否可以在 Windows 系统中采取类似的方法，创建一个目录并添加到 PATH 中，然后将原本需要加入 PATH 的可执行文件软链接到该目录。\n另外，这样做以后再加入别的文件时，只需要创建软链接，不需要更改环境变量也不需要重启 Terminal 了。\n.cmd 不可行 一开始我尝试使用类似于 git.cmd 然后里面写入 D:\\Tools\\Git\\cmd\\git.exe 这种方法，但是显然，我无法传递未知数量的参数给真正的 git.exe （我没有深入研究传递参数的相关知识，显然这不是一个优雅的方法）。\nmklink 创建软链接 Powershell 中没有提供 mklink 对应的 Cmdlet 别名，也就是说当你无法在 Powershell 中使用 mklink 命令。你需要使用 cmd.exe 来执行这个命令。\n关于 Powershell 创建软链接，请参考下文的 New-Item 。\n参阅 mklink | Microsoft Docs\n创建文件的软链接 使用\n1 mklink \u0026lt;link\u0026gt; \u0026lt;target\u0026gt; 其中，link 是创建的链接，target 是被创建链接的文件，比如：\n1 mklink git.exe D:\\Tools\\Git\\cmd\\git.exe 在当前目录下创建了一个 git.exe 指向了在 D 盘的 git.exe 文件。\n创建目录的软链接 不同于 Linux 操作系统，Windows 操作系统创建指向目录的软链接需要额外添加参数，使用\n1 mklink /d \u0026lt;link\u0026gt; \u0026lt;target\u0026gt; New-tem 创建软链接 既然有新的，更加好用的 Powershell ，那么当然要用 Powershell 啦。\n如上文所说，Powershell 并没有设置别名为 mklink 的命令，创建软链接这一行为被 Powershell 视为创建一个类型为 SymbolicLink 的值为 目标文件路径 的新文件\n因此，我们只需要使用 New-Item 即可，使用方法如下：\n1 New-Item \u0026lt;link\u0026gt; -ItemType SymbolicLink -Value \u0026lt;target\u0026gt; 使用 New-Item 创建目录无需添加额外的参数。\n参阅 New-Item (Microsoft.PowerShell.Management) - PowerShell | Microsoft Docs\n注意：Windows 无法在 TF 卡上创建软链接文件，但是你可以将文件链接到 TF 卡上的文件。\n","date":"2022-02-01T23:21:28+08:00","permalink":"https://blog.gaein.cn/passages/manage-windows-path-in-unix-way/","title":"以类Unix的方法管理Windows的Path环境变量"},{"content":"准备工作 一台有 静态公网 IP 的服务器，装有 Ubuntu 20.04 LTS 以及 ZeroTier-one 。\nUbuntu 安装 ZeroTier-one 详见 Download - ZeroTier\n创建网络 在 ZeroTier Central 中创建一个网路并设置为 private。\n配置服务器 参考 Private Root Servers | ZeroTier Documentation\n创建 world 定义 转到目录 /var/lib/zerotier-one\n1 cd /var/lib/zerotier-one 生成 moon.json\n1 zerotier-idtool initmoon identity.public \u0026gt;\u0026gt;moon.json 此文件包含机密信息，请妥善保管\n修改 moon.json\n1 vim moon.json 在 roots 中的第一个子节点的 stableEndpoints 节点中填入 \u0026lt;你的服务器IP\u0026gt;/\u0026lt;ZeroTier端口\u0026gt; 如下：\n1 \u0026#34;stableEndpoints\u0026#34;: [ \u0026#34;1.2.3.4/9993\u0026#34; ] 签发 moon 签发 000000deadbeef00.moon\n1 zerotier-idtool genmoon moon.json 此文件不包含机密信息，但是它从包含有机密信息的 moon.json 签发而来。\n启用端口 开启 Ubuntu 防火墙的 9993 端口：\n1 ufw allow 9993 服务商控制面板如有防火墙请放行 9993 端口。\n配置客户端 转到 ZeroTier 目录\nWindows: C:\\ProgramData\\ZeroTier\\One Macintosh: /Library/Application Support/ZeroTier/One Linux: /var/lib/zerotier-one FreeBSD/OpenBSD: /var/db/zerotier-one 在 ZeroTier 目录下创建文件夹 moons.d\n将服务端生成的 .moon 文件复制到 moons.d 文件夹中并重启 ZeroTier\n","date":"2021-10-07T17:07:35+08:00","permalink":"https://blog.gaein.cn/passages/configure-zerotier-moon/","title":"配置 ZeroTier 私人节点"},{"content":" 本来就想顺便玩玩结果用了4部手机了.jpg\n设备：红米4X(santoni)\n系统：MIUI开发版 9.10.11 架构：ARM64\n咕咕咕中，问题真的好多啊\n准备工作 另请参阅：Install LineageOS on santoni | LineageOS Wiki\n安装ADB和FastBoot 从 Google 下载Windows版的压缩包； 解压缩下载的压缩包到你习惯的文件夹（比如 C:\\Users\\YourName\\Tools\\PlatformTools\\）； 将解压缩的文件夹添加到系统 Path 环境变量。 解锁 bootloader 在 设置\u0026gt;我的设备\u0026gt;全部参数 中点击3次MIUI版本，再点击3次MIUI版本，开启开发者模式； 下载 小米解锁工具，确保账号有权限解锁； 在 设置\u0026gt;更多设置\u0026gt;开发者选项\u0026gt;设备解锁状态 中，插入SIM卡并绑定账号。具体步骤可以参考小米社区； 在 设置\u0026gt;更多设置\u0026gt;开发者选项\u0026gt;USB调试 中启用USB调试。 下载 小米刷机工具 ，不用下载任何包，在 fastboot 下解压运行后按提示安装驱动，然后这玩意就没用了； 似乎只有在 fastboot 模式下用小米来装驱动才行，此前不知道怎么回事一直没驱动。\n在电脑终端内输入 adb shell reboot -p ，手机弹窗允许调试点击“确定”，手机关机； 关机状态下，按住 音量- 再按 电源键 ，开机进入 fastboot； 运行小米解锁工具，登录账户并确认解锁。 刷入第三方 Recovery 这里选择使用 PitchBlack Recovery 因为好看\n另请参阅：How to Install - PitchBlack Recovery Project\n准备 确保你的设备已经解锁； 确保PC端有 adb 和 fastboot； 从 PitchBlack Recovery 下载适用于红米4X的 Recovery； 从 TeamWin Recovery 翻到“Download Links:” 处，下载适用于红米4X的 Recovery。（我这边是欧洲的镜像比较快，自行选择） 从TWRP刷入PBRP 因为以前是小米的 Recovery ，直接安装 PitchBlack 没有搞太明白，所以先刷入 TWRP。\n到下载TWEP的目录，在PC终端执行 fastboot boot twrp-\u0026lt;version\u0026gt;-santoni.img ，从TWRP中启动； 在手机进入TWRP后，点击 Wipe\u0026gt;Format Data 并输入 yes 后执行； 点击 Back 返回到主界面，点击 Advanced\u0026gt;ADB Sideload 启动 ADB 旁加载； 到下载PBRP的目录，从PC终端执行 adb sideload .\\PBRP-santoni-\u0026lt;version\u0026gt;-OFFICIAL.zip ； 手机终端出现 ---Installation finished!--- 字样即为刷入完成； 按下 音量- 重启至 PitchBlack Recovery。 编译 LineageOS 另请参阅：Build for santoni | LineageOS Wiki\n准备工作 准备一台装有 64位的 Ubuntu 20.04 （或Ubuntu Server 20.04）的电脑，可以考虑使用虚拟机或云服务器，为了避免麻烦，建议使用Ubuntu Server完成。编译的时间取决于性能。LineageOS官方的要求是200G存储空间，并且内存越小编译越慢。\n为了速度我就直接拿服务器编译了。\nDELL PowerEdge R620\nIntel® Xeon® Processor E5-2670 v2 X2\nMT DDR3 REG-ECC PC8500R 16GB X4\nHGST 600GB 15K SAS X3 (Raid5)\nUbuntu server 20.04.02\nUbuntu 发行版的光盘可以从 清华大学开源软件镜像站 下载。\n安装服务器过程略过，由于我在tty下使用所以语言选择了英语。\n建议在安装时候配置国内源，比如清华源（https://mirrors.tuna.tsinghua.edu.cn/ubuntu/）。\n环境配置 通过SSH连接上服务器之后就可以进一步进行环境的配置了（当然你在tty内配置也不是不行）。\n安装platform Tools 【可能需要代理】使用 wget 下载 Linux 版的 platform Tools: wget https://dl.google.com/android/repository/platform-tools-latest-linux.zip； 使用 apt 安装 zip: apt install zip； 解压缩 platform Tools :unzip platform-tools_\u0026lt;version\u0026gt;-linux.zip； 编辑 ~/.profile，添加: 1 2 3 4 # add Android SDK platform tools to path if [ -d \u0026#34;$HOME/platform-tools\u0026#34; ] ; then PATH=\u0026#34;$HOME/platform-tools:$PATH\u0026#34; fi 添加完成后运行 source ~/.profile 更新环境。 安装依赖 使用 apt 安装依赖: apt install zip bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev； 对于 Ubuntu 20.04 以前的操作系统来说，还需要安装 libwxgtk3.0-dev: apt install libwxgtk3.0-dev\n如果希望构建 lineageOS 15，则需要安装OpenJDK8: apt install openjdk-8-jdk 创建目录 mkdir -p ~/bin； mkdir -p ~/android/lineage。 安装repo命令 下载repo: curl https://storage.googleapis.com/git-repo-downloads/repo \u0026gt; ~/bin/repo； 更改权限: chmod a+x ~/bin/repo； 将 ~/bin 添加到环境变量，在 ~/.profile 中添加: 1 2 3 4 # set PATH so it includes user\u0026#39;s private bin if it exists if [ -d \u0026#34;$HOME/bin\u0026#34; ] ; then PATH=\u0026#34;$HOME/bin:$PATH\u0026#34; fi 运行 source ~/.profile 更新环境。 配置Git 使用 apt install git 安装 Git； 配置你的邮箱和用户名： 1 2 git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; 开启缓存 开启缓存可以加快构建\n设置环境变量 1 2 export USE_CCACHE=1 export CCACHE_EXEC=/usr/bin/ccache 设置ccache，编辑~/.profile，加入: 1 ccache -M 32G 使用source ~/.profile 使配置生效 配置LineageOS仓库 红米4X可以选择如下两个分支：\nlineage-15.1(需要OpenJDK-8) lineage-16.0 进入目录: cd ~/android/lineage； 安装python（由于Ubuntu自带python，安装 python-is-python3）即可； 【可能需要代理】初始化项目: repo init -u https://github.com/LineageOS/android.git -b lineage-\u0026lt;version\u0026gt; 如果无法下载可以考虑添加环境变量 REPO_URL=https://github.com/GerritCodeReview/git-repo；\n【可能需要代理】使用 repo sync 下载源代码； 这步好艰难\u0026hellip;要下很长时间\n配置设备相关 输入\n1 2 source build/envsetup.sh breakfast santoni 下载红米4X(santoni)的配置文件和内核。\n部分机型需要一个vendor目录。如果你收到了一个关于vendor的错误，到 GitLab 下载。放入 ~/android/lineageos/vendor/xiaomi 后，再次执行 breakfast santoni 即可。 经尝试上述方法在后来引起了错误，所以参考官方文档，从LineageOS的包里导出该文件，首先下载 LineageOS 16.0 for santoni （这个包的来历我也不知道，应该是以前镜像的官方build），使用 unzip path/to/lineage-*.zip system/* 解压，并将 system 目录移动到 ~/android/system_dump/，到 ~/android/lineage/device/xiaomi/santoni 目录执行 ./extract-files.sh ~/android/system_dump/ 导出。\n编译LineageOS 执行\n1 2 croot brunch santoni 报错\n1 ninja: error: \u0026#39;/home/nidb/android/lineageos/out/target/common/obj/JAVA_LIBRARIES/WfdCommon_intermediates/javalib.jar\u0026#39;, needed by \u0026#39;/home/nidb/android/lineageos/out/target/product/santoni/dex_bootjars/system/framework/boot.prof\u0026#39;, missing and no known rule to make it 很是绝望。参考 StackOverflow 发现或许是缺了 Wfd，在Github找到这个仓库 ，克隆该项目替换，没有作用。\n考虑使用 make 直接编译，因为脚本中含有 python2，所以卸载 python-is-python3 ，然后 apt install python2；\n尝试使用 lunch ,make -j10 。\n报错 ninja: error: 'prebuilts/lineage-sdk/api/9.txt'，参考 XDA 克隆 https://github.com/LineageOS/android_prebuilts_lineage-sdk 到 prebuilts 解决。\n编译到一大半报错 ninja: build stopped: subcommand failed. 原因是被Linux系统限制，使用 ulimit -c unlimited 解除。\n","date":"2021-10-04T18:43:15+08:00","permalink":"https://blog.gaein.cn/passages/lineageos-on-redmi-4x/","title":"【弃坑】在红米4X上安装LineageOS"},{"content":"题干 力扣-太平洋大西洋水流问题\n给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。\n规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。\n请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。\n提示：\n输出坐标的顺序不重要\nm 和 n 都小于150\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 给定下面的 5x5 矩阵: 太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * 大西洋 返回: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). 深度优先搜索 思路 找出太平洋和大西洋都能抵达的点即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public IList\u0026lt;IList\u0026lt;int\u0026gt;\u0026gt; PacificAtlantic(int[][] heights) { var res = new List\u0026lt;IList\u0026lt;int\u0026gt;\u0026gt;(); var m = heights.Length; var n = heights[0].Length; // 记录坐标地是否到达太平洋、大西洋 var canReachP = new bool[m, n]; var canReachX = new bool[m, n]; // 上下左右出发，深度优先搜索 for (int i = 0; i \u0026lt; m; i++) { DepthFirstSearch(heights, canReachP, i, 0); DepthFirstSearch(heights, canReachX, i, n - 1); } for (int j = 0; j \u0026lt; n; j++) { DepthFirstSearch(heights, canReachP, 0, j); DepthFirstSearch(heights, canReachX, m - 1, j); } // 遍历记录，如果都可到达即可加入结果 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (canReachP[i, j] \u0026amp;\u0026amp; canReachX[i, j]) { res.Add(new int[] { i, j }); } } } return res; } public void DepthFirstSearch(int[][] heights, bool[,] canReach, int i, int j) { // 如果已经扫描过可达就不用扫描 if (canReach[i, j]) return; // 扫描过即说明可达，这也是逆流的优点 canReach[i, j] = true; // 上下左右深度搜索，越界就不搜索 if (i - 1 \u0026gt;= 0 \u0026amp;\u0026amp; heights[i - 1][j] \u0026gt;= heights[i][j]) { DepthFirstSearch(heights, canReach, i - 1, j); } if (j - 1 \u0026gt;= 0 \u0026amp;\u0026amp; heights[i][j - 1] \u0026gt;= heights[i][j]) { DepthFirstSearch(heights, canReach, i, j - 1); } if (i + 1 \u0026lt; heights.Length \u0026amp;\u0026amp; heights[i + 1][j] \u0026gt;= heights[i][j]) { DepthFirstSearch(heights, canReach, i + 1, j); } if (j + 1 \u0026lt; heights[0].Length \u0026amp;\u0026amp; heights[i][j + 1] \u0026gt;= heights[i][j]) { DepthFirstSearch(heights, canReach, i, j + 1); } } ","date":"2021-09-17T20:47:22+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-417-pacificatlanticwaterflow/","title":"太平洋大西洋水流问题-力扣417 深都优先搜索"},{"content":"题干 力扣-最大正方形\n题干详见 LeetCode ，图片过多不在此赘述。\n暴力 思路 暴力算嘛，计算每一个最大的正方形的边长并存储，遍历一轮。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public int MaximalSquare(char[][] matrix) { var maxSide = 0; // 判空 if (matrix is null || matrix.Length == 0 || matrix[0].Length == 0) return 0; var rows = matrix.Length; var columns = matrix[0].Length; for (var i = 0; i \u0026lt; rows; i++) { for (var j = 0; j \u0026lt; columns; j++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { // 遇到一个 1 作为正方形的左上角 maxSide = maxSide \u0026gt; 1 ? maxSide : 1; // 计算可能的最大正方形边长 var currentMaxSide = rows - i \u0026gt; columns - j ? columns - j : rows - i; for (var k = 1; k \u0026lt; currentMaxSide; k++) { // 判断新增的一行一列是否均为 1 var flag = true; if (matrix[i + k][j + k] == \u0026#39;0\u0026#39;) break; for (var m = 0; m \u0026lt; k; m++) { if (matrix[i + k][j + m] == \u0026#39;0\u0026#39; || matrix[i + m][j + k] == \u0026#39;0\u0026#39;) { flag = false; break; } } if (flag) { maxSide = maxSide \u0026gt; k + 1 ? maxSide : k + 1; } else { break; } } } } } return maxSide * maxSide; } ","date":"2021-09-17T18:50:22+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-221-maximalsquare/","title":"二叉树的中序遍历-力扣94 中序遍历"},{"content":" 把罗马数字转成 int ，遍历字符串进行计算即可。\n题干 [罗马数字转整数]\n罗马数字包含以下七种字符: I，V，X，L，C，D 和 M。\n1 2 3 4 5 6 7 8 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n示例 1:\n1 2 输入: \u0026#34;III\u0026#34; 输出: 3 示例 2:\n1 2 输入: \u0026#34;IV\u0026#34; 输出: 4 示例 3:\n1 2 输入: \u0026#34;IX\u0026#34; 输出: 9 示例 4:\n1 2 3 输入: \u0026#34;LVIII\u0026#34; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5:\n1 2 3 输入: \u0026#34;MCMXCIV\u0026#34; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示：\n1 \u0026lt;= s.length \u0026lt;= 15 s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M') 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 自己想的慢速解法 思路 罗马数字每个数字由一到两个字符构成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [ { \u0026#34;I\u0026#34;: 1 }, { \u0026#34;V\u0026#34;: 5 }, { \u0026#34;X\u0026#34;: 10 }, { \u0026#34;L\u0026#34;: 50 }, { \u0026#34;C\u0026#34;: 100 }, { \u0026#34;D\u0026#34;: 500 }, { \u0026#34;M\u0026#34;: 1000 }, { \u0026#34;IV\u0026#34;: 4 }, { \u0026#34;IX\u0026#34;: 9 }, { \u0026#34;XL\u0026#34;: 40 }, { \u0026#34;XC\u0026#34;: 90 }, { \u0026#34;CD\u0026#34;: 400 }, { \u0026#34;CM\u0026#34;: 900 } ] 首先遍历读取字符串的每个字符，遇到 I, X, C 即为有可能和下一个字符组成一个罗马数字。\n维护一个字典，存储所有的单个罗马数字 ( IX, C 这种) ，对字符串进行遍历，遇到可能有下一个字母组成罗马数字的就检查下一个是否越界，如果没有越界就查询字典，字典有就加上相应的数值并且 i += 2 ，没有就查询当前字符，获取数值并加到 result 里，然后 i++。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public class Solution { private static bool MayHasNext(char ch) =\u0026gt; (ch) switch { \u0026#39;I\u0026#39; =\u0026gt; true, \u0026#39;X\u0026#39; =\u0026gt; true, \u0026#39;C\u0026#39; =\u0026gt; true, _ =\u0026gt; false, }; public static bool TryParse(char ch, out int num) =\u0026gt; TryParse(ch.ToString(), out num); public static bool TryParse(char ch1, char ch2, out int num) =\u0026gt; TryParse($\u0026#34;{ch1}{ch2}\u0026#34;, out num); public static bool TryParse(string s, out int num) =\u0026gt; (num = s switch { \u0026#34;I\u0026#34; =\u0026gt; 1, \u0026#34;V\u0026#34; =\u0026gt; 5, \u0026#34;X\u0026#34; =\u0026gt; 10, \u0026#34;L\u0026#34; =\u0026gt; 50, \u0026#34;C\u0026#34; =\u0026gt; 100, \u0026#34;D\u0026#34; =\u0026gt; 500, \u0026#34;M\u0026#34; =\u0026gt; 1000, \u0026#34;IV\u0026#34; =\u0026gt; 4, \u0026#34;IX\u0026#34; =\u0026gt; 9, \u0026#34;XL\u0026#34; =\u0026gt; 40, \u0026#34;XC\u0026#34; =\u0026gt; 90, \u0026#34;CD\u0026#34; =\u0026gt; 400, \u0026#34;CM\u0026#34; =\u0026gt; 900, _ =\u0026gt; -1, }) != -1; public int RomanToInt(string s) { if (s is null) throw new ArgumentNullException(nameof(s)); if (s == string.Empty) return 0; var result = 0; var i = 0; while (i \u0026lt; s.Length) { var ch = s[i]; if (MayHasNext(ch) \u0026amp;\u0026amp; i \u0026lt; s.Length - 1) { if (TryParse(ch, s[i + 1], out var numOfTwo)) { result += numOfTwo; i += 2; continue; } } if (TryParse(ch, out var num)) result += num; i++; } return result; } } 大佬的高速解法 思路 罗马数字的规则，用一句话来说就是：“把一个小值放在大值的左边，就是做减法，否则为加法”。也就是我们可以维护一个变量来存储上一个数字，然后比大小进行加减法。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public int RomanToInt(string s) { var strSpan = s.AsSpan(); var result = 0; var lastNum = GetRomanCharValue(strSpan[0]); foreach(var ch in strSpan[1..]) { var num = GetRomanCharValue(ch); if (lastNum \u0026lt; num) { result -= lastNum; } else { result += lastNum; } lastNum = num; } return result + lastNum; } private static int GetRomanCharValue(char ch) =\u0026gt; ch switch { \u0026#39;I\u0026#39; =\u0026gt; 1, \u0026#39;V\u0026#39; =\u0026gt; 5, \u0026#39;X\u0026#39; =\u0026gt; 10, \u0026#39;L\u0026#39; =\u0026gt; 50, \u0026#39;C\u0026#39; =\u0026gt; 100, \u0026#39;D\u0026#39; =\u0026gt; 500, \u0026#39;M\u0026#39; =\u0026gt; 1000, _ =\u0026gt; throw new ArgumentException($\u0026#34;Unknow roman char {ch}\u0026#34;), }; ","date":"2021-09-16T13:52:23+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-13-romantointeger/","title":"罗马数字转整数-力扣13 遍历吧"},{"content":"题干 [力扣-二叉树的中序遍历]\n题干详见 LeetCode ，图片过多不在此赘述。\n递归 思路 首先分析题干，迷惑了我半天的示例原来是这个类：\n1 2 3 4 5 6 7 8 9 10 public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val = 0 , TreeNode left = null, TreeNode right = null) { this.val = val; this.left = left; this.right = right; } } 不得不说这代码弄得我是\u0026hellip;血压升高又没得办法\n1 2 3 4 5 6 7 8 9 public int Val { get; set;} public TreeNode Left { get; set;} public TreeNode Right { get; set;} public TreeNode(int val = 0 , TreeNode left = null, TreeNode right = null) { Val = val; Left = left; Right = right; } 另外这种构造函数似乎没有必要写，因为可以使用类似于：\n1 2 3 4 5 var node = new TreeNode() { Val = 5, Left = chileLeft, }; 这种代码来完成。一般情况下用构造函数是属性不可为空的情况下。\n跑题了（）\n首先啥是二叉树，这玩意离散数学应该讲过，但是我没听（x） 二叉树是一个树形结构，每个节点有两个子节点。中序遍历就是先遍历左面的，再来他本身然后是右面的。递归的话不深究他的细节，写就完了。\n首先来个判空避免 NullReferenceException ，对于递归来说我们只需要负责好其中的环节就好了，至于细节千万不要深究，比较脑瓜子没几层栈，想了没两下就 StackOverflow 了。\n那么在这个方法中，先添加左，再添加他本身，然后右节点，返回即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public IList\u0026lt;int\u0026gt; InorderTraversal(TreeNode root) { if (root is null) return new List\u0026lt;int\u0026gt;(); var result = new List\u0026lt;int\u0026gt;(); // 实际上不需要判空 // 递归左 result.AddRange(InorderTraversal(root.left)); result.Add(root.val); // 递归右 result.AddRange(InorderTraversal(root.right)); return result; } ","date":"2021-09-15T22:22:13+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-94-binarytreeinordertraversal/","title":"二叉树的中序遍历-力扣94 中序遍历"},{"content":" 嗯是爬楼梯，刚看题没有什么思路，举几个栗子来看看规律，找到规律后使用规律来阶梯。\n题干 [力扣-爬楼梯]\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意： 给定 n 是一个正整数。\n示例 1：\n1 2 3 4 5 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2：\n1 2 3 4 5 6 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 动态规划 思路 观察结果：\nn=1 时，1 种； n=2 时，2 种； n=3 时，3 种； n=4 时，5 种； \u0026hellip;\n不难发现，第 n 次的结果是 n-1 次与 n-2 次之和。\n当然你写递归也行，但是那样总是有很多重复计算，不如来动态规划，存储之前算过的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int ClimbStairs(int n) { var table = new int[n - 1]; // 创建表 if (n \u0026lt;= 3) return n; // i \u0026lt;= 3时，返回相应结果即可 // 初始化表 table[1] = 2; table[2] = 3; // 计算前两次的值并存储 for (int i = 3; i \u0026lt; n - 1; i++) { table[i] = table[i - 1] + table[i - 2]; } return table[n - 2] + table[n - 3]; } } 排列组合脑瘫算法 思路 来举例子吧：\nn=1 时，1 种：\n1 1 n=2 时，1+1 种：\n1 2 2 1 1 n=3 时，2+1 种：\n1 2 2 1 // C(2,1) 1 1 1 n=4 时，1+3+1 种：\n1 2 3 2 2 2 1 1 // C(3,1) 1 1 1 1 n=5 时，`` 种：\n1 2 3 2 2 1 // C(3,2) 2 1 1 1 // C(4,1) 1 1 1 1 1 好，找到规律了：\n判断奇数还是偶数，是奇数 result + 1，是偶数 result + 2； y = (x - 1) / 2； i 循环 y 次，result + C(x - i, i)， i++ 超时，然后优化计算组合数部分，使用 HashSet\u0026lt;T\u0026gt; 来存储分子然后相消。\n总之想这个挺有趣的呢。\n最终代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 public class Solution { public static void Main() { var t = new Solution(); Console.WriteLine(t.ClimbStairs(44)); } public int ClimbStairs(int n) { var result = IsEven(n) ? 2 : 1; // 奇数偶数预先加值 var cnt = (n - 1) \u0026gt;\u0026gt; 1; // 循环组合次数 for (var i = 1; i \u0026lt;= cnt; i++) result += Combine(i, n - i); // 计算组合值 return result; } /// \u0026lt;summary\u0026gt; /// 是否为奇数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;num\u0026#34;\u0026gt;数字\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;是否为奇数\u0026lt;/returns\u0026gt; private static bool IsEven(int num) =\u0026gt; (num \u0026amp; 1) == 0; /// \u0026lt;summary\u0026gt; /// 是否为奇数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;num\u0026#34;\u0026gt;数字\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;是否为奇数\u0026lt;/returns\u0026gt; private static bool IsEven(long num) =\u0026gt; (num \u0026amp; 1) == 0; /// \u0026lt;summary\u0026gt; /// 计算阶乘 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;阶数\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;x!\u0026lt;/returns\u0026gt; private long Factorial(long x) =\u0026gt; x \u0026lt;= 1 ? 1 : x * Factorial(x - 1); /// \u0026lt;summary\u0026gt; /// 组合 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;m\u0026#34;\u0026gt;取出元素的个数\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;元素总个数\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private int Combine(int m, int n) { // 分子值 long moleculeValue = 1; long denominatorValue; // 分子的集合 var moleculesList = new HashSet\u0026lt;int\u0026gt;(); for (var i = 1; i \u0026lt;= n; i++) { moleculesList.Add(i); } // 分母的集合 var denominatorsList = new LinkedList\u0026lt;int\u0026gt;(); // 选取较少的一项进行计算 int denominatorCnt; var o = n - m; // 分母值 if (o \u0026gt; m) { denominatorValue = Factorial(m); denominatorCnt = o; } else { denominatorValue = Factorial(o); denominatorCnt = m; } // 进行分子分母相消 for (var i = 1; i \u0026lt;= denominatorCnt; i++) { if (moleculesList.Contains(i)) { moleculesList.Remove(i); } else { denominatorsList.AddLast(i); } } // 计算分母值 foreach (var val in denominatorsList) { denominatorValue *= val; } // 计算分子值 foreach (var val in moleculesList) { if (IsEven(val) \u0026amp;\u0026amp; IsEven(denominatorValue)) { denominatorValue \u0026gt;\u0026gt;= 1; moleculeValue *= (val \u0026gt;\u0026gt; 1); } else { moleculeValue *= val; } } return (int)(moleculeValue / denominatorValue); } } ","date":"2021-09-14T21:24:43+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-70-climbingstairs/","title":"爬楼梯-力扣70 动态规划"},{"content":"版权声明 \u0026ldquo;Command Line Parser for C# | DC Coding\u0026rdquo; by Dan Carter, ‎translate from original.\n本文翻译自 Dan Carter 的 \u0026ldquo;Command Line Parser for C# | DC Coding\u0026quot;。\nAnther\u0026rsquo;s permission: 原作者许可： 我最近正在折腾 Command Line Parser。这是一个处理、解析命令行参数和选项的样板代码 C# 库（可以用 NuGet 来安装）\n它使用常见的约定来确定选项的处理方式（类似于 C 的 getopt 函数）。\n它的 GitHub page 上有很完善的文档，但是我仍然决定在这里分享一下怎么用。\n简单选项 假设我们现在正在创建一个用户获取文件属性（大小、文件类型等）的程序，希望支持以下命令行选项：\n\u0026lt;文件路径\u0026gt; (必须) -d 或 --detailed （如果存在这个参数则输出所有能获取到的文件属性，否则则输出最常用的信息） -o \u0026lt;文件路径\u0026gt; 或 --output \u0026lt;文件路径\u0026gt; （指定文件属性输出的位置） 然后我们可以创建一个包括可能的命令行选项的属性类 Options ，使用特性来修饰期望的具体的用法：\n1 2 3 4 5 6 7 8 9 10 11 class Options { [Value(0)] public string FilePath { get; set; } [Option(\u0026#39;d\u0026#39;, \u0026#34;detailed\u0026#34;)] public bool Detailed { get; set; } [Option(\u0026#39;o\u0026#39;, \u0026#34;output\u0026#34;)] public string Output { get; set; } } Value 特性定义了按位置识别的参数，Option 特性定义了按名字识别的参数。\n然后在主函数中轻轻松松的像下面这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Program { static void Main(string[] args) { CommandLine.Parser.Default.ParseArguments\u0026lt;Options\u0026gt;(args) .WithParsed\u0026lt;Options\u0026gt;(o =\u0026gt; { // 解析成功，继续运行app }) .WithNotParsed\u0026lt;Options\u0026gt;(e =\u0026gt; { // 解析错误，处理错误 }); } } Options 类的实例 o 将会被用解析的选项填充，你可以使用它来控制你应用程序的行为。\n动词 这个库也支持类似于“动词”的玩意，比如 Git（一种版本控制软件）有很多你可以执行的特殊的动作（git clone，git commit，git pull 等），分别有它们自己的选项\n在 Command Line Parser 中，你可以为每个动词创建选项类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Verb(\u0026#34;clone\u0026#34;)] class CloneOptions { // ... } [Verb(\u0026#34;commit\u0026#34;)] class CommitOptions { // ... } [Verb(\u0026#34;pull\u0026#34;)] class PullOptions { // ... } 然后在你的主函数中定义你要对每个动词干什么以及如何处理错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Program { static int Main(string[] args) { return CommandLine.Parser.Default.ParseArguments\u0026lt;AddOptions, CommitOptions, CloneOptions\u0026gt;(args) .MapResult( (CloneOptions o) =\u0026gt; { // clone }, (CommitOptions o) =\u0026gt; { // commit }, (PullOptions o) =\u0026gt; { // pull }, e =\u0026gt; 1); } } 自定义 上面给出 例子使用了 CommandLine.Parser.Default （默认解析方案），但实际上有很多方法来自定义解析。例如，你可以设置要解析的参数的区域性，或者设置解析时是否区分大小写。\n帮助文本 Command Line Parser 中一个很棒的功能是它可以为你的应用程序生成帮助文本。你需要做的只有在特性中添加 HelpText 属性，然后传递 --help 参数的某人就会获取到帮助文本。\n例如，之前我们的 Options 类可以更改为：\n1 2 3 4 5 6 7 8 9 10 11 class Options { [Value(0, HelpText = \u0026#34;The file to display information for.\u0026#34;)] public string FilePath { get; set; } [Option(\u0026#39;d\u0026#39;, \u0026#34;detailed\u0026#34;, HelpText = \u0026#34;Whether to output detailed information about the file.\u0026#34;)] public bool Detailed { get; set; } [Option(\u0026#39;o\u0026#39;, \u0026#34;output\u0026#34;, HelpText = \u0026#34;If specified, a file to output the results to.\u0026#34;)] public string Output { get; set; } } 然后使用 --help 参数运行应用程序，将会有以下输出：\n1 2 3 4 5 6 7 8 9 -d, --detailed Whether to output detailed information about the file. -o, --output If specified, a file to output the results to. --help Display this help screen. --version Display version information. value pos. 0 The file to display information for. 这个文本会在解析参数失败的时候自动输出。\n你也可以给你的应用程序添加一个总结，包括一些使用的例子。这些玩意会被添加到帮助文本中。\n结论 Command Line Parser 带走了解析命令行选项相关的样板代码。我可以清楚的感觉到，这个库从有几个选项的小程序到巨大的复杂应用程序都很有用。\n我现在在一个未来博客（指原作者的博客）可能提到的足球比赛模拟器用到了这个库\u0026hellip;\n","date":"2021-08-02T22:24:35+08:00","permalink":"https://blog.gaein.cn/passages/command-line-parser/","title":"C#解析命令行参数"},{"content":"宿舍概况 七院的宿舍楼包括：\n男宿：文瀛五（六层）、文瀛六（三层）、文瀛九（三层，公主坟）、文瀛十三（三层）、文瀛十七（六层，回字楼）； 女宿：文瀛十（六层，公主楼）、文瀛十七（六层，回字楼）。 其中，文瀛五、十为同一类型建筑，内部设施相似，条件优良。文瀛六、九、十三为同一类型，较老，条件很差。文瀛十七为“回”字形楼宇，条件优良。\n目前文瀛九和文瀛十三两栋条件较差的宿舍已经被19、20级学长住满，新生应该不会分配到这两栋楼。\n宿舍以班为单位随机分配，不够时可能出现不同班级混宿甚至不同专业混宿的状况。大二专业分流时会重新分班，宿舍也会重新分配。\n地理位置 七院宿舍所在的文瀛苑位于学校西区，主操场西侧，柏林园东侧。位于第四食堂、食味坊、唐久超市、百特快餐、雅贤阁、民族食堂等地较近，就餐方便。距离主操场、主楼、图书馆等场地距离也不算远。\n门禁\u0026amp;供电 工作日：晚上11点停止供电并锁门； 周末：晚上11点30停止供电并锁门； 除周末外的节假日：晚上11点30锁门，通宵供电。 部分特殊时期（比如毕业生毕业）可能会通宵供电。\n如果回宿舍已经锁门可以敲门窗联系楼管开门，尽量不要回来太晚。\n公共设施 宿舍每层都有水房，可以用学校发的一卡通接热水。水房自来水免费用； 宿舍楼内有澡堂，使用一卡通刷淋浴，不能调节水温，大部分情况下温度还算合理； 宿舍楼内有洗衣房，洗衣机使用手机付款洗衣服； 部分楼（如文瀛9）的部分厕所为“贯穿式”比较恶心，大部分厕所是一人一坑； 文瀛五、文瀛十、文瀛十七等条件较好的宿舍有阳台、独立卫生间和楼顶自习室；文瀛九、文瀛十三等宿舍没有。 寝室设施 七院寝室均为六人间（不排除可能有部分大宿舍）、上下铺，铺位大小为 190cm x 90cm，可以自备床上用品。\n宿舍内均没有空调和电扇； 宿舍内每人一个衣柜，上下两层，内有衣杆和镜子等； 宿舍六人合用一张大桌子，桌子有抽屉，配六个凳子； 文瀛九、文瀛十三等宿舍部分宿舍有晾衣绳，部分宿舍没有晾衣绳但是有绳子挂钩； 文瀛十三内楼道有晾衣杆，文瀛九没有； 文瀛九部分宿舍有地板，其余宿舍为水泥地，文瀛十三没有地板； 宿舍内设有网线接口，宿舍总线带宽为100M，据说单人限速为20M，可以连接网线校园网访问内网（或公网）。 具体宿舍情况 文瀛苑主要分为3层和6层的楼，3层的条件较差，没有独卫阳台；6层的条件较好，有独卫阳台。\n文瀛五 男宿。目前为部分20级学生在住。\n西区较好。独立卫生间和阳台（露天和不露天的都有），铁皮衣柜，瓷砖地板。\n距离柏林园北侧的篮球场较近，离第四食堂等隔一栋楼，楼下有报亭可以买零食。\n文瀛六 男宿。目前为很少一部分20级学生在住。\n西区较差。没有独立厕所和阳台，铁皮衣柜，水泥地。\n位于文瀛五北边。\n文瀛九 男宿。目前为一少部分19级和一部分20级学生在住。\n西区较差。没有独立厕所和阳台，铁皮衣柜，少部分宿舍有地板。\n东临第四食堂、百特快餐等就餐地点（一条路都是），附近有唐久超市和报亭。\n文瀛十 女宿。目前为一部分20级学生在住。\n西区较好。独立卫生间和阳台（露天和不露天的都有），铁皮衣柜，瓷砖地板。\n位于文瀛九南边。\n文瀛十三 男宿。目前为大部分19级学生在住。\n西区最差。没有独立厕所和阳台，水泥地。\n东临麦港（主要是早餐和小吃）以及超市和理发店等，西边有报亭可以买零食。\n文瀛十七 男宿。目前为一部分18级学生在住。\n女宿。目前为一校部分20级学生在住。\n男女宿舍区域是分开的，只是同在一栋楼。\n东临主操场，西边是麦港（主要是早餐和小吃）以及超市和理发店等，南边是南环路。\n由于楼宇设计特殊，称为“回”字楼，经常有各种表白、喊楼整活。\n另请参阅 面向学弟学妹的本校宿舍简介 - UmbのBlog\n","date":"2021-07-26T13:44:29+08:00","permalink":"https://blog.gaein.cn/passages/dormitory-of-nuc/","title":"中北大学七院宿舍情况"},{"content":"版权声明 \u0026ldquo;Microsoft account integrated sign in via C#\u0026rdquo; by Anduin Xue, used under CC AS 4.0, ‎translate from original.\n本文翻译自 Anduin Xue 的 \u0026ldquo;Microsoft account integrated sign in via C#\u0026rdquo; ，依据 CC AS 4.0 协议授权。\n下面的简单代码说明了如何构建一个支持使用 Microsoft 账户的 OAuth 身份认证。\n在开始打代码之前，我们需要在你的 Azure portal 中先创建一个App。 https://portal.azure.com\n这个名字是你的App显示的名字。选中让你的应用可以访问任何组织账号和个人账号的那项。至于重定向URI，它必须是你的服务器重定向地址，比如：\n1 https://gateway.aiursoft.com/debug 创建完应用后，在这里复制你的 application id：\n然后创建一个 secret。\n别忘了复制那个 secret。\n运行下面说的代码需要一些像 AiurUrl 和 Aiursoft.XelNaga.Services.HTTPService 这样的类。运行下面这行命令来获取：\n1 $ dotnet add package Aiursoft.XelNaga 为了让用户登录，我们需要重定向到微软的登录门户。复制以下的代码：\n1 2 3 4 5 6 7 8 9 10 11 public string GetBindRedirectLink() { return new AiurUrl(\u0026#34;https://login.microsoftonline.com\u0026#34;, $\u0026#34;/{_tenant}/oauth2/v2.0/authorize\u0026#34;, new MicrosoftAuthAddressModel { ClientId = _clientId, RedirectUri = \u0026#34;https://gateway.aiursoft.com/debug\u0026#34;, ResponseType = \u0026#34;code\u0026#34;, Scope = \u0026#34;user.read\u0026#34;, State = \u0026#34;\u0026#34; }).ToString(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 public class MicrosoftAuthAddressModel { [FromQuery(Name = \u0026#34;client_id\u0026#34;)] public string ClientId { get; set; } [FromQuery(Name = \u0026#34;redirect_uri\u0026#34;)] public string RedirectUri { get; set; } [FromQuery(Name = \u0026#34;state\u0026#34;)] public string State { get; set; } [FromQuery(Name = \u0026#34;scope\u0026#34;)] public string Scope { get; set; } [FromQuery(Name = \u0026#34;response_type\u0026#34;)] public string ResponseType { get; set; } } 只需要返回给浏览器一个redirect result 和从 GetRedirectLink() 函数获取到的重定向链接。\n用户成功的登录了他的账户的时候，将会带着一个码重定向回到你设置的 RedirectUri。这个码正式我们需要的。\n通过这个码，你可以调用 GetUserDetail() 方法来获取用户的信息。\n1 2 3 4 5 public async Task\u0026lt;IUserDetail\u0026gt; GetUserDetail(string code) { var token = await GetAccessToken(_clientId, _clientSecret, code); return await GetUserInfo(token); } _clientId 和 _clientSecret 是你创建这个 app 时候复制的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private async Task\u0026lt;string\u0026gt; GetAccessToken(string clientId, string clientSecret, string code) { var apiAddress = \u0026#34;https://login.microsoftonline.com\u0026#34; + $\u0026#34;/{_tenant}/oauth2/v2.0/token\u0026#34;; var url = new AiurUrl(apiAddress, new { }); var form = new AiurUrl(string.Empty, new MicrosoftAccessTokenAddressModel { ClientId = clientId, ClientSecret = clientSecret, Code = code, Scope = \u0026#34;user.read\u0026#34;, RedirectUri = \u0026#34;https://gateway.aiursoft.com/debug\u0026#34;, GrantType = \u0026#34;authorization_code\u0026#34; }); try { var json = await _http.Post(url, form, false); var response = JsonConvert.DeserializeObject\u0026lt;AccessTokenResponse\u0026gt;(json); if (string.IsNullOrWhiteSpace(response.AccessToken)) { throw new AiurAPIModelException(ErrorType.Unauthorized, \u0026#34;Invalid Microsoft crenditial\u0026#34;); } return response.AccessToken; } catch (WebException) { throw new AiurAPIModelException(ErrorType.Unauthorized, \u0026#34;Invalid Microsoft API response\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MicrosoftAccessTokenAddressModel { [FromQuery(Name = \u0026#34;client_id\u0026#34;)] public string ClientId { get; set; } [FromQuery(Name = \u0026#34;client_secret\u0026#34;)] public string ClientSecret { get; set; } [FromQuery(Name = \u0026#34;code\u0026#34;)] public string Code { get; set; } [FromQuery(Name = \u0026#34;scope\u0026#34;)] public string Scope { get; set; } [FromQuery(Name = \u0026#34;grant_type\u0026#34;)] public string GrantType { get; set; } [FromQuery(Name = \u0026#34;redirect_uri\u0026#34;)] public string RedirectUri { get; set; } } GetAccessToken() 方法能够帮助你获取一个有效的能够让你下载到用户信息的 access token。\n你拿到了 access token 之后，只需要调用 GetUserInfo() 即可。下面我们将调用 graph API 来获取当前用户的信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private async Task\u0026lt;MicrosoftUserDetail\u0026gt; GetUserInfo(string accessToken) { var apiAddress = \u0026#34;https://graph.microsoft.com/v1.0/me\u0026#34;; var request = new HttpRequestMessage(HttpMethod.Get, apiAddress); request.Headers.Add(\u0026#34;Authorization\u0026#34;, $\u0026#34;Bearer {accessToken}\u0026#34;); var response = await _client.SendAsync(request); if (response.IsSuccessStatusCode) { var json = await response.Content.ReadAsStringAsync(); var user = JsonConvert.DeserializeObject\u0026lt;MicrosoftUserDetail\u0026gt;(json); return user; } else { throw new WebException(response.ReasonPhrase); } } 返回的用户是一个 MicrosoftUserDetail 的实例。\n1 2 3 4 5 6 7 8 9 10 11 public class MicrosoftUserDetail : IUserDetail { [JsonProperty(\u0026#34;id\u0026#34;)] public string Id { get; set; } [JsonProperty(\u0026#34;displayName\u0026#34;)] public string DisplayName{ get; set; } [JsonProperty(\u0026#34;userPrincipalName\u0026#34;)] public string UserPrincipalName { get; set; } [JsonProperty(\u0026#34;jobTitle\u0026#34;)] public string JobTitle{ get; set; } } Id 是唯一的，可以使用这个来认证你的用户。\n最后，构建一个个性化的网页，然后你的app就行力。\n源代码在这：\nhttps://github.com/AiursoftWeb/Nexus/blob/master/Pylon/Services/Authentication/ToMicrosoftServer/MicrosoftService.cs\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License\n","date":"2021-07-09T04:49:35+08:00","permalink":"https://blog.gaein.cn/passages/ms-account-integrated-signin-via-cssharp/","title":"C#实现使用微软账户集成登录"},{"content":"因为校园网 DNS 污染，导致我无法连接 githubusercontent.com ，所以准备更换一个公共 DNS。以下为常见的一些公共 DNS 服务。\nDNS 全称是 Domain Name System ，可以理解为负责把域名变成 IP 的一个玩意。\n注：所有 IPv6 地址均无阿里云测试，因为我服务器没有 v6。目前只有这两三种网络测试，选择 DNS 时候还是自己 ping 一下看看。\n常见公共 DNS 服务 阿里 DNS 网址: https://alidns.com/\nIPv6 主 DNS 辅 DNS 太原电信 唐山电信 2400:3200::1 2400:3200:baba::1 10ms 19ms IPv4 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 223.5.5.5 223.6.6.6 15ms 20ms 4ms 百度 DNS 网址: https://dudns.baidu.com/\n主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 180.76.76.76 无 13ms 18ms 5ms DNSPOD（腾讯） 网址: https://www.dnspod.cn/products/public.dns\n免费版 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 119.29.29.29 无 12ms 21ms 7ms 专业版 主 DNS 辅 DNS 太原电信 北京阿里云 见控制台 见控制台 20ms 未测试 114DNS 网址: https://www.114dns.com/\n无劫持 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 114.114.114.114 114.114.115.115 33ms 34ms 29ms 拦截 钓鱼病毒木马网站 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 114.114.114.119 114.114.115.119 34ms 34ms 29ms 拦截 色情网站 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 114.114.114.110 114.114.115.110 47ms 36ms 31ms Google Public DNS 网址: https://dns.google.com/\nIPv6 主 DNS 辅 DNS 太原电信 唐山电信 2001:4860:4860::8888 2001:4860:4860::8844 43ms 253ms IPv4 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 8.8.8.8 8.8.4.4 58ms 49ms 54ms 1.1.1.1 网址: https://1.1.1.1/dns/\nIPv6 主 DNS 辅 DNS 太原电信 唐山电信 2606:4700:4700::1111 2606:4700:4700::1001 79ms 202ms IPv4 主 DNS 辅 DNS 太原电信 唐山电信 北京阿里云 1.1.1.1 1.0.0.1 188ms（辅） 165ms 165ms 配置 DNS Windows 10 点击右下角网络图标，然后点击\u0026quot;Network \u0026amp; Internat settings\u0026quot;； 点击正在使用的网络（比如我的是\u0026quot;Ethernet\u0026quot;，如果你在使用 WiFi 这里应该会显示\u0026quot;Wi-Fi\u0026quot;），点击\u0026quot;Properties\u0026quot;； 在 \u0026ldquo;IP Settings\u0026rdquo; 处点击 \u0026ldquo;Edit\u0026rdquo;，依次输入 \u0026ldquo;Preferred DNS\u0026rdquo; 和 \u0026ldquo;Alternate DNS\u0026rdquo;，如果有 IPv6 那么在下面的 \u0026ldquo;IPv6\u0026rdquo; 栏的对应位置输入 IPv6 DNS。 Ubuntu 我手里只有 Ubuntu，其它 Linux 如何配置未知。貌似更改 /etc/resolv.conf 是通用方法。\n由于我们使用的是 Ubuntu，Ubuntu 的 DNS 是由 systemd-resolve 来管理的，因此我们不需要手动更新 /etc/resolv.conf （事实上更新了也会被覆盖）。\n更好的方法还可以考虑使用 Netplan 来管理 DNS ， 详见 Using DHCP and static addressing 中 nameservers 一章的配置。\n关于错误示范请见我在 18 年干的傻事：\nUbuntu 下 apt“无法解析域名”解决方案\n确定使用的是 systemd 管理的解析服务：使用命令 systemd-resolve --status 查看服务状态； 编辑 DNS 文件：/etc/systemd/resolved.conf\nDNS 为 DNS 地址，可以配置多个 DNS，用空格隔开。\nFallbackDNS 为备用 DNS，同理。 比如： 1 2 3 [Resolve] DNS=223.5.5.5 119.29.29.29 180.76.76.76 FallbackDNS=223.6.6.6 另请参阅：Use DNS over TLS - Fedora Magazine\n","date":"2021-06-12T14:57:12+08:00","permalink":"https://blog.gaein.cn/passages/use-public-dns-and-configure-dns/","title":"常见公共DNS服务\u0026Linux和Windows下修改DNS的方法"},{"content":"集合的排序—— Sort 方法 Array 类提供了 Sort 静态方法，使用快排算法对集合中的元素进行排序。 List\u0026lt;T\u0026gt; 泛型类提供了 Sort 方法，使用快排。\n不使用自定义的排序 注意：使用无参数重载的 Sort 方法，需要实现 IComparable 接口。简单类型 System.String 和 System.Int32 等实现 IComparable 接口，所以可以对包含这些类型的元素的数组进行排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System; using System.Linq; var array = new[] { 10, 5, 7, 3, 9, -2, }; var list = array.ToList(); Array.Sort(array); list.Sort(); foreach (var item in array) { Console.Write($\u0026#34;{item} \u0026#34;); } Console.Write(\u0026#39;\\n\u0026#39;);. foreach (var item in list) { Console.Write($\u0026#34;{item} \u0026#34;); } 输出\n1 2 -2 3 5 7 9 10 -2 -2 3 5 7 9 10 -2 自定义规则的排序 传入比较器实例 Array 和 List\u0026lt;T\u0026gt; 泛型类的 Sort 方法都有接受实现 IComparer 接口的类的实例对象的重载。\n显示定义比较器类 定义类继承于 Comparer\u0026lt;T\u0026gt; 泛型类，避免拆箱装箱的额外开销，并且保证类型安全，并且实现 Compare(T, T) 方法：\n注意：也可以继承于 IComparer 和 IComparer\u0026lt;T\u0026gt; 接口，但是这不是Microsoft 建议的做法：\n“建议从 Comparer 类派生，而不是实现 IComparer 接口，因为 Comparer 该类提供方法的显式接口实现 IComparer.Compare 和 Default 获取对象的默认比较器的属性。”\n1 2 3 4 5 6 7 8 9 10 public class MyComparer : Comparer\u0026lt;int\u0026gt; { public override int Compare(int x, int y) { var xPositive = Math.Abs(x); var yPositive = Math.Abs(y); return xPositive.CompareTo(yPositive); } } 返回值的规则为：\n当 x 应该在 y 的 前面 的时候（也就是 x 小于 y），返回小于0的数字（-1） 当 x 应该在 y 的 后面 的时候（也就是 x 大于 y），返回大于0的数字（1） 当 null 参与比较时不应该引发异常，且为 null 的对象应在其它对象 前面（也就是说 小于 任何其它对象） 另请参阅： IComparer 接口 (System.Collections) | Microsoft Docs\nIComparer 接口 (System.Collections.Generic) | Microsoft Docs\nComparer 类 (System.Collections.Generic) | Microsoft Docs\n\u0026ldquo;Comparer.Compare(T, T) 方法 (System.Collections.Generic) | Microsoft Docs\u0026rdquo;\n使用 Comparer\u0026lt;T\u0026gt;.Create 方法和匿名函数创建比较器 Create 方法用指定的比较创建一个比较器。\n该方法的参数是一个 Comparison\u0026lt;T\u0026gt; 类型的委托。可以使用 lambda 表达式直接创建一个匿名函数委托。\n1 2 3 4 5 6 7 var array = new[] { 10, 5, 7, 3, 9, -2, }; var comparer = Comparer\u0026lt;int\u0026gt;.Create((x, y) =\u0026gt; Math.Abs(x).CompareTo(Math.Abs(y)) ); Array.Sort(array, comparer); 或者直接\n1 2 3 4 5 var array = new[] { 10, 5, 7, 3, 9, -2, }; Array.Sort(array, Comparer\u0026lt;int\u0026gt;.Create((x, y) =\u0026gt; Math.Abs(x).CompareTo(Math.Abs(y)) )); 关于 lambda 表达式可以看我的这篇笔记：CSharp的委托、lambda 表达式和事件 - CSharp笔记 —— 博客 | Gaein nidb 的网站\n箭头前的 x y 为两个参数，类型为自动推断的int（如果编译器不能推断可以手动加上类型来指定），只有一个参数的时候可以省略箭头前面的括号。\n箭头后为表达式体，只有一行语句的时候可以在箭头后直接书写语句，该语句的返回值将作为匿名方法返回值。如果有多行语句，使用花括号框成代码块，并且使用 return 关键字返回值。\n变量 comparer 为 Comparer\u0026lt;int\u0026gt; 的实例，作为参数传入 Array.Sort 方法即可。\n另请参阅： Comparer 类 (System.Collections.Generic) | Microsoft Docs\nComparer.Create(Comparison) 方法 (System.Collections.Generic) | Microsoft Docs\n传入委托的比较方法 Array 类和 List\u0026lt;T\u0026gt; 泛型类也都有 Comparison\u0026lt;T\u0026gt; 类型参数的重载，所以可以直接使用 lambda 创建匿名函数传入 Sort 方法。\n1 2 3 4 5 6 7 8 9 10 var array = new[] { 10, 5, 7, 3, 9, -2, }; var list = array.ToList(); Array.Sort(array, (x, y) =\u0026gt; Math.Abs(x).CompareTo(Math.Abs(y)) ); list.Sort((x, y) =\u0026gt; Math.Abs(x).CompareTo(Math.Abs(y)) ); 没错，把 Create 方法的参数扔这里就好了（那我前面是什么废话）。\nLINQ的排序—— OrderBy 方法 OrderBy 方法用于升序排序，orderby 子句会被编译器转换为对 OrderBy 方法的调用。\n不使用自定义的排序 使用重载 OrderBy\u0026lt;TSource,TKey\u0026gt;(IEnumerable\u0026lt;TSource\u0026gt;, Func\u0026lt;TSource,TKey\u0026gt;) 来使用默认的比较器进行升序排序：\n1 2 3 4 5 6 using System; using System.Linq; var arr = new[] { 10, 5, 7, 3, 9, -2, }; arr.OrderBy(it =\u0026gt; it).ToList().ForEach(Console.WriteLine); 输出为\n1 2 3 4 5 6 -2 3 5 7 9 10 自定义规则的排序 LINQ 的 OrderBy 方法没有像 Array 和 List\u0026lt;T\u0026gt; 一样的传入 Comparison\u0026lt;T\u0026gt; 类型委托的重载。它只提供了重载 OrderBy\u0026lt;TSource,TKey\u0026gt;(IEnumerable\u0026lt;TSource\u0026gt;, Func\u0026lt;TSource,TKey\u0026gt;, IComparer\u0026lt;TKey\u0026gt;) 。因此，我们不能在参数表里传入 lambda 表达式创建匿名方法来比较。只能创建类并继承于 Comparer\u0026lt;T\u0026gt; ，或者使用 Comparer\u0026lt;T\u0026gt;.Create 方法并传入用于比较的匿名方法。\n当需要多次进行这种比较时推荐创建自定义的类，并且实例化一个对象多次使用。或者创建一个变量来存储 Comparer\u0026lt;T\u0026gt;.Create 创建的对象。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var files = new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles().ToList(); var comparer = new MyComparer(); // 使用创建的类的实例 var listAfterSort1 = files.OrderBy(it =\u0026gt; it.Name, comparer).ToList(); // 使用 Comparer\u0026lt;T\u0026gt;.Create 传参委托的匿名函数创建 var listAfterSort2 = files.OrderBy(it =\u0026gt; it.Name, Comparer\u0026lt;string\u0026gt;.Create((x, y) =\u0026gt; string.Compare(x, y, StringComparison.Ordinal); )); public class MyComparer : Comparer\u0026lt;string\u0026gt; { public override int Compare(string x, string y) =\u0026gt; string.Compare(x, y, StringComparison.Ordinal); } 注意：这种情况实际上是不需要自定义比较器的，为了演示才这么写的（因为我懒得想例子）\n","date":"2021-06-11T19:39:59+08:00","permalink":"https://blog.gaein.cn/passages/csharp-orderby-customed-comparer/","title":"C# 中集合和 LINQ 的排序"},{"content":" 注意：此内容已过期。Adobe Premiere 不能导入的本质原因的 PR 2020 前的版本不支持 HEVC/H.265 编码。旧版本使用 ffmpeg 进行转码即可正常使用，新版本没有此问题。\n有关视频编码、容器、格式等见：直播推流常见协议及网页端实现 RTMP/STR/FLV/HLS/WebRTC\n此文章内所述较为片面。\nmkv mkv格式本身是一个“容器”，它包括了视频、音频、章节等，其实，不需要转码，只需要把需要的视频和音频“拆”出来即可。\n工具 MKVToolNix 该工具用于操作mkv文件（虽然我们只需要其中的解包部分）\n官网：https://mkvtoolnix.download/ Windows下载：https://www.fosshub.com/MKVToolNix.html MKVExtractGUI2 图形化界面的解包mkv的程序，需要放置在 MKVToolNix 的根目录下。\n目录结构如下：\nsourceforge：https://sourceforge.net/projects/mkvextractgui-2/ 提取音视频 可以直接双击点开 MKVExtractGUI2 ，选择 input ，下面的框中将显示出来 Tracks，选择需要的然后导出即可。\n可惜我的并不能用，它什么也不显示，只能手动来一波了。\n提取音视频（命令行） 实际上 MKVExtractGUI2 也是调用的 MKVToolNix 命令行来提取的，而 MKVToolNix 的图形化又比较复杂，不会用。直接使用命令行甚至会方便一些。\n在当前目录打开 powershell 后，输入：\n.\\mkvinfo.exe \u0026quot;\u0026lt;mkv文件路径\u0026gt;\u0026quot; ，比如我这个是 .\\mkvinfo.exe \u0026quot;C:\\Users\\Gaein_nidb\\Videos\\High School Fleet [01].mkv\u0026quot;\n以VCB-S压制的 High School Fleet/高校舰队 为例，程序会输出一大坨mkv的信息，我们需要关注的为 Tracks ，其中的每一个 Track 为一条轨道，其中包括：\nTrack number：轨道ID（在mkvextract工具中轨道ID从0开始） Track type：轨道的类型（视频或音频等） Codec ID：编码ID 以上均用 \u0026ldquo;//\u0026rdquo; 做了伪注释\n以及一些其它重要信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 |+ Tracks | + Track // 第一条轨道 | + Track number: 1 (track ID for mkvmerge \u0026amp; mkvextract: 0) // 在mkvextract工具中轨道ID为0 | + Track UID: 16171542915234837125 | + Track type: video // 视频 | + \u0026#34;Lacing\u0026#34; flag: 0 | + Minimum cache: 1 | + Codec ID: V_MPEGH/ISO/HEVC // 格式为HEVC | + Language: und | + Video track | + Pixel width: 1920 | + Pixel height: 1080 | + Display width: 1920 | + Display height: 1080 | + Codec\u0026#39;s private data: size 1151 (HEVC profile: Main 10 @L4.1) | + Default duration: 00:00:00.041708333 (23.976 frames/fields per second for a video track) | + Track // 第二条轨道 | + Track number: 2 (track ID for mkvmerge \u0026amp; mkvextract: 1) // ID为1 | + Track UID: 11899936184913956278 | + Track type: audio // 音频 | + Codec ID: A_FLAC // 格式为flac | + Codec\u0026#39;s private data: size 113 | + Default duration: 00:00:00.085333333 (11.719 frames/fields per second for a video track) | + Language: jpn | + Audio track | + Sampling frequency: 48000 | + Channels: 2 | + Bit depth: 24 | + Track // 第三条轨道 | + Track number: 3 (track ID for mkvmerge \u0026amp; mkvextract: 2) // ID为2 | + Track UID: 10563629169812897935 | + Track type: audio // 音频 | + \u0026#34;Default track\u0026#34; flag: 0 | + Codec ID: A_AAC // 格式为ACC | + Codec\u0026#39;s private data: size 2 | + Default duration: 00:00:00.021333333 (46.875 frames/fields per second for a video track) | + Language: jpn | + Audio track | + Sampling frequency: 48000 | + Channels: 2 那么我们需要提取的有：\nHEVC视频，轨道0 FLAC音频，轨道1 当然你想要ACC不要FLAC也行，咋都行，看需求而来\n使用 mkvextract 工具来解mkv文件，输入命令：\n.\\mkvextract.exe \u0026quot;\u0026lt;mkv文件\u0026gt;\u0026quot; tracks 0:video.hevc 1:audio.flac\n其中，tracks后面的参数为 \u0026lt;轨道ID\u0026gt;:\u0026lt;输出文件\u0026gt; ，根据你想解的轨道，输入上面看信息看到的轨道ID即可。\n然后，在这个文件夹中，我们得到了 video.hevc 和 audio.flac 两个文件。\n导入PR 尽管我们已经解开了，但是仍然不能导入，PR会说不支持的文件格式。\n对于视频来说，解决的方法很简单：更改后缀名为PR能识别的，比如 mp4\n对于flac音频来说：更改后缀名为 wav\n请使用 ffmpeg 或其他工具进行 re-mux 或 re-enc\n","date":"2021-05-12T22:32:26+08:00","permalink":"https://blog.gaein.cn/passages/import-hevc-for-old-adobe-premiere/","title":"【过期内容】Adobe Premiere 导入 mkv 格式的视频"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 委托、lambda 表达式和事件 8 - 委托、lambda 表达式和事件 8.1 - 引用方法 委托是寻址方法的 .NET 版本。在C++中，函数指针只不过是一个指向内存位置的指针，我们不知道它实际指向什么，参数和返回类型就更无从知晓了。而 .NET 的委托是安全的，它定义了返回类型和参数的类型，它不仅包含对方法的引用，也可以包含对多个方法的引用。\nlambda 表达式与委托直接相关。当参数是委托类型的时候，就可以使用 lambda 表达式实现委托引用的方法。\n8.2 - 委托 当要把方法作为参数传递给方法的时候，就需要使用委托。\n8.2.1 - 声明委托 首先必须定义要使用的委托，对于委托，定义就是告诉编译器这种类型的委托表示哪种类型的方法。然后必须将委托实例化，编译器将在后台创建该委托的一个类。\n语法如下：\n1 delegate void IntMethodInvoker(int x); 声明了一个类型为 IntMethodInvoker 的委托，交给委托的方法带有一个 int 类型的参数，并且返回 void。在定义委托的时候必须指定好方法的参数和返回类型，这样才安全嘛。\n委托语法类似于方法的定义，但是没有主体，而且要加上关键字 delegate 。因为委托基本上算是定义一个新类，所以基本上来说，在能定义类的地方就能定义委托。可以在类的内部定义委托，也可以和类平级。还可以给委托加上修饰符：public 、 private 、 protected 等。\n8.2.2 - 使用委托 可以使用委托的“构造函数”向内传递一个方法的名字来创建一个委托：\n1 2 3 4 5 6 7 8 9 private string GetString(); // 声明委托 public static void Main() { var x =40; var invokeMethod = new GetString(x.ToString); // 将方法委托给 invokeMethod Console.WriteLine(invokeMethod()); // 执行了 invokeMethod，invokeMethod 又执行了 x.ToString 方法 } 在CSharp中，委托在语法上总是接受一个参数类型的构造函数，这个参数就是委托所引用的方法。这个方法必须要匹配定义委托时候的签名。\n实际上，使用 invokeMethod() 和 invokeMethod.Invoke() 完全相同。\n为了减少输入量，在需要委托实例的每个位置都可以只传送方法名称，这称为委托推断：\n1 2 var invokeMethod = new GetString(x.ToString); var invokeMethod2 = x.ToString; // 等价 注意：不要输入圆括号，仅输入方法名代表了方法的地址，而使用圆括号则是调用了方法并返回一个值。\n除了实例一个委托之外，还能实例委托的数组：\n1 2 3 4 5 6 GetString[] methods = new[] { x.ToString, y.ToString, // 返回 string 类型并且不接受参数的方法都行 }; 8.2.4 - Action 和 Func 为每个参数和返回类型都定义一个委托太麻烦了，所以可以使用 Action\u0026lt;T\u0026gt; 和 Func\u0026lt;T\u0026gt; 委托。\n泛型 Action\u0026lt;T\u0026gt; 代表引用一个 void 返回类型的委托。没有泛型参数的 Action\u0026lt;T\u0026gt; 类可以调用没有参数的方法。Action\u0026lt;in T\u0026gt; 调用带一个参数（类型为 T）的方法，以此类推，Action\u0026lt;in T1, in T2\u0026gt; 调用带两个参数的方法。最多有16个参数。\n泛型 Func\u0026lt;T\u0026gt; 可以引用有返回类型的委托， Func\u0026lt;out TResult\u0026gt; 委托类型可以调用带返回类型且无参数的委托。而 Func\u0026lt;in T, out TResult\u0026gt; 委托类型可以调用带一个参数的方法，最后一个泛型是返回类型。\n8.2.6 - 多播委托 委托也可以包含多个方法，这种委托也可以包含多个方法。这种委托称为多播委托。如果调用多播委托，就可以按照顺序连续调用多个方法。所以，多播委托方法的返回类型必须为 void ；否则，只能获取最后一个调用的委托的方法结果。\n多播委托重载了运算符 + 以及 += ，可以通过 + 来为多播委托添加一个方法。当然，也重载了 - 和 -= ，可以使用 - 运算符移除一个方法。\n注意：对同一个委托，调用其方法链的顺序并未定义，因此，应避免编写依赖于特定顺序调用的代码。\n多播委托包含一个逐个调用的委托集合。如果通过委托调用其中一个方法抛出了异常，整个迭代就会终止，剩余委托的方法即使是正常的也不会被调用。\n为了避免这种问题，应该自己迭代方法列表。 Delegate 类定义了 GetInvocationList 方法，它返回一个 Delegate 对象数组。\n8.2.7 - 匿名方法 注意：这种匿名方法的语法在CSharp2中引入。在新的程序中，并不需要这个语法，lambda 表达式明显比这个好用。\n语法如下，大致看看就得了：\n1 2 3 4 5 6 7 8 9 10 var mid = \u0026#34;, middle part,\u0026#34;; Func\u0026lt;string, string\u0026gt; annoDel = delegate (string param) { param += mid; param += \u0026#34; and this was added to the string.\u0026#34;; return param; }; // 代码的第四行到第九行是匿名方法。 8.3 - lambda 表达式 lambda 运算符 =\u0026gt; 左边列出了需要的参数（一个参数可以省略括号），而右边定义了赋予 lambda 变量的方法的实现代码。\n8.3.1 - 参数 lambda 表达式有几种定义参数的方法，如果只有一个参数那就写出参数名就行了，编译器根据委托自动推断参数类型，比如：\n1 2 Func\u0026lt;string, string\u0026gt; oneParam = s =\u0026gt; $\u0026#34;change uppercase {s.ToUpper()}\u0026#34;; 有多个参数的时候，将参数放在圆括号中，用逗号分隔。当然，为了方便起见，也可以在参数前加上类型。\n8.3.2 - 多行代码 如果 lambda 表达式只有一条语句，则不方法块内不需要花括号和 return 语句，因为编译器会添加一条隐式的 return 语句。但是如果 lambda 表达式的实现代码中需要多条语句，那么就要添加花括号和 return 了。\n8.3.3 - 闭包 通过 lambda 表达式可以访问表达式块外部的变量，这成为闭包。闭包是非常好用的功能，但是使用不当也会造成大灾难。\n注意：如果给多个线程使用闭包，就可能遇到并发冲突。最好仅给闭包使用不可变的类型（readonly），这样就可以确保不改变值，也不需要同步。\n8.4 - 事件 事件基于委托，为委托提供了一种发布/订阅的机制。比如在桌面程序中：Button 出发了 Click 事件。这类事件就是委托。触发 Click 事件时调用的处理程序方法需要得到定义，而其参数由委托定义。\n使用 event 关键字来定义事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using System; namespace Program { // 用于事件传参的参数，继承于 EventArgs public class CarInfoEventArgs: EventArgs { // 构造函数 public CarInfoEventArgs(string car) =\u0026gt; Car = car; public string Car { get; set; } } public class CarDealer { // 事件，需要在泛型中写出传递给它的参数 public event EventHandler\u0026lt;CarInfoEventArgs\u0026gt; NewCarInfo; public void NewCar(string car) { Console.WriteLine($\u0026#34;new car {car}\u0026#34;); // 触发事件，第一个参数是触发者，第二个参数是传递的参数 NewCarInfo?.Invoke(this, new CarInfoEventArgs(car)); } } } 作为一个约定，事件通常用带两个参数的方法\n第一个参数是一个对象，包含事件的发送者。 第二个参数提供了事件的相关信息。 EventHandler\u0026lt;TEventArgs\u0026gt; 定义了一个处理程序，它返回 void ，接受两个参数，第二个参数类型通过泛型指定，并且必须继承于 EventArgs （上面代码中的 CarInfoEventArgs 就是）。\n另外，事件有自动生成一个私有字段，类似于自动生成的属性访问器吧：\n1 2 3 4 5 6 7 8 public event EventHandler\u0026lt;CarInfoEventArgs\u0026gt; NewCarInfo; // 简记 private EventHandler\u0026lt;CarInfoEventArgs\u0026gt; _newCarInfo2; // 写全 public event EventHandler\u0026lt;CarInfoEventArgs\u0026gt; NewCarInfo2 { add =\u0026gt; _newCarInfo += value; remove =\u0026gt; _newCarInfo -= value; } CarDealer 类通过调用委托的 Invoke 方法来触发事件，这与多播委托一样，顺序无法保证的。\n8.4.2 - 使劲按侦听器 下面实现的 Consumer 类用作事件的侦听器。这个类订阅了 CarDealer 类的事件：\n1 2 3 4 5 6 7 8 9 10 11 12 public class Consumer { private string _name; // 构造函数 public Consumer(string name) =\u0026gt; _name = name; // 事件被触发时调用此方法，这个是被委托的方法 public void NewCarIsHere(object sender, CarInfoEvent e) { Console.WriteLine($\u0026#34;{_name}: car {e.car} is new\u0026#34;); } } 使用 CarDealer 类的 NewCarInfo 事件（前面定义的那个 EventHandler 类型的“变量”），通过 += 运算符创建一个订阅：\n1 2 3 4 5 var dealer = new CarDealer(); var consumer = new Consumer(\u0026#34;A\u0026#34;); dealer.NewCarInfo += consumer.NewCarIsHere; // 添加订阅 dealer.NewCar(\u0026#34;B\u0026#34;); // 这个方法会触发事件，然后执行委托 最后会输出：\nnew car B\nA: car B is new\n","date":"2021-05-05T21:23:03+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note6-delegates-lambda-expressions-and-events/","title":"C#的委托、lambda 表达式和事件 - C#笔记"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 数组 7 - 数组 7.1 - 相同类型的多个对象 可以使用集合和数组，对于数量固定的可以使用数组。\n对于多个不同类型的对象可以使用类、结构或元组。\n7.2 - 简单数组 数组是一种数据结构，它可以包含同一类型的多个元素。\n7.2.1 - 数组的声明 使用类型紧跟一对中括号来声明数组，后面跟标识符。比如，下面的代码声明了一个 int 类型的数组：\n1 int[] array; 7.2.2 - 数组的初始化 数组是引用类型，所以必须给它分配堆上的内存。应该使用 new 运算符，指定元素的类型和数量来初始化数组的变量：\n1 int[] array = new int[8]; 上面的代码中 array 引用了一个包含8个 int 类型的元素的数组，它们位于托管堆上。\n注意：在指定了数组的大小后，如果不复制其中的所有元素就不能调整大小。而对于很大的数组来说复制数组是一场性能灾难，如果事先不知道包含多少个元素，应该使用集合。\n还可以使用数组初始化器为每个元素复制，数组初始化器只能在声明数组的时候使用，不能在声明之后使用。\n1 int[] array = new int[4] {2, 4, 6, 8}; 如果使用了初始化器（花括号那个）来初始化数组，可以不指定数组的大小，由编译器自动计算：\n1 int[] daysOfMonthTable = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 当然，使用花括号可以同时声明和初始化数组：\n1 int[] daysOfMonthTable = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 7.2.3 访问数组元素 通过索引器传递元素编号，就可以访问数组。索引器总是从0开始，array[0] 表示 array 数组的第一个元素。\n如果不知道数组中元素的个数，又想遍历数组，可以在 for 使用 array.Length 属性：\n1 2 3 4 for (var i = 0; i \u0026lt; array.Length; ++i) { Console.WriteLine(array[i]); } 当然，也可以使用 foreach 语句，但是 foreach 不能更改其中的元素：\n1 2 3 4 foreach(var item in array) { Console.WriteLine(item); } 7.2.4 - 使用引用类型 除了能声明预定义类型的数组，还可以声明自定义类型的数组，语法同上：\n1 Student[] stu = new Student[60]; 声明完后每个元素的引用都是 null ，因此，需要使用从0开始的索引器，可以为数组每个元素分配内存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 stu[0] = new Student() { Name = \u0026#34;Jack\u0026#34;, Class = \u0026#34;5\u0026#34;, }; stu[0] = new Student() { Name = \u0026#34;John\u0026#34;, Class = \u0026#34;2\u0026#34;, }; // ... 当然，也可以使用数组初始化器。\n7.3 - 多维数组 正如前面所见的，一维数组使用一个整数来索引，而多维数组使用多个整数来索引（比如我们可以用两个整数分别索引行和列）。\n在CSharp中声明一个二维数组可以在方括号中间加上一个逗号，比如：\n1 2 3 4 5 6 int[,] matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; 显而易见，适用于一维数组的初始化器也能用。\n7.4 - 锯齿数组 锯齿数组的大小设置比较灵活，不像二维数组那样必须是“方方正正”的，锯齿数组中每一行都可以有不同的大小：\n1 2 3 4 5 int[][] array = new int[3][]; array[0] = new int[4] {1, 2, 3, 4}; array[1] = new int[2] {16, 32}; array[2] = new int[1] {114514}; 定义时，第一个方括号里写行数，第二个留空。\n可以看作每个元素都是另外一个数组吧。\n7.5 - Array 类 用方括号声明数组是CSharp中 Array 类的表示法。在后台使用 CSharp 语法，会创建一个派生自抽象基类 Array 的新类。这样，就可以使用 Array 类中的方法和属性了。\n7.5.1 - 创建数组 除了可以使用CSharp语法来创建数组实例之外，还可以使用静态方法 Array.CreateInstance 来创建数组。如果事先不知道元素的类型，该静态方法就非常有用，因为类型可以作为 Type 对象传递给 CreateInstance 方法。\n还可以将用 CreateInstance 方法创建好的数组强制转换为 int 数组：\n1 2 3 var array = Array.CreateInstance(typeof(int), 6); var arrayAfterConvert = (int[])array; 7.5.2 - 复制数组 因为数组是引用类型，所以将数组的一个变量赋值给另外一个变量，得到是引用同一个数组的变量。使用 Clone 方法可以复制数组：\n1 2 var array1 = {1, 2}; var array2 = (int[])array1.Clone(); Clone 方法是浅复制，也就是说，如果数组的元素的引用类型，则仅复制引用而不深入复制值。\n还可以使用 Array.Copy 方法创建浅表副本，与 Clone 的区别是， Copy 方法需要传递一个阶数仙童并且足够大的数组作为参数，而不是像 Clone 创建并返回一个新数组。\n7.5.3 - 排序 Array 类使用快排算法来对数组中的元素进行排序。Sort 方法需要数组中的元素实现 IComparable 接口。在简单类型中已经实现了该接口，所以可以直接进行排序。\n如果对数组使用自定义类，就实现 IComparable 接口（或者它的泛型版本），这个接口定义了方法：Compare ，该方法接受一个要被用来比较的对象作为参数：\n如果要比较的对象的相等，就返回0。 如果该实例排在参数对象的前面，就返回小于0的值。 如果该实例排在参数对象的后面，就返回大于0的值。 如果对象的排序方法与上述不同，或者不能修改数组元素中用作元素的类（即修改元素的类并添加继承自 IComparable ），就可以考虑另外一个类（比如 Comparer ）实现 IComparer 接口或者其泛型版本。这两个接口定义了方法 Compare ，这个方法接受两个参数：\n如果两个参数对象相等，就返回0。 如果第一个参数在第二个参数前面，则返回小于0的值。 如果第一个参数在第二个参数后面，则返回大于0的值。 Tips：Array 类提供了 Sort 方法，需要传递一个委托i作为参数，而不需要依赖 IComparer 接口或者 IComparable 接口。\n7.6 - 数组作为参数 要把数组传递给方法，就按着你想象的来就行了。将参数声明为数组：\n1 2 3 4 static void DisplayStudents(Student[] stu) { // code } 7.7 - 数组协变 数组支持协变，也就是说，可以把数组声明为基类，其它派生类的对象可以被赋予数组：\n注意：数组协变只能用于引用类型不能用于值类型。\n7.8 - 枚举 在 foreach 语句中使用枚举，可以迭代集合中的元素，且不需要知道集合中的元素个数。数组和集合实现了带 GetEnumerator 方法的 IEnumerable 接口。 GetEnumerator 方法返回一个实现 IEnumerable 接口的枚举。接着 foreach 语句就可以使用 IEnumerable 接口迭代集合了。\n7.8.1 - IEnumerator 接口 foreach 语句使用 IEnumerator 接口的方法和属性，迭代集合中的所有元素。为此接口定义了 Current 用来返回当前迭代的元素。\nMoveNext 方法移动到下一个元素上，如果没有下一个元素则返回 false ，移动成功则返回 true 。\n7.8.2 - foreach 语句 foreach 首先调用 GetEnumerator 方法获取一个枚举器，并且当 MoveNext 方法返回 true 时进行迭代。\n1 2 3 4 foreach(var person in people) { Console.WriteLine(person); } 相当于：\n1 2 3 4 5 6 IEnumerator\u0026lt;Person\u0026gt; enumerator = people.GetEnumerator(); while(enumerator.MoveNext()) { var person = enumerator.Current; Console.WriteLine(enumerator.Current); } 7.8.3 yield 语句 yield return 语句返回集合的一个元素，并移动到下一个元素上。yield break 可停止迭代。\nTips：包含 yield 语句的方法或属性也成为迭代块。迭代块必须声明为返回 IEnumerator 或 IEnumerable 接口，或者这写接口的泛型版本。这个块可以包含多条 yield return 语句或 yield break 语句，但不能包含 return 语句。\n1. 迭代集合的不同方式 2. 用 yield return 返回枚举器 常见的使用方法是，用一个循环来迭代集合，然后每一次迭代来一个 yield return 语句，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 using System; using System.Collections.Generic; namespace Test { public class Program { private static void Main() { var school = new School(10); school.Add(new Student(\u0026#34;Jack\u0026#34;, 1)); school.Add(new Student(\u0026#34;Jan\u0026#34;, 2)); school.Add(new Student(\u0026#34;John\u0026#34;, 3)); school.Add(new Student(\u0026#34;Mack\u0026#34;, 4)); school.Add(new Student(\u0026#34;Ann\u0026#34;, 5)); foreach (var student in school) { Console.WriteLine(student); } } } public class Student { public Student(string name, uint grade) { Name = name ?? throw new ArgumentNullException(nameof(name)); Grade = grade; } public override string ToString() =\u0026gt; $\u0026#34;{Name} in {Grade}\u0026#34;; public string Name { get; set; } public uint Grade { get; set; } } public class School { public School(uint count) { Count = count; Students = new Student[Count]; } private int _currentIndex; public uint Count { get; set; } public Student[] Students { get; set; } /// \u0026lt;summary\u0026gt; /// Add a student to school /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;stu\u0026#34;\u0026gt;Student Object\u0026lt;/param\u0026gt; public void Add(Student stu) =\u0026gt; Students[_currentIndex++] = stu; public IEnumerator\u0026lt;Student\u0026gt; GetEnumerator() { for (var i = 0; i \u0026lt; Count; i++) { yield return Students[i]; } } } } 首先，定义了一个学生类 Student ，其中含有学生的基础信息和一个用于实例化的构造函数以及重写的 ToString 方法。\n然后，定义了另外一个类 School ，在学校类中写了 Add 方法来添加学生。另外实现了 GetEnumerator 方法，由于在 foreach 中的元素是 Student 类的实例，因此类型为泛型的 IEnumerator\u0026lt;Student\u0026gt; 。yield return 返回每一次迭代的结果即可。\n7.9 - 结构比较 数组和元组都实现了接口 IStructuralEquatable （用于进行内容比较是否相等）和 IStructuralComparable （用于在排序时进行比较决定顺序）。这两个接口不仅可以比较引用，还可以比较内容。\n可以让需要的结构实现 IEquatable 接口，这个接口定义了一个强化的 Equals 方法。这个方法接收两个参数，第一个是 object ，第二个是 IEquatableComparer ：\n1 2 3 4 if ((people as IEquatable).Equals(people2, EqualityComparer\u0026lt;Person\u0026gt;.Default)) { Console.WriteLine(\u0026#34;Same\u0026#34;); } 7.10 - Span 为了快速访问连续内存，可以使用 Span\u0026lt;T\u0026gt; 结构。一个可以使用 Span\u0026lt;T\u0026gt; 的例子是数组； Span\u0026lt;T\u0026gt; 结构在后台保存在连续的内存中。\n使用 Span\u0026lt;T\u0026gt; 可以直接访问数组元素。数组的元素没有复制，可以直接使用，这比复制要快（废话）。\nSpan 结构有个构造函数，把数组传参进去就行了，就能获得一个 Span。\n7.10.1 - 创建切片 Span\u0026lt;T\u0026gt; 的一个强大功特性是，可以使用它创建访问数组的一部分或者是切片。使用切片时，不会复制数组元素，它们是从 Span 直接访问的。\n调用 Slice 方法，也可以从 Span\u0026lt;T\u0026gt; 对象中创建一个切片。该方法接受两个参数：切片开始的索引号以及切片的长度。当然，也可以使用 Span 的构造函数创建一个切片：第一个参数是数组，后面是切片开始的索引号和长度。\n如果以后不需要修改 Span 引用的内容，可以使用 ReadOnlySpan 这个类型，转换是隐式进行的。\n注意：Span\u0026lt;T\u0026gt; 是安全的，不会出界破坏其它内存中的数据。如果创建的 Span 超出了数组的长度，则会抛出 ArgumentOutOfRangeException 异常。\n7.10.2 - 使用 Span 改变值 调用 Clear 方法，使用 0 填充 Span\u0026lt;int\u0026gt; 。\n调用 Fill 方法，使用传递的参数填充 Span\u0026lt;T\u0026gt; 。\n调用 CopyTo 方法，将一个 Span 复制到另一个 Span 中，如果目标不够大则会抛出 ArgumentException 异常。调用 TryCopyTo 方法来避免发生异常：\n1 2 3 4 if (span.TryCopyTo(newSpan)) { Console.WriteLine(\u0026#34;COPY SUCCESS\u0026#34;); } 7.10.3 - 只读的 Span 如上文所说，对于不需要修改的 Span 可以使用 ReadOnlySpan\u0026lt;T\u0026gt; 类型，这种类型没有 Clear 和 Fill 等方法，但是可以调用 CopyTo 复制到新的 Span 。\n7.11 - 数组池 如果一个应用程序创建、销毁了很多数组，那么GC酱就会很累。可以通过 ArrayPool 类创建数组池。\n7.11.1 - 创建数组池 通过调用静态的 Create 方法，就可以创建 ArrayPool\u0026lt;T\u0026gt; 。使用 Create 方法可以在创建之前定义最大的数组长度和数组的数量：\n1 var arrPool = ArrayPool\u0026lt;int\u0026gt;.Create(maxArrayLength: 8192, maxArraysPerBucket: 4096); maxArrayLength 的默认值是 1024x1024 字节，maxArraysPerBucket 的默认值是 50 。数组池使用了多个桶，以便使用多个数组时更快。只要还没有达到数组的最大数量，大小类似的数组就尽可能保存在一个桶里。\n1.12.2 - 从池中租借内存 调用 Rent 方法从池中租借内存。该方法接受应请求的最小数组长度。Rent 方法返回一个数组，其中至少包含所请求的元素个数。返回的数组可能有更多的可用内存：\n1 2 3 4 var arrayPool = ArrayPool\u0026lt;int\u0026gt;.Create(maxArrayLength: 8192, maxArraysPerBucket: 4096); var array = arrayPool.Rent(20); Console.WriteLine(array.Length); // output: 32 1.12.3 - 将内存返回给池 不再需要数组的时候，可以把内存返回回去。数组返回后，稍后可以使用一个 Rent 来重用这些内存。\n调用数组池的 Return 方法并将数组作为参数传递给它。这样返回后不会清除数组内的数据，也就是下次 Rent 后还可以访问其中的数据。为此该方法还有一个可选参数，指定在返回池之前是否清空它。\n","date":"2021-05-03T14:31:30+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note5-array/","title":"C#中数组的使用 - C#笔记"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 字符串和正则表达式 9 - 字符串和正则表达式 9.1 - System.String 类 在CSharp中，string 关键字的映射实际上指向 .NET 基类 System.String 。 System.String 是一个功能非常强大且用途广泛的基类。\n使用运算符重载可以连接字符串：\n1 2 3 4 var str = \u0026#34;Hello\u0026#34;; var str1 = \u0026#34;World\u0026#34;; var msg = str + str1; Console.WriteLine(msg); // HelloWorld CSharp还允许使用索引器来提取指定的字符串：\n1 2 var msg = \u0026#34;HelloWorld\u0026#34;; Console.WriteLine(msg[4]); // o System.String 类常见的方法有：\nCompare：比较字符串的内容，考虑区域原因（比如不同区域的日期格式、货币等）。 CompareOrdinal：同上，不考虑区域。 Concat：把多个字符串实例合并为一个实例。 CopyTo：把从选定下标开始的特定数量的字符复制到一个新实例中。 Format：格式化包含各种值的字符串和如何格式化的说明符。 IndexOf：字符串中第一次出现某个给定子字符或字符的为止。 IndexOfAny：字符串中第一次出现某个字符或一组字符的位置。 Insert：把一个字符串实例插入到另外一个字符串实例指定的索引处。 Join：合并字符串数组，创建一个新的字符串。 LastIndexOf：与 IndexOf 一样，从后往前查找。 LastIndexOfAny：与 IndexOfAny 一样，从后往前找。 PadLeft：在字符串的左侧，通过添加指定的重复字符来填充字符串。 PadRight：同上，在字符串右侧。 Replace：用另一个字符或子字符串替换字符串中给定的字符或子字符串。 Split：用给定字符作为分隔符分隔字符串。 SubString：从字符串中获取指定位置的子字符串。 ToLower：转换成小写。 ToUpper：转换成大写。 Trim：删除首尾的空白。 9.1.1 - 构建字符串 Spring 类存在一个问题：重复修改给定的字符串，效率会很低，它实际上是一个不可变的数据类型，表面上修改字符串内容的方法和运算符实际上是创建了一个新字符串并将内容复制过去。\nStringBuilder 类不像 String 类那样支持非常多的方法。它仅限于替换和追加或删除字符串中的文本。但是它的工作方式非常高效。\n通常情况下，StringBuilder 类分配的内存比它需要的多，在默认情况下就根据初始化实例时的字符串长度来确定所用内存的大小。这个类有两个主要的属性：\nLength：字符串的实际长度； Capacity：在内存中分配的最大长度； 对字符串的修改就在赋予 StringBuilder 实例的内存中进行，这就大大提高了追加或替换单个字符的效率，插入和删除子字符（串）的效率依然不高，因为要移动后面的字符串。\n最好把容量设置为字符串可能的最大长度，确保 StringBuilder 类不需要重新分配内存。\n一般而言，使用 StringBuilder 类执行字符串的任何操作，而 String 类用于存储字符串或显示最后结果。\n9.1.2 - 字符串插值 使用 $ 前缀创建字符串，在花括号中可以包含占位符来引用代码，比如：\n1 2 3 var name = \u0026#34;Jack\u0026#34;; var msg = $\u0026#34;Hello { name }, Welcome!\u0026#34;; Console.WriteLine(msg); // Hello Jack, Welcome! 注意，这只是个语法糖，编译器会创建 String.Format 方法的调用。 StringFormat 方法的第一个参数接受一个格式字符串，其中的占位符从0开始，比如：\n1 2 3 var name = \u0026#34;Jack\u0026#34;; var msg = String.Format(\u0026#34;Hello { 0 }, Welcome!\u0026#34;, name); Console.WriteLine(msg); FormattableString 把字符串赋予 FormattableString ，就很容易得到翻译过来的插值字符串。\n1 2 3 4 5 6 7 var x = 3, y = 4; FormattableString s = $\u0026#34;The result of { x } and { y } is { x + y }\u0026#34;; Console.WriteLine($\u0026#34;Format: { s.Format } \u0026#34;); foreach(var i = 0; i \u0026lt; s.ArgumentCount; ++i) { Console.WriteLine($\u0026#34;Argument { i }: { s.GetArgument(i) }\u0026#34;); } 输出为：\n1 2 3 4 Format: The result of { 0 } + { 1 } is { 2 } Argument 0: 3 Argument 1: 4 Argument 2: 7 给字符串插值使用其他区域值 辅助方法 Invariant 把插值字符串改为使用不变的区域值，而不是当前的区域值。将 CultureInfo.InvariantCulture 传递给 IFormatProvide 参数，就可以使用不变的区域值：\n1 Console.WriteLine(FormattableString.Invariant($\u0026#34;Date: {$day:d}\u0026#34;)); 注：区域值就是对于某些特殊的字符串（比如时间、日期），在不同的区域有不同的格式。\n转义花括号 使用两个花括号来转义插值字符串中的花括号：\n1 Console.WriteLine($\u0026#34;{{}}\u0026#34;); 输出：\n1 {} 9.2.2 日期时间和数字的格式 在占位符中，格式字符串跟在表达式后面，用冒号隔开：\n1 2 3 var day = new DateTime(1949, 10, 1); WriteLine($\u0026#34;{day:D}\u0026#34;); WriteLine($\u0026#34;{day:d}\u0026#34;); 用大写字母 D 表示长日期格式字符串，用小写字母 d 表示短日期字符串。\n输出：\n1 2 Saturday, October 1, 1949 10/1/1949 根据系统的语言设置，输出可能不同。\n另请参阅： Standard date and time format strings | Microsoft Docs\n使用 n 用分隔符（逗号）表示数字， e 表示指数表示法， x 表示转换为十六进制， c 显示为货币。\n还可以使用占位符：\n数字占位符 #：如果数字可用则显示数字，不可用则不显示； 零占位符 0：如果数字可用则显示数字，不可用则显示 0； 另请参阅：Standard numeric format strings | Microsoft Docs\n9.2.3 自定义字符串格式 可以为自己的类型创建自定义格式字符串。为此，需要实现接口 IFormattable。\n为实现自定义格式字符串，接口 IFormattable 实现了带两个参数的 ToString 重载：第一个参数是格式字符串，第二个参数是 IFormatProvider。这个参数用于基于区域值进行不同显示。\n比如类 Student ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Student : IFormattable { public string Name { get; set; } public uint Code { get; set; } string IFormattable.ToString(string format, IFormatProvider formatProvider) =\u0026gt; format switch { \u0026#34;N\u0026#34; =\u0026gt; Name, \u0026#34;C\u0026#34; =\u0026gt; Code.ToString(\u0026#34;0000\u0026#34;), _ =\u0026gt; throw new FormatException($\u0026#34;Invalid format string {format}\u0026#34;) }; } 主函数里：\n1 2 3 4 5 6 7 8 var student = new Student() { Name = \u0026#34;康萱琪\u0026#34;, Code = 21 }; Console.WriteLine($\u0026#34;{student:N}\u0026#34;); Console.WriteLine($\u0026#34;{student:C}\u0026#34;); 输出如下：\n1 2 3 \u0026gt; dotnet run 康萱琪 0021 正则表达式 这东西是特么魔法。\n正则表达式可以看作为在较大字符串中寻找子字符串的小型编程语言。\n符号 含义 示例 匹配的示例 ^ 输入文本的开头 ^B B，但只能是文本中的第一个字符 $ 输入文本的结尾 X$ S，但只能是文本中的最后一个字符 . 除了换行符意外的所有单个字符 i.ation isaction、itaction * 可以重复0次或多次的前导字符 ra*t rt、rat、raat 他妈的我不想写了\n9.4 - 字符串和 Span Span\u0026lt;T\u0026gt; 类型引用数组的一个切片，而不需要复制它的内容。\nReadOnlySpan\u0026lt;char\u0026gt; 从 AsSpan 拓展方法中返回。\n","date":"2021-05-03T14:31:30+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note7-string-and-regular/","title":"C#字符串和正则表达式 - C#笔记"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 运算符和类型强制转换 6 - 运算符和类型强制转换 6.1 - 运算符和类型转换 6.2 - 运算符 CSharp的运算符类似于C++和Java的运算符，但有一些区别。\n除了常见的算数运算符、逻辑运算符、比较运算符和赋值运算符等，CSharp还有\n类型信息运算符 sizeof 、 is 、 typeof 、 as 溢出异常控制运算符 checked 、 unchecked 标识符的名称运算符 nameof() 空合并运算符 ?? 空值条件运算符 ?. 、 ?[] 6.2.1 - 运算符的简化操作 自增(++)、自减(--)以及一些合并赋值(+=)运算符。\n当自增/自减运算符用于较长的表达式内部时，把运算符放在前面(++x)会在计算表达式之前递增 x 。换而言之，在增加了 x 的值后再带入表达式计算。而把运算符放在后面(x++)则反之。\n看个例子就行：\n1 2 3 4 5 6 var x = 0; Console.WriteLine(++x); // The output is \u0026#34;1\u0026#34; x = 0; Console.WriteLine(x++); // The output is \u0026#34;0\u0026#34; Console.WriteLine(x); // The output is \u0026#34;1\u0026#34; 看这三行输出。第一行是先把 x 进行了自增，在 x 传入 WriteLine 方法前就是 1 了。第二行代码是先将 x 的值 0 传给 WriteLine 方法，再将 x 的值自增为 1 。因此第三行代码输出为 1。\n条件运算符 适当的使用条件运算符可以使程序更简洁，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 获取数字为奇数或偶数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;数字\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;字符串奇数或偶数\u0026lt;/returns\u0026gt; public static string NumType(int input) =\u0026gt; input % 2 == 0 ? \u0026#34;偶数\u0026#34; : \u0026#34;奇数\u0026#34;; // 不使用条件运算符的版本 public static string NumType(int input) { if (input % 2 == 0) return \u0026#34;偶数\u0026#34;; return \u0026#34;奇数\u0026#34;; } 使用条件运算符明显短了很多。\nchecked 和 unchecked 运算符 如果把一个代码块标记为 checked ，CLR就会执行溢出检查，如果发生了溢出就抛出 OverflowException 异常。\n注意：unchecked 是默认行为。只有在 checked 标记的代码块里把几行不去检查的代码进行标记才使用。\nchecked 有性能损耗\nis 运算符 is 运算符可以检查对象是否与特定的类型兼容。短语“兼容”表示对象或者是该类型或者是派生自该类型，总之，可以安全的正常转换为该类型。\nCSharp7 扩展了具有类型匹配的 is 运算符，可以在类型的右边声明变量。如果 is 运算符返回 true ，则该变量被赋值为转换后的引用。\n1 2 3 4 5 6 7 8 9 10 11 12 public void PeopleReg(object o) { if (o is Person p) { // convert success Console.WriteLine($\u0026#34;Welcome {p.Name}\u0026#34;); } else { Console.WriteLine(\u0026#34;You are not a human!\u0026#34;); } } as 运算符 as 运算符用于执行引用类型的强制转换。如果要转换的类型与指定的类型兼容，转换就会成功，否则赋值为 null 。\nas 运算符允许在一步中进行安全的类型转换，不需要先使用 is 运算符测试类型，再执行转换。\nsizeof 运算符 使用 sizeof 运算符可以确定栈中值类型需要的长度（字节）。如果结构体只包含值类型，也可以使用 sizeof 运算符和结构。\n如果对复杂类型（而非基本类型）使用 sizeof 运算符，就要把代码放在 unsafe 块中。\ntypeof 运算符 typeof 运算符返回一个表示特定类型的 System.Type 对象。例如 typeof(string) 返回表示 System.String 类的对象。\nTip：在使用反射技术动态的查找对象的相关信息时，这个运算符很有用。\nnameof 运算符 接受一个符号、属性或方法，并返回其名称。比如：\n1 2 3 4 5 6 7 public void LikeArticle(Guid aid) { if (aid == null) { throw new ArgumentNullException(nameof(aid)); } } 还可以使用这个运算符得到属性的名称，也可以得到方法的名称。\n索引运算符 类似于访问数组元素，索引运算符可以是任何类型（比如字典中使用的索引运算符）：\n1 var title = dict[\u0026#34;title\u0026#34;]; 可空类型和运算符 引用类型可以为空，每次都用 if 来判断空太麻烦了，所以有了可空类型和运算符。\n可空的值类型使用 ? 来定义，比如：\n1 2 int? num = 6; num = null; 或者\n1 2 3 4 5 6 7 8 9 10 /// \u0026lt;summary\u0026gt; /// 获取文章列表 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;limit\u0026#34;\u0026gt;限制数\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;HTTP 200\u0026lt;/returns\u0026gt; [HttpGet] public async Task\u0026lt;ActionResult\u0026lt;ICollection\u0026lt;ArticleListDto\u0026gt;\u0026gt;\u0026gt; GetArticleList([FromQuery] int? limit) { } 注意：通常可空类型与一元或二元运算符一起使用时，如果其中一个操作数或两个操作数都是 null 则结果也为 null 。\n在比较可空类型时，有一个为 null 则结果就是 false 。\n空合并运算符 空合并运算符(??)提供了一种快捷的方式：如果运算符前的表达式不为 null 则返回前面的表达式，否则返回后面的：\n1 2 3 4 5 6 public void Test(int? num) { var numInt = num ?? -1; var input = Console.ReadLine(); var path = input ?? \u0026#34;C:/\u0026#34;; } 空值条件运算符 下面这段代码验证传递的参数 p 是否非空。如果它为空，方法就只是返回，而不会继续执行：\n1 2 3 4 5 6 7 public void ShowPerson(Person p) { if (p==null) return; var firstName = p.FirstName; // ... } （你看它多麻烦）\n使用空值条件运算符 ?. 访问 FirstName ，当 p 为空的时候就只返回 null ，而不继续执行表达式。\n1 2 3 4 public void ShowPerson(Person p) { var firstName = p?.FirstName; } 还可以把空值运算符用于数组：\n1 2 3 4 5 6 7 int[] arr = null; var val = arr?[0]; // 结合 ?? 运算符给它一个默认值： var valWithDefault = arr?[0] ?? -1; 5.2.2 - 运算符的优先级和关联性 基本运算符 \u0026gt; 一元运算符 \u0026gt; 乘除 \u0026gt; 加减 \u0026gt; 移位运算 \u0026gt; 关系运算 \u0026gt; 比较运算 \u0026gt; AND \u0026gt; XOR \u0026gt; OR \u0026gt; 逻辑与 \u0026gt; 逻辑或 \u0026gt; 空合并 \u0026gt; 三元条件运算符 \u0026gt; 赋值与lambda\n关联性的例外是赋值运算符，它们是右关联。\n一个重要的、可能误导右关联是三元条件运算符：\n1 2 3 a ? b : c ? d : e; // 等价 a ? b : (c ? d : e); 注意：在复杂的表达式中应避免运算符优先级来生成正确的结果。优先级一般符合正常的认知，当不利于人类理解时应该使用括号指定优先级。避免潜在的问题。\n6.3 - 使用二进制运算符 Convert.ToString 提供的一个重载带有两个 int 参数，其中第二个 int 值是 toBase 参数。使用这个方法可以传递值：\n2 - 二进制 8 - 八进制 10 - 十进制 16 - 十六进制 来格式化字符串。\n默认情况下，如果二进制以 0 开头，则这些 0 将会被忽略，而不会被打印出来。使用 PadLeft 方法来填充字符串中的这些 0 值。\n位与 AND：该位全是1的时候结果为1，否则为0，比如：\nA: 1001_0011_1001_1111\nB: 1100_0101_0011_1011\nR: 1000_0001_0001_1011\n位或 OR : 该位上任意操作数为1的时候结果为1，比如：\nA: 1001_0011_1001_1111\nB: 1100_0101_0011_1011\nR: 1101_0111_1011_1111\n位异或XOR: 该位上只有一操作数位1的时候结果为1，比如：\nA: 1001_0011_1001_1111\nB: 1100_0101_0011_1011\nR: 0101_0110_1010_0100\n位取反NOT:按位取反，比如：\nA: 1001_0011_1001_1111\nR: 0110_1100_0110_0000\n6.3.1 - 位的移动 向左移动 n 位等同于原来的数字乘以 2^n ，这比乘法运算符要快得多哦。\n6.3.2 - 有符号数和无符号数 使用二进制时要记住的意见重要的事情是，有符号类型的数字最左边一位表示符号。\n6.4 - 类型的安全性 6.4.1 - 类型转换 隐式转换 只要保证值不会发生任何变化，类型转换就可以自动进行。即：可以从“小范围”转到“大范围”的意思。\nTips：BigInteger 是包含任意大小的数字的结构体。可以从较小的类型中初始化它，传递一个大数字或者解析字符串。\n注意：\n只能从较小的整数类型隐式的转换为较大的整数类型，反过来不行。 可以将整数隐式的转换为浮点数，尽管可能会丢失精度。 可空类型不能隐式的转换为不可空类型。 显示转换 强制类型转换，使用 (type)identifer 的语法来转换。强制类型转换可能是不安全的，可能会引发溢出或者异常。\nCSharp提供了 checked 运算符，可以检查是否有算术溢出。当然它也检查了是否安全，如果不安全则会强制抛出一个异常。\nTips：谨慎的使用显示的类型强制转换，就可以把简单值类型的任何实例转换为几乎任何其它类型。\n如果需要在数字和字符串之间转换可以使用 .NET 类库提供的一些方法。\n数字 -\u0026gt; 字符串：\n1 2 var num = 8; var str = num.ToString(); 字符串 -\u0026gt; 数字：\n1 2 3 4 5 6 7 8 var str = \u0026#34;8\u0026#34;; var num = 0; if (int.TryParse(str, out num)) { // Successfully convert string to int. Console.WriteLine(num); // 8 } 如果使用了 Parse 方法，将会返回转换后的值，但是如果不能转换该方法就会抛出一个异常。\n6.4.2 - 装箱和拆箱 前面说过了：\n装箱：值类型 -\u0026gt; 引用类型，栈 -\u0026gt; 堆 拆箱：引用类型 -\u0026gt; 值类型，堆 -\u0026gt; 栈 装箱可以隐式的进行。\nTips: 拆箱时必须非常小心，确保能拆\u0026hellip;否则可能会引发一个异常\n6.5 - 比较对象的相等性 1. ReferenceEquals 方法 ReferenceEquals 是一个静态方法，其测试两个引用是否指向类的同一个实例，特别是两个引用是否包括内存中相同的地址。不能重写。\n但是，它认为 null 等于 null。\nTips：这个方法如果用于比较值类型则总返回 false 。\n2. Equals 虚方法 Equals 虚版本的也可以实现比较， System.Object 中实现的版本是比较引用。因为这是虚方法所以可以在自己的类中重写它，使用适合自己类的方法进行比较，比如值比较。\n如果希望类的实例用作字典的键，就需要重写这个方法。\n3. Equals 静态方法 作用相同，不同的是静态方法有两个参数，它的作用是比较这两个参数（引用）的相等性。如果有一个参数为 null 则返回 false 。\n4. == 比较运算符 最好将它看作严格的值比较和严格的引用比较中间的玩意，大多数情况下，如果两边是引用类型的话是引用比较。\n不过字符串类型通过运算符重载实现了通过比较运算符进行值比较，更符合人的直觉。\n在使用上述几种方法的时候，通常来说使用 ==，需要比较引用的时候使用 ReferenceEquals 方法。需要复杂类型的自定义比较时，重写 Equals 方法，并且，建议使用这个方法重载运算符 ==，以便于更方便的比较。\n6.5.2 - 比较值类型的相等性 在比较值类型的相等性时，采用与引用类型相同的规则：ReferenceEquals 用于比较引用，Equals 用于比较值，比较运算符可以看作一个中间项。\n如果调用 sA.Equals(sB) ，其中 sA 和 sB 是某个结构的实例，则根据它俩是否存在所有的字段并且包含相同的值返回 true 或者 false。\n另一方面，在默认情况下，使用 == 比较结构会无法编译，除非自己重载了比较运算符。\n尽管 System.ValueType 提供的 Equals 默认重写版本肯定足以应付大部分自定义的结构，但是仍然可以重写方法以适用于自己的结构、提高性能。另外，如果值类型包含作为字段的引用类型，就需要重写 Equals 方法，默认的版本仅比较它们的地址。\n6.6 - 运算符重载 假如有个 Matrix 类，实现了矩阵相加、相乘的一些方法。但是直接调用看着太不舒服了，使用更利于理解的运算符才是该干的。\n通过运算符重载可以告诉编译器，+ 和 * 分别对 Matrix 对象执行什么操作，以便编写类似于上面的代码。\n事实证明，在许多情况下，重载运算符利于生成可读性更高、更直观的代码。\n6.6.1 - 运算符的工作方式 编译器会看前后的操作数的类型，如果是相同的基础类型，则按照规定的操作进行。 如果是不同的，则看是否能够隐式转换并选择合适的路径进行转换。 如果是用户自定义的类型，则去查找重载，找到就走重载，找不到就报错。 6.6.2 - 运算符重载的示例：Vector 结构 Vector 结构表示一个三维的数学矢量。为了简单，就算它是三个 double 类型数字的集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public struct Vector { public Vector(double x, double y, double z) { X = x; Y = y; Z = z; } public Vector(Vector v) { X = v.X; Y = v.Y; Z = v.Z; } public double X { get; set; } public double Y { get; set; } public double Z { get; set; } public override string ToString() =\u0026gt; $\u0026#34;( {X}, {Y}, {Z} )\u0026#34;; } 运算符重载的声明方式与静态方法基本相同，但 operator 关键字告诉编译器这是运算符重载，它后面紧跟一个运算符，比如 + ：\n1 2 public static Vector operator +(Vector left, Vector right) =\u0026gt; new Vector(left.X + right.X, left.Y + right.Y, left.Z + right.Z); 注意：CSharp要求所有的运算符重载都声明为 public 和 static ，这表示它们与类或结构相关联而不是某个特定的实例。所以运算符重载的代码体不能访问非静态类成员，也不能访问 this 标识符。\n有一个运算符重载，其参数依次是一个 double 和一个 Vector ，但是编译器不能交换参数的顺序，所以对于这种交换顺序不影响的运算，需要写两个重载。\n虽然 += 一般算作一个运算符，但实际上它对应的操作分为两步：相加和赋值。但是CSharp是不允许重载 = 运算符的，不过如果重载了 + 运算符，编译器会自动重载 += 运算符。\n6.6.3 - 比较运算符的重载 6个比较运算符分为三对：\n== 和 != \u0026gt; 和 \u0026lt; \u0026gt;= 和 \u0026lt;= CSharp语言要求成对重载比较运算符，也就是你重载了 \u0026gt;= 也必须重载 \u0026lt;= ，否则就会产生编译器错误。\nTips：当比较时，需要考虑：如果有嵌入的类，是比较嵌入的类的引用（浅度比较）还是应该比较对象的值是否相等（深度比较）？\n注意：不要通过调用从 System.Object 中继承的 Equals 方法的实例版本来重载比较运算符，如果这么做在双等号左值为 null 时（例如 objA == objB）系统会去调用 null.Equals(objB) ，这样会引发一个异常。采用其他方法（重写 Equals 方法以比较）比较安全。\n还需要重写 Equals 方法和 GetHashCode 方法。这些方法总是应该在重载 == 进行重写，否则编译器会报错：\n1 2 3 4 5 public override bool Equals(object obj) =\u0026gt; obj is Vector v ? this == v : false; public override int GetHashCode() =\u0026gt; X.GetHashCode() ^ (Y.GetHashCode() ^ Z.GetHashCode()); 散列代码的实现应比较快速，且总对相同的对象返回相同的值，因此对几个属性算散列是比较的河里的。\n6.6.4 - 可以重载的运算符 不同于C++，并不是所有的运算符可以重载。\n可以重载的运算符有：\n算术一元、二元运算符 按位二元运算符 按位一元运算符：true 和 false 运算符必须成对重载 比较运算符：必须成对重载 赋值运算符：不能显示重载，重载单个运算符就重载了 索引运算符：不能直接重载索引运算符，索引器成员类型允许类和结构上支持 类型强制转换运算符：不能直接重载，可以用用户定义的类型强制转换 6.7 - 实现自定义的索引运算符 自定义索引器不能使用运算符重载语法来实现，但是它们可以用与属性非常相似的语法来实现。\n举个 PersonCollection 类的栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class PersonCollection { private Person[] _people; // ctor public PersonCollection(params Person[] people) =\u0026gt; _people = people.ToArray(); // indexer public Person this[int index] { get =\u0026gt; _people[index]; set =\u0026gt; _people[index] = value; } } 为了允许索引器语法访问 PersonCollection 并返回 Person 对象，可以创建一个索引器。索引器看起来非常类似于属性。不同之处是名称，指定索引器必须要使用 this 关键字，中括号中是索引的类型。\n对于索引器，不仅能用 int 类型进行索引，任何类型都是有效的。\n6.8 用户定义的类型强制转换 CSharp允许定义用户自己的数据类型，因此，需要去支持这些类型的转换。如果知道无论在源变量中存储什么值，类型强制转换总是安全的，就可以把它定义为隐式强制转换。然而，如果某些数值可能会出错，如丢失什么数据或抛出异常，就应该把数据类型转换定义为显示强制转换。\n隐式转换关键字：implicit 显示转换关键字：explicit 与其他运算符重载一样，类型强制必须同时声明为 public 和 static 。\n6.8.1 - 实现用户定义的类型强制转换 定义隐式的强制类型转换使用 implicit 关键字，假如我们要转 Currency 类为 float ：\n1 2 public static implicit operate float (Currency value) =\u0026gt; value.Dollars + (value.Cents / 100.0f); 把 float 转换成 Currency 不总是成功的，应该定义一个强制转换：\n1 2 3 4 5 6 public static explicit operate Currency (float value) { uint dollars = (uint)value; ushort cents = (ushort)((value - dollars) * 100); return new Currency(dollars, cents); } Tips：如果类型强制转换用于把 float 值转换为 int ，计算机会截取多余的数字，而不是执行四舍五入。\nSystem.Convert 对象包含大量的静态方法来完成各种数字转换，在使用 System.Covert 类的方法时会造成额外的性能损失，所以只应在需要的时候使用它们。\nSystem.Convert 类的方法还执行它们自己的溢出检查，因此，不需要把对它们的调用放在 checked 环境下面。\n1. 类之间的类型强制转换 注意：派生类之间不能相互转换。\nCSharp要求把类型强制转换的定义放在源类或目标类的内部。\n2. 基类和派生类之间的类型强制转换 在进行强制类型转换时，会检查被引用的对象。因为基类原则上可以引用一个派生类的实例，所以这个对象可能是要强制转换的派生类的一个实例。如果是这样，强制转换就会成功。如果被引用的实例不是派生自基类的一个实例，强制转换就会抛出异常。\n编译器已经提供了对于基类和派生类之间的强制类型转换。如果要进行的转换是合法的，它们也仅仅是更改了类型，而引用没有变。这些强制类型转换与用户定义的强制类型转换不同。在上面的例子中，将 float 强制转换为 Currency 还新定义并初始化了一个实例。\n3. 装箱和拆箱类型的强制类型转换 从值类型到 object 的强制转换总是一种隐式的强制转换，因为这种转换是从派生类到基类的的转换。\n在执行上述转换（装箱）时，值类型的变量的值被复制到堆上，放在一个装箱的对象中，并且将装箱后的变量的引用设置为那个对象。\n拆箱是一种显示的强制类型转换，因为如果要强制转换的对象不是正确的类型就会抛出一个异常。\n在使用装箱和拆箱时，这两个过程都把数据复制到新装箱或新拆箱的休想上，理解这一点非常重要。因此，对装箱的操作不会影响源值类型变量的值。\n6.8.2 多重类型强制转换 如果在进行要求的数据类型转换时没有可用的直接强制类型转换方法，则编译器会自动寻找一种转换方式，将多种转换合并起来以便于进行强制类型转换。\nTips：如果希望类利于使用，就应该确保所有的强制类型转换都按照一种互相兼容的方式进行，即这些转换直观上应得到相同的结果。\n最好设计自己的强制类型转换，让所有的转换路线都得到相同的、正确的结果，此时编译器去选择哪条路径就不重要了。\n","date":"2021-05-01T20:42:20+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note4-operators-and-typecasts/","title":"C#的运算符和类型强制转换 - C#笔记"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 CSharp 泛型 5 - 泛型 5.1 - 泛型概述 有了泛型，就可以创建独立于被包含类型的类和方法。比如我希望创建一个链表 LinkedList 类，但是存储在 Node.value 中的可能是 int 类型也可能是其它如 double 等类型。这样我们就要为每种类型写一个 LinkedList 类，但是大部分实现都是一样的（比如插入、删除等，这些操作和是什么类型几乎没有关系）。所以才有了泛型来解决类似于这样的问题。\n另一个减少代码量的是 Object 类，但是使用这种类型转换是不安全的，比如我创建了一个 LinkedList 类，其中有个方法是 Add(Object input) ，我希望这是一个 int 链表，但是使用者即使传入 string 也不会报错，但是在使用的时候很可能引发运行时抛出异常。\n5.1.1 - 性能 值类型存储在栈(Stack)上，引用类型存储在堆(Heap)上。CSharp类是引用类型，结构是值类型。\n从值类型转换为引用类型称为装箱，装箱是自动进行（隐式转换）的。 而从引用类型转换为值类型为拆箱，拆箱必须强制转换（而且如果类型有问题会抛出异常）。 ValueType ===(Box)===\u0026gt; ReferenceType\nValueType \u0026lt;==(UnBox)== ReferenceType\n另外，这种操作性能损失比较大，遍历多项的时候更加明显。\nList\u0026lt;T\u0026gt; 类在使用时定义传入的对象的类型，如果泛型 T 定义为 int ，则它在JIT编译器动态生成的类中使用，不再进行装箱和拆箱操作。大幅度提高了性能。\n5.1.2 - 类型安全 在泛型类中，T 定义了允许使用的类型，只能使用限定的类，否则编译器会报错。而使用拆箱时不能确定对象是否为指定类型，容易引起程序崩溃或奇奇怪怪的bug。\n5.1.3 - 二进制代码的重用 泛型类可以定义一次，并且可以用许多不同的类型实例化。不需要像 C++ 模板那样访问源代码。\n5.1.4 - 代码的扩展 5.1.5 - 命名约定 泛型类型的名称用字母 \u0026ldquo;T\u0026rdquo; 作为前缀。 如果没有特殊的要求，泛型类可以用任意类，并且如果只使用了一个泛型类型则通常将其命名为 T，比如 List\u0026lt;T\u0026gt; 。 如果泛型有特殊的要求（比如它要求该类型必须继承自某个接口或派生自某个基类），或者使用了两个或多个泛型，就应该给泛型类型写名称，比如：Convert\u0026lt;TInput, TOutput\u0026gt; 。 5.2 - 创建泛型类 1 2 3 4 5 6 7 public class LinkedListNode\u0026lt;T\u0026gt; { public LinkedListNode(T value) =\u0026gt; Value = value; public T Value { get; } public LinkedListNode\u0026lt;T\u0026gt; Next { get; internal set; } public LinkedListNode\u0026lt;T\u0026gt; Prev { get; internal set; } } 另外，通过实现 GetEnumerator 方法，可以用 foreach 语句遍历链表。 GetEnumerator 方法使用 yield 语句创建一个枚举器类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class LinkedList\u0026lt;T\u0026gt; : IEnumerable\u0026lt;T\u0026gt; { public LinkedListNode\u0026lt;T\u0026gt; First { get; } public LinkedListNode\u0026lt;T\u0026gt; Last { get; } public LinkedListNode\u0026lt;T\u0026gt; Add(T node) { var newNode = new LinkedList\u0026lt;T\u0026gt;(node); if (First == null) { First = newNode; Last = First; } else { LinkedListNode\u0026lt;T\u0026gt; previous = Last; Last.Next = newNode; Last = newNode; Last.Prev = previous; } return newNode; } public IEnumerator\u0026lt;T\u0026gt; GetEnumerator() { LinkedListNode\u0026lt;T\u0026gt; current = First; while (current != null) { // 使用yield返回枚举的值 yield return current.value; // 迭代 current = current.Next; } } IEnumerator IEnumerator.GetEnumerator =\u0026gt; GetEnumerator(); } 5.3 - 泛型类的功能 5.3.1 - 默认值 通过 default 关键字，将 null 赋予引用类型，将 0 赋予值类型。\n1 2 3 4 5 public T GetDocument() { T doc = default; // ... } 5.3.2 - 约束 假如在上述例子中，我只想要接受实现了 IDocument 接口的泛型。\n为了在泛型类型的名称中指定该要求，将例子中的 T 改为 TDocument ，where 子句指定了实现 IDocument 接口的要求：\n1 2 3 4 5 public class DocumentManager\u0026lt;TDocument\u0026gt; where TDocument : IDocument { } 注意：给泛型类添加约束的时候，最好包含泛型参数名称的一些信息。对编译器而言这不重要，但是它更可读。\n5.3.3 - 继承 泛型类可以派生自泛型基类：\n1 2 3 4 public class LinkedList\u0026lt;T\u0026gt;: IEnumerable\u0026lt;T\u0026gt; { } 于是，派生类可以是泛型类或非泛型类。例如：可以定义一个抽象的泛型基类，它在派生类中用一个具体的类实现。\n5.3.4 - 静态成员 泛型类的静态成员只能在类的一个实例中共享。\n5.4 - 泛型接口 使用泛型可以定义接口，在接口中定义的方法可以带泛型参数。\n5.4.1 - 协变和抗变 淦，这部分有点搞不懂欸（ 以后再做研究，这部分内容可参考性不高，可能存在错误。目前人是差不多理解了，说不出来\u0026hellip;\n协变：返回中，不能使用子类接收返回的父类，用父类接收返回的子类可以 抗变：传参中，子类传入需要父类的地方 （那他妈不都是子类-\u0026gt;父类嘛？）\n假如有 Animal 类和 Dog 子类。假设我定义了一个泛型 Foo\u0026lt;Animal\u0026gt; 那么它实现了协变，能去接受 Dog 类的实例。即协变为接受从子类转换为父类。这种与原始类型转换方向（类 -\u0026gt; Object 基类）相同的可变性就称作协变。\n反之，泛型类或方法的返回将 Dog 作为 Animal 是抗变。\n5.4.2 - 泛型接口的协变 如果泛型接口用 out 关键字标注，那么它就是协变的。\n比如，接口 IIndex 是协变的，从一个只读索引器中返回这个类型：\n1 2 3 4 5 public interface IIndex\u0026lt;out T\u0026gt; { T this [int index] { get; } int Count { get; } } 不使用 out 或者 in 关键字，可以把类型定义为不变的。\n实现了这个接口（ MyClass: IIndex\u0026lt;Dog\u0026gt; ）的类可以把返回值赋给 IIndex\u0026lt;Dog\u0026gt; ，也可以赋值给 IIndex\u0026lt;Animal\u0026gt;。\n1 2 IIndex\u0026lt;Rectangle\u0026gt; rectangles = /* codes ... */; IIndex\u0026lt;Shape\u0026gt; shapes = rectangles; 5.4.2 - 泛型接口的抗变 如果泛型类型用 in 关键字标记，泛型接口就是抗变的：\n1 2 3 4 5 6 7 8 9 public interface IDisplay\u0026lt;in T\u0026gt; { // codes } public class ShapeDisplay : IDisplay\u0026lt;Shape\u0026gt; { // codes } 1 2 3 4 IDisplay\u0026lt;Shape\u0026gt; shapeDisplay = new ShapeDisplay(); IDisplay\u0026lt;Rectangle\u0026gt; rectDisplay = shapeDisplay; // ... 抗变更上面的协变看起来效果是相反的（但是它怎么安全的做到这一点的啊？）\n5.5 - 泛型结构 与类相似，结构也可以是泛型的，比如 Nullable\u0026lt;T\u0026gt;。它们非常类似于泛型类，但是没有继承特性。\n把 Nullable\u0026lt;T\u0026gt; 类型强制转换成 T 类型的运算符重载是显示定义的，因为当 hasValue 为 false 时，它会抛出一个异常。强制转换 T 为 Nullable\u0026lt;T\u0026gt; 类型的运算符重载定义为隐式的，因为转换总是成功的。\n因为可空类型使用的非常频繁，CSharp有一个 ? 运算符，用它来定义可空类型的变量，比如：\n1 int? num = null; 注意：在运算可空类型的时候，如果两个可空变量中任何一个值是 null 那么它们的和就是 null\n非可空类型总是可以隐式转换为对应的可空类型。从可空类型转换到对应的非可空类型时需要强制转换，可能会引发异常，因此：\n1 2 3 int? num = 18; int numInt = num ?? -1; 可以使用该类合并运算符以不进行显示转换。\n5.6 - 泛型方法 除了定义泛型类以外还可以泛型方法。在泛型中，泛型类型用方法声明来定义，泛型方法可以在非泛型类中定义：\n1 2 3 4 5 6 void Span\u0026lt;T\u0026gt;(ref T x, ref T y) { T temp = x; x = y; y = temp; } CSharp编译器会通过 Swap 方法来获取参数的类型，因此并不需要把泛型类型传过去。只需要 Swap(3, 6) 即可。\n5.6.1 - 泛型方法示例 5.6.2 - 带约束的泛型方法 类似于带约束的泛型类，使用 where 子句进行约束。\n5.6.3 - 带委托的泛型方法 可以将泛型类型传给参数中的委托中的泛型类型：\n1 2 3 4 pubic static T2 Accumulate\u0026lt;T1, T2\u0026gt;(IEnumerable\u0026lt;T1\u0026gt; source, Func\u0026lt;T1, T2, T2\u0026gt; action) { } 参数表中参数类的泛型将会使用调用时候指定的泛型。\n5.6.4 泛型方法规范 泛型方法可以重载，为特定的类型定义规范。这也适用于带泛型参数的方法。\n注意：所调用的方法是在编译期间而不是运行期间定义的。\n","date":"2021-04-29T12:40:44+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note3-generics-type/","title":"C#中的泛型 - C#笔记"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 CSharp 面向对象编程 系统学习CSharp笔记，本来也想写在基础部分来着，但是上一篇博客太长了，想想还是拆出来写吧。 包括CSharp的 对象和类、继承 两章\n3 - 对象和类型 3.1 - 创建和使用类 3.2 - 类和结构 结构不同于类，结构是值类型而类是引用类型，结构不需要在堆上分配空间，它们通常存储在栈上，另外，结构不支持继承。\n较小的数据类型使用结构可以提升性能。\n3.3 - 类 类可以包含静态成员或者实例成员。静态成员属于类而实例成员属于对象。\n3.3.1 - 字段(Field) 字段是与类相关的变量，前面说过，字段通常是私有的。最好不要把它设置为 public ，除非你有足够的理由，因为字段应该去由属性来设置，而不是直接暴露给外部。\n3.3.2 - 只读字段 带有 readonly 修饰符的字段只能在构造函数中分配它的值。它与 const 修饰符不同，它不需要在编译的时候就指定值。\n3.3.3 - 属性(property) 属性的概念是：\n它是一个方法或一对方法，在客户端看来，它们是一个字段。\n也就是说，在类的内部，属性是设置私有字段的方法。而外部看来，它们是字段，比如：\n具有表达式体的树形访问器 1 2 3 4 5 6 7 private string _name; public string Name { get =\u0026gt; _name; set =\u0026gt; _name = value; } 自动实现的属性 当然，上面的代码可以使用自动实现的属性替换为，也可以用属性初始化器来初始化（第二行代码）\n1 2 3 public string Name { get; set; } public Guid Uid { get; set; } = new Guid(); 注意看第一段代码的命名规范：本来 Microsoft 那边的规范是使用小写字母命名私有字段，但是 .NET Core 团队转向用下划线加小写字母来命名，这样显然更容易区分。\n属性的访问修饰符 CSharp允许给属性的 get 和 set 访问器分别设置不同的修饰符。\n注意：在 get 和 set 访问器中必须有一个具备属性的访问级别。\n只读属性 在属性定义中省略 set 访问器，就可以创建只读属性。\n表达式体属性 在CSharp6之后，用于创建只读属性，类似于表达式体方法。\n比如说：\n1 2 3 public string FirstName { get; set; } public string LastName { get; set; } public string FullName =\u0026gt; $\u0026#34;{FirstName} {LastName}\u0026#34; 不可变的类型 如果对象没有任何可以改变的成员，只有只读成员，它就是一个不可变的类型。\n3.3.4 - 匿名类 var 与 new 关键字一起使用时，可以创建匿名类型。匿名类型只是一个继承自 Object 且没有名称的类。该类的定义从初始化器中推断，类似于隐式类型化的变量，比如：\n1 2 3 4 5 6 7 var result = new { code = 200, message = \u0026#34;OK\u0026#34;, server = \u0026#34;AspNetCore\u0026#34;, data = null, }; 如果创建另外一个匿名类，但是它们的所有属性都匹配则它们为同一个类型，可以赋值。\n3.3.5 - 方法 注意：正式的CSharp术语区分函数和方法。“函数”成员不仅包含方法，也包含类或结构的一些非数据成员，比如索引器、运算符、构造函数和析构函数，甚至还有属性。字段、常量和事件才是数据成员。\n方法的声明 说过了\n表达式体方法 一行解决问题：\n1 2 public static bool hasValue() =\u0026gt; data == null; 调用方法 通过 类名.方法名() 来调用静态方法，静态方法属于类。\n对于非静态来说，它们是属于某个对象（特定实例）的，因此需要先将其类实例化，再用 对象.方法() 来调用。\n方法的重载 CSharp支持方法重载——方法的几个版本有不同的签名，即同名的方法可以接受不同的参数。\n1 2 3 4 5 6 7 8 9 10 // method1 string FindName(Guid id) =\u0026gt; members.FirstOrDefault().Where(it =\u0026gt; id.Id == id)?.Name; // method2 string FindName(string id) { var guid = Guid.Parse(id); return FindName(guid); } 不仅参数类型可以不同，参数个数也可以不同。\n命名的参数 任何方法都可以使用命名的参数，只需要写一个变量名在前面，然后就不管顺序传入指定的参数了。\n比如：\n1 2 3 public static void TestMethod(int n, int opt1 = 0, int opt2 = 16); TestMethod(0, opt2: 4); 个数可变的参数 声明数组类型的参数（比如 int 类型），添加 params 关键字，就可以使用任意数量的 int 类型的参数调用该方法。\n1 2 3 4 5 6 7 public static void PrintEach(params int[] inputs) { foreach(var item in inputs) { Console.WriteLine(item); } } 调用该方法的时候可以使用任意数量个 int 类型的参数哦，比如：\n1 2 PrintEach(0); PrintEach(1, 1, 4, 5, 1, 4); 3.3.6 - 构造函数(constructor/ctor) 声明一个与类同名的方法，但是不需要写返回类型（连 void 都不写），比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class UsersServices { private readonly IOptions _options; private readonly IUsersRepo _userRepo; // constructor public UsersServices(IOptions options, IUsersRepo usersRepo) { _options = options ?? throw new ArgumentNullException(nameof(options)); _usersRepo = usersRepo ?? throw new ArgumentNullException(nameof(usersRepo)); } } 如果不写构造函数的话，编译器会默认生成一个啥也没有的构造函数。如果写了带参数的构造函数则不会默认生成默认的（没有参数什么也不做）构造函数。构造函数可以重载。\n可以包含 static 修饰符的情况：\n类仅用于某些静态成员或属性的容器，因此永远不会实例化它。 希望类仅通过某个静态成员函数来实例化 表达式体和构造函数 如果CTOR由一个表达式构成，就直接用表达式体实现：\n1 MyClass(IOptions option) =\u0026gt; _option = option; 从构造函数中调用其他构造函数 可以调用其它的构造函数，复用代码。CSharp有一个特殊的语法，成为构造函数初始化器，可以实现此目的：\n1 2 3 4 5 6 7 8 9 10 11 12 class Car { public Car(string description): this(description, 5) { } public Car(string description, int num) { // codes... } } 也可以包含对基类的构造函数的调用（语法和上面大致相同，使用 base 代替 this）\n静态构造函数 给类编写无参数的静态构造函数。这种构造函数只执行一次。\n3.4 - 结构 有时仅需要一个小的数据结构。此时，类提供的功能多于我们需要的功能，由于性能原因，最好使用结构。\n结构相比于类来说：\n不支持继承 如果没有默认的构造函数则所有值被初始化为默认值 可以指定字段如何在内存中布局 因为结构实际上是把数据项组合在一起，所以有时候大多数或者全部字段都声明为 public\n3.4.1 - 结构是值类型 对于结构来说，new 只是调用构造函数，初始化所有字段。\n结构遵循其它数据类型都遵循的规则：在使用所有元素都必须进行初始化，调用 new 关键字就全部初始化了。\n但当把结构作为参数传递给方法的时候应该把它作为 ref 参数，以免性能损失。\n3.4.2 - 只读结构 使用CSharp7.2时， readonly 修饰符可以应用于结构，因此编译器保证结构体的不变性。\n3.4.3 - 结构和继承 结构不是为继承设计的\n要比较结构值，最好实现结构 IEquatable\u0026lt;T\u0026gt; 。\n3.4.4 - 结构的构造函数 默认构造函数把数值字段都初始化为 0，且总是隐式的给出。不能为结构创建定制的默认CTOR。\n3.4.5 - ref 结构 使用 ref 关键字将结构体分配到堆上。\n3.5 - 按值和按引用传递参数 为了避免在更改成员时类和结构之间的不同行为上出现这种混淆，最好将结构设置为不可变的。\n3.5.1 - ref 参数 在定义和调用方法的参数前加上 ref 修饰符，使用引用。\n3.5.2 - out 参数 处理类型错误的数据，可以使用 TryParse 方法。无论解析成功与否，都返回一个 bool 类型，解析成功的结果使用 out 返回到另外一个参数。\n调用此方法时，变量不需要预先初始化，而是在方法中初始化变量，在调用方法的时候需要提供 out 修饰符，比如：\n1 2 3 4 if (int.TryParse(inputStr, out var result)) { Console.WriteLine(\u0026#34;SUCCESS\u0026#34;); } 3.5.3- in 参数 in 参数保证发送到方法中的数据不会更改，它将参数设置为只读变量。相比于只使用 ref 来说，显然使用 in 修饰符更安全一些。\n使用值类型和 in 修饰符，不仅有助于确保不更改内存，编译器还可以创建更好的优化代码。\n3.6 - 可空类型 可空类型是可以为空( null )的值类型，用于解决从数据库映射到代码或者类似这种值类型的可能为空的情况。\n可空类型只需要在类型的后面添加“?”。\n值类型隐式转换为可空类型，可空类型需要强制转换为值类型，如果强制转换的过程中可空类型变量为 null 则会引发一个异常。更好的解决方案是使用可空类型的 HasValue 和 Value 属性。\n可以使用：\n1 int idInt = id.HasValue ? id.Value : -1; 当然，使用合并运算符更好：\n1 int idInt = id ?? -1; 3.7 - 枚举类型 枚举是一个值类型，包含一组命名的常量。\n默认情况下，枚举的类型是 int ，也可以通过 :[type] 指定为其它整数类型，比如：\n1 2 3 4 public enum Color : short { } 还可以使用枚举类型把多个选项分配给一个变量，分配给常量的值必须是不同的位（使用位与来把多个枚举常量赋值给变量），并且加上 Flags 属性 ，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Flags] public enum DaysOfWeek { Monday = 0b_0000_0000_0000_0001, Tuesday = 0b_0000_0000_0000_0010, Wednesday = 0b_0000_0000_00000_0100, Thursday = 0b_0000_0000_0000_1000, Friday = 0b_0000_0000_0001_0000, Saturday = 0b_0000_0000_0010_0000, Sunday = 0b_0000_0000_0100_0000, Weekend = Saturday | Sunday, Workday = 0b_0000_0000_0001_1111, AllWeek = Workday | Weekend } 枚举还提供了方法来解析字符串：\n1 2 3 4 if (Enum.TryParse\u0026lt;Color\u0026gt;(\u0026#34;Red\u0026#34;, out var red)) { } Enum.GetNames 方法返回一个包含所有枚举名的字符串数组。\n1 2 3 4 5 foreach (var day in Enum.GetNames(typeof(Color))) { } 为了获取枚举的值，可以使用 Enum.GetValues，返回枚举值的一个数组。\n3.8 - 部分类 partial 关键字允许把类、结构、方法或接口放在多个文件中。\n注意：尽管 partial 关键字很容易创建跨文件的庞大的类，但是它并不应该这么用，如果类过大还是应该拆分的。\n部分类中可以用 partial 关键字声明一个方法，然后在其它文件中实现（实现不需要加这个关键字），比如：\n1 public partial void PartMethod(); 在另一个文件中：\n1 2 3 4 public void PartMethod() { // DO SOME THING } 部分方法必须是 void 类型，否则编译器在没有实现代码的情况下不能将其删除。\n3.9 - 扩展方法 扩展方法是给对象添加功能的另一个选项，在不能使用继承时，也可能使用这个选项（例如类是密封的）。\n扩展方法的定义在参数表里是这样的： (this [类型] [标识符]) 也就是普通方法的参数表类型前面加上 this。会作为第一个参数类型的扩展方法。\n1 2 3 4 public static class StringExt { public static int GetWordCount(this string s) =\u0026gt; s.Split().Length; } 3.10 - Object 类 所有的 .NET 类都继承于 System.Object 。Object 类提供了一些方法：\n方法 作用 ToString() 对象的字符串表示，可以重写 GetHashCode() 在散列中的对象可以使用这个方法 Equals() 比较对象的相等性，有重载可以重写 Finalize() 析构函数，引用被GC的时候调用 GetType() 返回一个实例提供对象所属类的信息 MemeberwiseClone 浅表复制对象并返回副本的引用 4 - 继承 4.1 - 面向对象 面向对象的三个最重要的概念是继承、封装和多态（老生常谈了）\n4.2 - 继承的类型 单重继承： 一个类派可以生自一个基类，CSharp采用这种继承 多重继承： 一个类派生自多个基类，C++用，CSharp不允许这种继承，但是可以继承自多个接口 多层继承： 一个基类的派生类可以继续被继承，CSharp允许这种继承 接口继承： 定义了接口的继承，CSharp允许并且允许多重接口继承 4.2.1 - 多重继承 C++等支持多重继承，但是会增加代码复杂度以及额外开销，（并且我觉得不是很优雅）。所以CSharp不支持这种继承。但是同时，CSharp允许继承自多个接口。\n4.2.2 - 结构和类 前面说过，结构不是为继承而设计的，但是\n结构总是派生自 System.ValueType ，它们还可以派生自多个接口。 类总是派生自 System.Object 或者用户选择的另一个类，它们还可以派生自多个接口。 4.3 - 实现继承 声明类派生自另一个类（比如类 A 派生自 B），使用以下的语法：\n1 2 3 4 class A : B { } 如果类也派生自接口，则用逗号分隔多个接口。\n注意：如果派生类同时派生自类和多个接口，类放在最前面。\n4.3.1 - 虚方法 把一个基类方法声明为 virtual ，就可以在任何派生类中重写(override)该方法：\n1 2 3 4 5 public class Shape { public virtual void Draw() =\u0026gt; Console.WriteLine($\u0026#34;Shape with {Position} and {Size}\u0026#34;); } 也可以把属性声明为 virtual 。对于虚属性或重写属性，语法和非虚属性相同，但要添加关键字 virtual。\nCSharp中的虚函数概念与标准的 OOP 的概念相同：可以在派生类中重写虚函数。在调用方法的时候会调用该类对象的合适方法。不同于Jvav，在CSharp中函数在默认情况下不是虚拟的，但可以显示的声明为 virtual。\nCSharp要求在派生类中重写另一个函数时，使用 override关键字显示声明：\n1 2 3 4 5 public class Rectangle : Shape { public override void Draw() =\u0026gt; Console.WriteLine($\u0026#34;Rectangle with {Position} and {Size}\u0026#34;); } 可以重写 Object 类的某些方法，比如 ToString 和 Equals。\n注意：成员字段和静态函数都不能声明为 virtual ，因为这个概念只对类中的实例函数有效。\n4.3.2 - 多态性 拿上面的例子来说，尽管方法声明为接收一个 Shape 对象，但是任何派生自 Shape 的类型都可以传递给这个方法。因为派生自 Shape 的类拥有 Shape 的所有内容。\n4.3.3 - 隐藏方法 如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为 virtual 和 override ，派生类方法就会隐藏于基类方法。\n注意：new 方法修饰符 不应该用于 故意隐藏基类的成员。它的主要目的是处理版本冲突。\n4.3.4 - 调用方法的基类版本 为了添加派生类的功能，可以使用 base 关键字调用基类方法，语法为 base.\u0026lt;MethodName\u0026gt;\n4.3.5 - 抽象类和抽象方法 CSharp允许把类声明为 abstract 。抽象类不能实例化，而抽象方法不能直接实现，必须在非抽象的派生类中重写。\n4.3.6 - 密封类和密封方法 如果不应创建派生自某个自定义类的类，该自定义类就该密封。给类添加 sealed 修饰符，就不允许创建该类的子类。\n4.3.7 - 派生类的构造函数 CTOR 总是按照层次结构的顺序调用：先调用 System.Object 类的构造函数，再按照层次结构由上向下运行，直到到达编译器要实例化的类为止。\n把初始化代码放在 CTOR 代码块内太迟了，所以采用 base 关键字传参：\n1 2 3 4 5 6 7 public class Student : Human { public Student(Sex sex) : base(sex) { } } 4.4 - 修饰符 4.4.1 - 访问修饰符 修饰符 应用于 说明 public 所有的类或成员 任何代码都可访问 protected 类型和内嵌类型的所有成员 只有派生的类能够访问 internal 所有的类或成员 只有在包含它的程序集才能访问 private 类型和内嵌类型的所有成员 只能在它所属的类中访问 protected internal 同上 protected OR internal private protected 同上 private AND protected 注意： public、protected 和 private 是逻辑访问修饰符，而 internal 是“物理”的，它表示程序集的边界。\n4.4.2 - 其他修饰符 |修饰符|应用于| 说明 | | new|函数成员|隐藏继承的成员| |static|所有成员|静态| |virtual|仅成员函数|虚函数| |abstract|同上|定义签名，没有实现| |override|同上|重写| |sealed|类、方法和属性|封闭，不可被继承|\n4.5 - 接口 声明接口在语法上与声明类完全相同，只是 class 换成了 interface，但是接口中不允许提供任何成员的实现。\n因为接口的成员总是抽象的，所以接口不需要 abstract 修饰符。\n4.5.1 - 定义和实现接口 接口名称通常以 I 开头，以便知道这是一个接口。\n让想实现接口的类继承于接口，然后去实现接口里面定义的成员即可。比如说 AccountService 派生于 IAccountService ，表示它获得了 IAccountService 中的所有成员，但接口实际上并不实现其方法，所以 AccountService 中必须提供其实现。如果缺少代码编译器将产生一个错误。\n4.5.1 - 派生的接口 接口可以彼此继承，其方式与类的继承相同。\n4.6 is 和 as 运算符 两个与继承有关的重要运算符：is 和 as\n在从基类的对象转为派生类的对象的时候不应该直接进行强制转换，而应该先检查，使用 as 运算符而不是强制转换 (\u0026lt;type\u0026gt;)：\n1 2 3 4 public void Login(object service) { IAccountService = service as IAccountService; } as 运算符会检查要进项转换的对象是否符合条件（实现了接口），然后再进行转换，如果不符合不会抛出异常而是返回一个 null。\nis 运算符根据条件是否满足，返回一个 bool 值，如果条件为 true ，则将所得的对象写入后面声明的变量中：\n1 2 3 4 if (o is AccountService service) { // service is AccountService. } ","date":"2021-04-27T21:52:51+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note2-oop/","title":"C#面向对象——对象和类型与继承 - C#笔记"},{"content":"目录 C#基础 C#面向对象 C#泛型 C#运算符和强制类型转换 C#中数组的使用 C#的委托、lambda 表达式和事件 C#字符串和正则表达式 CSharp 基础 《CSharp高级编程（第 11 版）》 笔记，系统入 .NET\n由于这么多年来一直用 CSharp摸鱼，所以基础部分只写一些自己认为比较重要的。今天看了一天书，一百来页，结果刚才发现好像都忘了\u0026hellip;所以来开个笔记。这一部分主要介绍了什么是 .NET ，技术之间的关系（显然，我的理解很不透彻）。然后所CSharp的基础内容，变量定义、程序流控制等。\n.NET 应用程序和技术 .NET Framework 旧技术，只能运行于 Windows 操作系统。梦开始的地方。.NET Framework 4.8 后无更新计划，但会继续支持。\n.NET Core \u0026amp; .NET .NET Core 是跨平台的、开源的高性能平台。近年来 .NET Core 很有起色。.NET 5 “合并了” .NET Core 和 .NET Framework，未来的 .NET 会以 .NET 为名发布，比如今年年末计划发布的 LTS 版本：.NET 6\n如果你开一个新项目的话，用 .NET Core/.NET 5 吧！如果不是维护旧代码或者有特殊需求，真的不建议用 .NET Framework 了。而且新平台上手难度也很低。\nCSharp 面向对象的类型安全的高性能语言。语法上算是 C-Style，与 C/C++、Java 很相似（但是更像 Java 一点），不过相比于 Java 来说语言特性方面有很多优点。\n关于相关概念的理解 注意：这部分是我自己的理解，不一定对。\n.NET 大部分情况下可以指一个生态：它有着一个公共基础架构，包括语言（CSharp、F##、VisualBasic）以及编译器和运行库组建（比如 GC）。\n在其上是 .NET 标准库\n要注意 .NET Standard 不是一个实现而是一个协定，本协定规定了需要实现什么 API。.NET Framework、.NET Core 和 Mono 平台实现了这个协定。但是他们各自实现了 CLR —— 公共语言运行时，但是 .NET Framework 实现的 CLR 就叫做 CLR，而.NET Core 所实现的 CLR 叫做 CLR Core。因此 CLR 是概念还是实现需要看具体语境。\nCLR CLR 的职责是：将构建时的中间码（IL）编译为本机码。同时还负责加载类型、垃圾回收以及线程处理。\n开发工具 个人心中觉得的易用程度：\nVisual Studio 2019 + JetBrains ReSharper 插件 Visual Studio Code + CSharp插件 JetBrains Rider Visual Studio 注： Visual Studio for MAC 没用过，家贫。\n2 - 核心 CSharp 2.1 - CSharp基础 Hello World 1 2 3 4 5 6 7 8 9 10 11 12 using System; namespace Example { class Program { static void Main() { Console.WriteLine(\u0026#34;Hello World\u0026#34;); } } } CSharp9的“脚本” Main 函数是程序的入口点，但是在 CSharp9 之后，可以忽略Main函数直接书写代码，就像“脚本”一样：\n1 2 3 4 5 using System; Console.WriteLine(\u0026#34;Please input your name\u0026#34;); var userName = Console.ReadLine(); Console.WriteLine($\u0026#34;Hello, {userName}\u0026#34;); 它将从第一行代码开始顺序执行。\n每一段代码都干了啥 下面来看看分析下 HelloWorld 的代码：\nCSharp的语法 CSharp的语法很符合 C/C++那一套：\n分号结束语句； 标识符区分大小写； 花括号包裹语段； 单行注释以 // 开头，多行注释包裹在 /* 与 */ 之间。 包括很多像定义变量、赋值、函数声明与调用什么的也都很相似。\n名称空间 名称空间是把相关类组合在一起的方式。namespace 后跟名称空间，花括号内的类属于该名称空间。\nusing System; 引用了名称空间 System 。声明语句允许引用这个类（Console），而不用去写 System.Console.WriteLine();\n可以使用 using static 不仅可以打开名称空间，也可以引用类的所有静态成员 using static System.Console 后可以直接使用 WriteLine() 方法。\nProgram类 所有的CSharp代码都应该包含在类中（9那种“脚本”编程除外。）类的声明包含 class 关键字，后面跟类名和一对花括号。\n事实上这个类叫啥名都行啊\n主函数 C 、 C++ 、 Java 等很多编程语言都有这个概念，主函数（Main 方法）是程序的入口点，程序从这里开始执行。Main() 方法的返回值为 void 或者 int。\n在CSharp中，方法的定义如下：\n1 2 // [modifiers修饰符] return_type返回类型 MethodName方法名([parameters参数]) public int ConvertToInt (double input) WriteLine 是一个静态方法，所以不需要先实例化一个 Console 对象。\n2.2 - 变量 使用以下语法声明变量\n1 2 // datatype类型 identifier标识符; int number; 2.2.1 - 初始化变量 CSharp中，变量在使用之前必须要被初始化。使用未初始化的变量无法通过编译。如果变量是类或结构中的字段，则会自动初始化为0（是在内存中的0，而不是字面量0）。\n在CSharp中实例化一个对象，需要使用 new 关键字：\n1 HttpClient client = new HttpClient(); 2.2.2 - 类型推断 在CSharp中可以使用类型推断让编译器自动推断类型（使用 var 关键字）。在类型名非常长的时候很爽，事实上大部分变量我都在用类型推断让编译器去帮我推断：\n1 2 3 4 5 6 var num = 6; // num is int. var option = new JsonSerializerOptions() { WriteIndented = true, }; // option is JsonSerializerOptions. 需要遵循以下规则：\n变量必须被初始化，不然编译器就没有推断的依据（谁知道你 var t 想干啥啊） 初始化器不能为空（也没人知道你 var t = null 想干啥） 初始化器必须放在表达式中 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象（不能把对象赋值过去var obj = sb;，但是你可以在等号右面整个新对象var obj = new StringBuilder();） 2.2.3 - 变量的作用域 变量是有作用域的，它遵循以下规则：\n只要类的局部变量在某个作用域内，其字段（也称为成员变量）也在该作用域内（对象的字段和对象的作用域一样）； 局部变量存在于声明该变量的块语句或方法结束的右括号之前的作用域内； 在 for 、 while 或类似语句中声明的局部变量存在于该循环体内。 局部变量的作用域冲突 同名的局部变量不能在同一个作用域内声明两次。\n1 2 var t = 5; vat t = \u0026#34;str\u0026#34;; 这必报错好吧。\n如果在不同的作用域内声明了两个同名变量，小作用域内会使用作用域小的变量（但是我觉得应该尽量避免这种情况）\n字段和局部变量的作用域冲突 在类级别（类中）定义的会被认为是字段，而方法内的看作局部变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 using System; namespace Test { class Program { static int i = 10; static void Main() { int i = 30; Console.WriteLine(i); // Output: 30. } } } 可以看到，在小作用域（方法中）使用了小作用域的变量（Main 里面定义的 i）而不是字段i。在这一部分CSharp隐藏了作用域更大的字段i。 想要使用类级别的变量可以使用 Program.i 这样的语法（object.fieldName）\n2.2.4 - 常量 使用 const 关键字定义常量：\n1 const int size = 1024; 这个 const 和 C/C++ 中有区别，它的原理更像 ##define SIZE (1024)。编译器在编译的时候将它替换为字面量。因此，在 const 关键字后面定义的常量要在被编译之前能确定它的值。\n1 const string dir = Environment.CurrentDirectory; // Error. 上面这语句中编译器在编译的时候不知道 Environment.CurrentDirectory 的值，因此没有办法编译为常量。\n常量必须在声明时初始化。指定了其值后，就不能再改写了。 常量的值必须能在编译时用于计算。因此，不能使用从变量中提取的值来初始化常量。 常量总是隐式静态的。不需要也不允许添加 static 关键字。 2.3 - 预定义数据类型 2.3.1 - 值类型和引用类型 CSharp把数据类型分为两种：\n值类型 引用类型 从概念上，值类型存储的是变量的值，而引用类型存储的是变量的引用。\n值类型存储在（堆）栈-Stack中，而引用类型存储在堆-Heap中。\n在CSharp中，基本的数据类型大部分值类型，比如int、double、bool等，而大多数更复杂的类型（自己定义的类等）是引用类型。结构体是值类型。\nCLR会定期删除不能使用的引用。\n如果变量为引用类型则可以把它设置为 null ，表示它不引用任何对象。\n如果去访问一个指向 null 的变量的非静态成员函数或字段则会引发一个运行时异常。\n2.3.2 - .NET 类型 数据类型的CSharp关键字从编译器映射到.NET数据类型。在语法上可以把基本类型看作支持某些方法的类。\n2.3.3 - 预定义的值类型 整型 有符号整型：\nsbyte - 8位 short - 16位 int - 32位 long - 64位 无符号整型：\nbyte - 8位 ushort - 16位 uint - 32位 ulong - 64位 在CSharp中，所有的数据类型都以与平台无关的方式定义，以备迁移。 所有的整数类型都能被赋予十进制或者十六进制或者二进制，十六进制和二进制使用前缀：\n0x - 十六进制 0b - 二进制 如果没有显示的声明则变量默认为 int 类型，可以使用后缀：\nU - 无符号 L - 长整型 UL - 无符号长整型 可以使用下划线作为数字分隔符，增强可阅读性，比如：\n1 uint binary = 0b1111_1011_1100_1011_1101_1100_0010; 浮点型 float - 32位 double - 64位 指定值为 float 需要使用后缀 F：\n1 float width = 23.8F; decimal类型 专门用于财务的类型。\ndecimal - 128位\n不是基本类型，计算的时候会有性能损失。\n需要在数字后面加上 M 来指定。\nbool类型 它只有 true 和 false\n注意：在CSharp中 bool 类型和整数值不能相互隐式转换。也就是说：\n1 2 3 4 5 int flag = 1; if (flag) Console.WriteLine(\u0026#34;Yes!\u0026#34;); // wrong. if (flag == 1) Console.WriteLine(\u0026#34;Yes!\u0026#34;) // right. 字符类型 char 仅用于存储字符。它可以使用单引号包裹的字面量赋值，也可以使用Unicode、强制转换的整数和十六进制数以及转义字符。\n2.3.4 - 预定义的引用类型 object类型 在CSharp中，object 类型就是最终的父类型，所有的内置类型和用于定义的类型都从它派生而来。\nstring类型 CSharp有 string 关键字，在遮罩下转换为 System.String。\nstring 是一个引用类型，但是目前来说 string 类基本上已经实现其语义遵循一般的、直观的字符串规则。\n可以直接用 == 来比较字符串的值啦！\nCSharp字符串也可以包含Unicode和十六进制数转义序列。\n前缀：\n@ 这个字符后所有的字符都看成原来的含义，不会被解释为转义，并且也可以包含换行符（可以写多行）。 $ 这个字符串中使用插值，可以使用 {var} 来在字符串中插入值，比如： 1 2 var name = \u0026#34;Jack\u0026#34;; var note = $\u0026#34;Hello, {Jack}!\u0026#34;; 2.4 程序流控制 2.4.1 - 条件语句 if语句 1 2 3 4 5 6 7 8 if (condition) { // codes... } else { // other codes... } 为了安全和保持一致，建议只要使用if语句就加上花括号，如果真的只有一行并且不想加花括号可以这样写：\n1 if (isFault) return; switch 语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 switch (t) { case 1: Console.WriteLine(\u0026#34;1\u0026#34;); break; case 2: Console.WriteLine(\u0026#34;2\u0026#34;); break; case 3: case 4: Console.WriteLine(\u0026#34;3 or 4\u0026#34;); break; default: Console.WriteLine(\u0026#34;UnKnow number\u0026#34;); break; } 注意：case的值必须是常量表达式，不允许使用变量。\nCSharp这个玩意它很安全，如果激活了一个 case 则其它的 case 就不会被激活，而且 break 是强制加入的。如果上一个 case 没有语句则可不写 break 来“滑滑梯”。\n还有一个玩意叫 switch表达式 ，这个东西书上没写，我搓了个 switch 来用代码提示转换成了表达式看看：\n1 2 3 4 5 6 7 8 var code = 200; var result = code switch { 200 =\u0026gt; \u0026#34;OK\u0026#34;, 400 =\u0026gt; \u0026#34;BadRequest\u0026#34;, _ =\u0026gt; \u0026#34;UnKnow\u0026#34; }; 这个东西呢适用于以下场景：不同的条件返回不同的值，但是类型是一样的。\n2.4.2 - 循环 这些都跟C差不多咯\nfor 循环 1 2 3 4 5 6 var sum = 0; for (var i = 0; i \u0026lt; 100; ++i) { sum += i; } while 循环 1 2 3 4 5 6 var input = Console.ReadLine(); while(string.IsNullOrWhiteSpace(input)) { Console.WriteLine(\u0026#34;Invalid input, please retry.\u0026#34;); input = Console.ReadLine(); } 当输入的 input 为空的时候会进入循环一直要求输入。\ndo-while 循环 1 2 3 4 5 6 7 var input = string.Empty; do { Console.WriteLine(\u0026#34;Please input.\u0026#34;); input = Console.ReadLine(); } while(string.IsNullOrWhiteSpace(input)); foreach 循环 foreach 循环可以迭代集合中的每一项，但是它不能改变集合中的各项。\n2.4.3 - 跳转语句 goto 语句 标签：\n1 2 Label: Console.WriteLine(\u0026#34;L1\u0026#34;); 跳转：\n1 goto Label; 大多数情况下不允许使用goto语句。一般情况下，使用它肯定不是面向对象编程的好方式。\nbreak 语句 用于退出 case 和退出循环，如果放在嵌套的循环中则退出内部循环。、\ncontinue 语句 只退出当前迭代，立即开始下一轮循环。\nreturn 语句 退出当前方法并把控制权返回给调用者。如果方法的类型不是 void 则必须return相应的类型。\n2.5 - 名称空间 名称空间是一种逻辑组合，而不是物理组合（事实上要尽量和文件结构对应好一些吧）\n名称空间之间用句点隔开。名称空间与程序集无关。\n一般来说 CompanyName.ProjectName.SystemSection 是可以接受的命名方式，也是微软所推荐的。\n2.5.1 - using 语句 输名称空间太长了，所以用using来把它引入，然后就能直接写了，上面说过。\n很多CSharp代码都有 using System ，因为微软公司提供的许多有用的都在这个名称空间下。\n如果在不同的名称空间下两个类名一样则需要写前面的名称空间。应该尽量避免这种情况的发生。\n2.5.2 - 名称空间的别名 using 关键字的另一个用途是给类和名称空间指定别名。如果名称空间很长但是还需要避免类名冲突的话可以使用别名，这样写起来爽一些。\n注意：名称空间的别名的修饰符 ::\n2.6 Main() 方法 要求一般为：\n使用了 static 修饰符 在任意名称的类中 返回 int 或 void 类型 （当然，前面说过了，CSharp9所允许的那样脚本化的操作并不需要满足）\n在调用的时候可以让CLR包含参数，将命令行参数传递给程序：\n1 void Main(string[] args) 与C不同的是，args[0] 并不是程序的路径，它就是传递的第一个参数。\n2.7 - 注释 注释是个好东西哦\n2.7.1 - 源文件中的内部注释 CSharp使用传统的C风格的注释：\n单行注释使用 // 多行注释使用 /* 和 */ 不过，在写多行的时候也可以使用多个单行注释，因为使用IDE的快捷键来这么干非常方便。\n2.7.2 - XML文档 /// 用于生成XML风格的注释，常见的XML标签有：\n\u0026lt;summary\u0026gt; - 提供类型或成员的简短小结 \u0026lt;returns\u0026gt; - 说明方法的返回值 \u0026lt;param\u0026gt; - 标记方法的参数（编译器要验证其语法） 2.8 - CSharp预处理器指令 2.8.1 - #define 和 #undef #define 本身没啥用（它不能和C/C++那样玩），和 #if 配合才有大用。\n2.8.2 - #if、#elif、#else 和 #endif #if 如果条件符合那就编译中间的代码，比如：\n1 2 3 4 5 6 7 #define DEBUG #if DEBUG Console.WriteLine(\u0026#34;DEBUG MODE ENABLED!\u0026#34;); #elif Console.WriteLine(\u0026#34;NORMAL MODE.\u0026#34;); #endif 它还支持一组逻辑运算符：!、==、!= 和 ||\n2.8.3 - #warning 和 #error 编译器遇到它们的时候分别产生警告和错误，它后面的文本是给用户显示的信息。\n2.8.4 - #region 和 #endregion 用于把一段代码视为有给定名称的一块，一些编辑器会识别并使这些代码在屏幕上更好的布局。\n2.8.5 - #line 改变在编译器警告和错误中的行号。\n2.8.6 - #pragma 关闭或者开启对某行代码的警告。比如：\n1 2 3 4 5 6 #pragma warning disable 169 class MyClass { int neverUsedField; } #pragma warning restore 169 上述代码可以关闭“字段未使用”的警告。\n2.9 - CSharp编程准则 关于规范方面，ldqk有一篇博客，写的很全面\n全面的CSharp编码规范整理\n2.9.1 - 关于标识符的规则 标识符是给变量、用户定义的类型和这些类型的成员的名称，准则有：\n尽管可以包含数字字符，但它们必须以字母或者下划线开头； 不能把CSharp关键字用作标识符。 2.9.2 - 用法约定 CSharp的约定是命名变量时不使用任何前缀（不用 char *pszResult 这样的）：string Result\n微软规定了许多CSharp的用法准则，虽然不是强制要求，但是尽量遵守这些准则，除非有明确的理由。\n命名约定 名称的大小写\n名称空间和类，以及基类中的成员等名称应该遵循 Pascal 大小写规则。\nPascal 大小写规则就是每个单词首字母大写，比如：\n1 2 3 4 5 6 7 8 9 public class ClassMember { // ... } public class ListService { // ... } 应该使用 Pascal 大小写规则的有：\n名称空间、类名、方法名、属性或者私有字段（最近Microsoft那边在使用下划线开头命名私有字段，那样更容易区分一些）。\n另外一种大小写方式是 camel 大小写形式，它就是第一个单词全部小写，其余单词首字母大写，比如：\n1 2 uint itemIndex = 0; string dataFileFullPath = @\u0026#34;C:\\...\u0026#34; 通常来说本地变量使用这种大小写规则。\n名称的风格\n保持一致\n比如某个方法为 ShowConfirmationDialog() ，则另一个方法不应该叫做 ShowDialogWarning() 或者 WarningDialogShow() 而是应该命名为 ShowWarningDialog()。\n名称空间的名称\n尽量避免与其它重名，推荐的格式上文说过，是：\u0026lt;CompanyName\u0026gt;.\u0026lt;TechnologyName\u0026gt;，例如：\n1 2 3 4 namespace Microsoft.Text { } 名称和关键字\n名称不应该与任何关键字冲突\n属性和方法的使用 如果这个看起来感觉是变量，就应该用属性来表示，而不是方法。总结来说：\n不要将只写的设置为属性，比如应该使用 SetPassword() 方法而不是只写的 Password 属性； 读取该值不应该花费太多时间； 读写该值不应该有其它明显的效果，它的作用应该仅与这个属性相关； 可以按照任意的顺序去设置属性，不应该因为属性没有设置完而抛出异常； 如果属性可能有意想不到的改变，就应该写成方法。 如果不能满足所有的条件，那么就写成方法吧。\n字段的使用 字段的用法非常简单。字段应该总是私有的，但是某些情况下可以设置为公有。\n","date":"2021-04-24T21:38:19+08:00","permalink":"https://blog.gaein.cn/passages/csharp-note1-basic/","title":"C#编程基础 - C#笔记"},{"content":" 文章由我翻译自5 ways to set the URLs for an ASP.NET Core app。本人文化水平不高，可能有误译，但是大致内容应该没有问题，还请多海涵。\n版权声明：本文:5 ways to set the URLs for an ASP.NET Core app为Andrew Lock原创，依据 CC BY-SA 4.0 许可证进行授权，转载请附上出处链接及本声明。\n为 ASP.NET Core 自定义监听 Url 和端口的五种办法 默认情况下，ASP.NET Core应用程序监听以下地址：\nhttp://localhost:5000 https://localhost:5001 在这篇文章里我将给出 5 种不同的办法来改变你的应用程序监听的地址。\n在启动程序的时候改变 ASP.NET Core 监听地址有很多种办法。我有一篇旧博客指出了在 ASP.NET Core 1.0 中可选的几种办法，这些办法在 ASP.NET Core 3.x 中大致是相同的：\nUseUrls() —— 在 Program.cs 中写死； 环境变量 —— 使用 DOTNET_URLS 或者 ASPNETCORE_URLS 来设置； 命令行参数 —— 从命令行启动时使用 --urls 参数来设置； 使用 launchSettings.json —— 在 applicationUrl 这个节点中设置； KestrelServerOptions.Listen() —— 手动使用 Listen() 为 Kestrel 服务器设置地址。 在下面我们来看各个办法的详细说明。\n你能用什么样的URLs 在这篇文章里我说了你可以监听的 \u0026ldquo;URLs\u0026rdquo;，但是你不可能去使用一个随意的、毫无章法 URL。这有 3 类 URL 可以用来监听。\nIPv4 和 IPv6 的本机环回地址（例如 http://localhost:5000）。它的格式为:{协议}://{回路网络接口地址}:{端口}； 你机器上的某个特定 IP 地址（例如 http://192.168.8.31:5005）。它的格式为:{协议}://{IP地址}:{端口}； 指定端口的全部 IP 地址（例如 http://*:6264）。它的格式为:{协议}://*:{端口}。 port 在上述模式中也是可选的 —— 如果你省略了它，将会使用方案的默认端口（https 端口是 80，https 的端口是 443）。\n上述模式中你选择那种取决于你的部署机制。比方说，你在一台服务器上托管多个应用程序，你需要设置明确的IP地址。如果你在容器中托管，一般来说你可以使用地址 localhost。\n注意观察 “任意” IP 地址的格式 —— 你不一定必须要用 *，你可以使用一切不是 IP 地址也不是 localhost 的地址。也就是说，你可以使用像 http://*、http://+，http://mydomain 或者 http://example.org。所有这些都会有相同的行为，并且监听任何 IP。如果你只想处理某个特定的域名的请求，你需要额外设置 host filtering。\n当你知道你需要你的程序监听那些 URLs 时，你需要告诉你的程序这些事。在这篇博客里我写了设置这些的 5 种可能的方法。\nUseUrls() 第一种、并且也是最简单的设置绑定 URL 的的办法是在 IWebHostBuilder 中使用 UseUrls() 写死：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); webBuilder.UseUrls(\u0026#34;http://localhost:5003\u0026#34;, \u0026#34;https://localhost:5004\u0026#34;); }); } 把 URLs 写死看起来并不是一个优雅且可拓展的解决方法，所以这个方法并不怎么用在实际使用中。\n幸运的是，你仍旧可以从外部配置文件、环境变量活命令行参数中设置 URLs。\n环境变量 .NET Core使用两 种 设置：\nApp设置 是你通常所使用的，并且从 appSettings.json 、环境变量以及其它地方加载。 Host设置 是用来设置基础的东西的，比如 hosting环境变量 和 host 使用的 URL。 当考虑如何为应用程序设置 URLs 时，我们感兴趣的办法是 Host设置 。默认情况下，host设置的值从三个不同的源读取：\n带有 DOTNET_ 前缀的环境变量。这些环境变量被去除了前缀添加到集合里面； 命令行参数； 带有 ASPNETCORE_ 前缀的环境变量，这些环境变量也被添加到了集合里面，仅对 ASP.NET Core 应用程序有作用。如果你创建了一个.NET 通用主机的服务，那么这些环境变量将不会添加； 如果你不手动重写方法 UseUrls()，ASP.NET Core 将会使用从设置系统中读取的 URLS 键对应的值。基于前文，你可以使用两个环境变量中的任意一个设置 URLs：\nDOTNET_URLS ASPNETCORE_URLS 如果你同时设置了两个环境变量， ASPNETCORE_URLS 的参数将会优先被使用。\n你可以像通常做的那样在你的环境中设置环境变量。比如，使用命令提示符：\n1 setx ASPNETCORE_URLS \u0026#34;http://localhost:5001\u0026#34; 使用PowerShell：\n1 $Env: ASPNETCORE_URLS = \u0026#34;http://localhost:5001\u0026#34; 或者是在bash里：\n1 export ASPNETCORE_URLS=\u0026#34;http://localhost:5001;https://localhost:5002\u0026#34; 就像你在上面看到的那样，你可以通过用分号分割它们来传递多个被监听的地址（用HTTP和HTTPS都行）。\nMarc在评论中指出，如果你在 Docker 中运行它，Dockerfile 会将 ASPNETCORE_URLS 环境变量设置为端口 80\n命令行参数 另外一个设置host设置值的办法是使用命令行。如果设置了环境变量则命令行参数会重写它们。只需要使用 --urls 参数：\n1 dotnet run --urls \u0026#34;http://localhost:5100\u0026#34; 像前面那样，你可以通过用分号分割来传递多个 URLs：\n1 dotnet run --urls \u0026#34;http://localhost:5100;https://localhost:5101\u0026#34; 环境变量和命令行参数可能是生产环境中设置 URLs 用的最多的办法了，但是对于在本地开发来说可能略显繁琐，因此在本地开发通常简单的使用 launchSettings.json\nlaunchSettings.json 大部分 ASP.NET 项目模板在 Properties 文件夹中包含 launchSettings.json 文件。这个文件包含了启动 ASP.NET Core 应用程序的几种配置。一个典型的例子是包含从命令行直接启动选项的定义还有一个使用 IIS Express。该文件配置了 Visual Studio 中 Debug 的下拉菜单：\nlaunchSettings.json 通过 applicationUrl 节点提供了一个设置 URL 的简单办法 —— 你还可以看见 iisSettings 里面的 IIS express 设置，以及另外一个 TestApp （应用程序的名称）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;iisSettings\u0026#34;: { \u0026#34;windowsAuthentication\u0026#34;: false, \u0026#34;anonymousAuthentication\u0026#34;: true, \u0026#34;iisExpress\u0026#34;: { \u0026#34;applicationUrl\u0026#34;: \u0026#34;http://localhost:38327\u0026#34;, \u0026#34;sslPort\u0026#34;: 44310 } }, \u0026#34;profiles\u0026#34;: { \u0026#34;IIS Express\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;IISExpress\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } }, \u0026#34;TestApp\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5001;http://localhost:5000\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } 想要使用这个文件你不需要做任何特别的设置 —— dotnet run 将会自动使用它。\nlaunchSettings.json 同时也提供了一种方便简单的办法使用 environmentVariables 节点来添加环境变量，你可以从上面的文件看出来这点。\n当你从命令行使用 dotnet run 运行你的应用程序，你的程序将会使用上面文件中指定的“项目”中的 applicationUrl 节点中的 URLs https://localhost:5001;http://localhost:5000。当你使用 \u0026ldquo;IISExpress\u0026rdquo; 选项的时候，你的应用程序会使用 iisSettings.iisExpress 中的 applicationUrl。\n当你在本地开发时可以使用这个文件非常轻易的修改环境变量。事实上你还可以 不 使用这个 launchSettings.json 文件:\n1 dotnet run --no-launch-profile 这将会跳过 launchSettings.json 文件并且使用本机的环境变量来内部确定URLs。\n所有的这些办法都是简介的对 Kestrel 的间接设置，但你仍然可以直接设置它们。\nKestrelServerOptions.Listen() 在大部分ASP.NET Core程序中，Kestrel被设置为默认的服务器。如果你想的话可以手动设置为 Kestrel 设置端点，或者通过 IConfiguration 系统去配置 KestrelServerOptions。\n我从来没有真正需要去设置这个的时候，并且这个玩意有非常大量的选项可以用。所以，通常情况下我建议参考文档。举个例子，你可以使用被 KestrelServerOptions 暴露的 Listen() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); webBuilder.UseKestrel(opts =\u0026gt; { // 直接绑定套接字句柄或者Unix套接字 // opts.ListenHandle(123554); // opts.ListenUnixSocket(\u0026#34;/tmp/kestrel-test.sock\u0026#34;); opts.Listen(IPAddress.Loopback, port: 5002); opts.ListenAnyIP(5003); opts.ListenLocalhost(5004, opts =\u0026gt; opts.UseHttps()); opts.ListenLocalhost(5005, opts =\u0026gt; opts.UseHttps()); }); }); } 这个直接设置 Kestrel 绑定多个地址。尽管它是写死的，但是也可以不是嘛 —— 你可以绑定 IConfiguration 中的地址。当你使用这个办法去设置 kestrel 的绑定的时候，它将会覆盖你用其它办法配置的 URLS 设置，比方说环境变量。当这种情况发生的时候，你可以在日志中看到警告。\n1 2 3 4 5 6 warn: Microsoft.AspNetCore.Server.Kestrel[0] Overriding address(es) \u0026#39;http://localhost:5007\u0026#39;. Binding to endpoints defined in UseKestrel() instead. info: Microsoft.Hosting.Lifetime[0] Now listening on: http://127.0.0.1:5002 info: Microsoft.Hosting.Lifetime[0] Now listening on: http://[::]:5003 个人认为，没有必要像这样从 Kestrel 中绑定端点，但是如果你有需要的话，这是一个摆脱 Kestrel 控制的好方法。\n总结 这篇文章中我给出了五种不同的设置监听的 URLs 的办法。UseUrls() 是最简单的，但是并不适合在生产环境中使用。--urls 命令行参数和 ASPNETCORE_ / DOTNET_ 环境变量是在生产环境中设置最有用的办法。launchSettings.json 文件在开发环境中设置URLs非常有用。如果你需要对配置进行底层的控制，你可以直接使用 Kestrel 的 Listen* 选项，无论是生产环境开始开发环境它们都可以轻易的设置。\n","date":"2021-04-04T03:18:28+08:00","permalink":"https://blog.gaein.cn/passages/set-urls-for-aspnetcore/","title":"为 ASP.NET Core 自定义监听 Url 和端口的五种办法"},{"content":"将 ASP.NET Core 应用程序部署到 docker 中 前言 最近用 ASP.NET Core 随便摸了一些 API 和新博客的后端，为了方便以后迁移和管理准备部署在 docker 中。\n编译 由于使用 docker 相当于已经指定了系统（Linux），因此我们可以使用更多编译选项。\ndocker 中也有 Windows Server 的镜像，不过大部分是 Linux，官方的 runtime 也是基于 debian 的。\n1 dotnet publish -c Release -p:PublishReadyToRun=true --no-self-contained -r ubuntu.20.04-x64 -o ./Release 发布模式 使用 --configuration 或者 -c 来指定发布的模式。默认为 Debug ，由于我们需要发布正式版所以采用 Release 。\nR2R ReadyToRun：在编译的时候除了编译中间码外也编译目标架构的机器码，但是仍然会保留中间码。这样会造成程序体积的翻倍，但是会加快启动速度，不过由于程序体积变大也可能减缓启动速度，是个很玄学的选项 不过微软文档上表示。\nFor instance, ReadyToRun can be used to reduce the response latency of the first use of Web API in an ASP.NET application.\n比方说呢，R2R 可以加快 ASP.NET Core Web API 的第一次响应速度。\n更多内容见微软文档Microsoft Docs | ReadyToRun development overview\n非自部署发布 使用 --no-self-contained 或者 --self-contained false 来指定不要自部署发布，即不包含.NET runtime。这样做有利于减少发布程序的大小。\n但是在没有.NET runtime的机器上运行时需要先安装.NET runtime。\n不过我的想法是在 docker 里面运行，可以使用 ASP.NET Core 的镜像（通常来说也确实是这样的），包含了 .NET runtime 。所以不需要自部署发布。\n目标平台 使用 --runtime \u0026lt;RUNTIME_IDENTIFIER\u0026gt; 或 -r 来指定目标平台。后面接目标平台标识符，即 Runtime Identifiers (RIDs)。\nRID 列表见微软文档：Microsoft Docs | Runtime Identifiers (RIDs)\n因为启用了 R2R 所以需要指定目标平台。\n另外我觉得（并没有根据的胡扯）指定发布平台比全平台编译效果好。\n输出目录 使用 --output \u0026lt;OUTPUT_DIRECTORY\u0026gt; 或者 -o 设置输出目录。\n更多 更多选项见Microsoft Docs | dotnet CLI\nDocker 添加镜像加速 docker 官方的镜像仓库慢的理解不能 docker hub 已经被防火墙阻断，这边我使用了阿里云的镜像加速服务（因为我是阿里云服务器，这样速度也非常可观）\n打开阿里云控制台的容器镜像服务中的镜像加速器Tag； 按照下面的操作文档修改，比如Ubuntu为： 进入目录/etc/docker（如果没有就创建一个） 编辑文件daemon.json（如果没有就创建一个） 写入如下内容：{\u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://\u0026lt;token\u0026gt;.mirror.aliyuncs.com\u0026quot;]}，网址在上面的“加速器地址”处有写。 sudo systemctl daemon-reload重载 sudo systemctl restart docker重启docker Dockerfile Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n引用 ASP.NET Core 镜像 首先我不希望发布自部署应用程序，因为它过于庞大。 方便起见，可以考虑引用 ASP.NET Core Runtime 的 Docker 镜像：\n1 FROM mcr.microsoft.com/dotnet/aspnet:5.0 实际上，使用自部署应用程序+alpine 或许可以发布出体积更小的镜像，但是会稍微麻烦一些。\n这句话引用了 ASP.NET Core 的 docker 镜像，里面有包含 Runtime。\n设置目录 首先需要使用 COPY 命令复制我们编译出来的文件，然后使用 WORKDIR 来指定工作目录（就是启动程序的路径）。\n1 2 3 4 5 # Copy Files COPY . /public # Set Workdir WORKDIR /public 请注意替换成自己编译输出的目录\n设置时区 为了确保时间正确，设置一下时区\n1 2 RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime RUN echo \u0026#34;Asia/Shanghai\u0026#34; \u0026gt;/etc/timezone 当然，更好的做法是在创建容器时候使用环境变量指定，或在 docker compose 中指定：\n1 2 environment: TZ: \u0026#39;Asia/Shanghai\u0026#39; 开放端口 1 2 # Expose Port 80 EXPOSE 80 由于 docker 中是生产环境，所以会使用 80 端口而不是默认的 5000 。可以在执行程序的时候更改端口。总之，这里写你要暴露的端口咯。\n当然，你也可以不暴露端口，通过其他手段访问。\n运行程序 1 CMD ./WebApplication 注意替换为你的程序名\n使用参数 --urls \u0026quot;http://*:6000\u0026quot; 来设置启动的端口（127.0.0.1为监听本机）。可以使用类似于 --urls \u0026quot;http://*:6000;http://*:6001;http://*:6002;http://*:6003\u0026quot; 监听多个端口。\n或者你可以使用环境变量和其它方法，可以参考这篇文章：5 ways to set the URLs for an ASP.NET Core app\n或\n为 ASP.NET Core 自定义监听 Url 和端口的五种办法\n创建容器 1 docker build -t MyWebApplication:v1.4.2 Release/ 这句话将会创建一个 docker 容器，命令的格式如下\n1 docker build -t \u0026lt;container name\u0026gt;:\u0026lt;tag\u0026gt; \u0026lt;directory\u0026gt; 注意替换为自己容器名称和标签以及构建出来的目录\n运行容器 1 docker run -d -p 6000:80 MyWebApplication:v1.4.2 其中 -p 6000:80 的意思是讲容器暴露的 80 端口映射到本机的 6000 端口，而后面的 MyWebApplication:v1.4.2 则是刚才创建容器时候写的 container name 和 tag。\n","date":"2021-04-04T00:10:02+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-docker/","title":"将 ASP.NET Core 应用程序部署到 docker 中"},{"content":"上了半年大学，也写了很多年代码了（厚颜无耻）。总结一下编程中用到的一些代码规范，命名法则等。在这里总结一下。\n前言 上了半年大学，课余时间充裕了，学到了很多计算机的知识。虽然也是摸鱼占大多数，但是自己写的代码确实比以前规范了一些（虽然仍然是屎山）\n参考学长的这篇 C/C++ 编码规范\n内容 缩进 层次之间要有缩进，如\n1 2 3 4 5 6 7 8 9 10 11 12 13 namespace MyProgram { class Program { public static void Main(string args[]) { if (args.Length \u0026gt; 0) { // Do something... } } } } 注释 使用单行注释后后面留一个空格。\n使用 XML 注释时候写清所有参数。\n命名 变量名使用驼峰命名法 Camel： 第一个单词首字母小写，其余单词首字母大写，比如connectionStr ，resourcesUri，addedNode等 常用于变量 字段或方法、类等使用帕斯卡命名法 Pascal： 第一个单词首字母大写，其余与驼峰相同，比如GetToken，InsertToList，UserId等\n","date":"2021-02-16T15:44:13+08:00","permalink":"https://blog.gaein.cn/passages/programing-standard/","title":"编程代码规范"},{"content":"大家在处理 Web 程序的时候经常使用一些GET、POST等词汇，这是 HTTP 协议中规定的 HTTP 方法，用来发送给服务器表示对一些资源的处理。这里记录一下这些常见的 HTTP 方法的含义及作用。\n前言 根据杨旭老师在哔哩哔哩上的课程 ASP.NET Core 3.x 构建 RESTful API 记录的笔记，以后的笔记会根据课程进行更新。\n这一节主要说各种常见HTTP方法的用途和作用。\nHTTP 请求方法 关于 HTTP 方法，可以参考HTTP 请求方法 - HTTP | MDN\n不同的动作作用于同样一个 URI，区别他们的是 HTTP 方法\n“增删改查” HTTP POST 创建/添加一个资源，比如发表一篇文章或者评论。\nPOST 的参数放在请求的 body 里。\nPOST 收到请求应该返回新创建的资源以及可以获取该资源的唯一标识 URI。\nHTTP GET 获取一个资源，比如访问界面、列出产品列表等。\nGET 的参数通常使用查询字符串，在 URI 的?后边，使用\u0026lt;参数\u0026gt; = \u0026lt;值\u0026gt;，多个查询使用\u0026quot;\u0026amp;\u0026ldquo;号连接。\nGET 收到请求应该返回所查询的资源。\nHTTP DELETE 删除一个资源，比如删除用户、文章等。\nDELETE 通常没有参数。\nDELETE 收到请求后应该删除资源（或标记为删除），无需返回信息，返回状态码HTTP 204即可。\nHTTP PATCH 更新一个资源的一部分，比如用户更改头像、联系方式。\nPATCH 的参数放在请求的 body 里面。\nPATCH 收到请求后应该更新资源，返回状态码 HTTP 204 即可。\nHTTP PUT 替换更新一个资源，Id 不变。如果没有这个资源则创建，但是多次请求结果不变。比如过户某账号。\nPUT 的参数放在请求的 body 里，是完整的对象。\nPUT 收到请求后应该替换资源但是 ID 不变，返回状态码 HTTP 204 即可。\n总结 动作 HTTP 方法 Payload 参数位置 URI 请求更改 响应内容 查询 GET 查询参数 Query 端点 + ID 无修改 单个资源或多个资源的集合 添加/创建 POST 要创建的资源的对象 Body 端点 新建资源 新创建的资源 局部修改/更新 PATCH 待修改资源的JSON键值对 Body 端点 + ID 更新资源的某些字段 无需返回 替换 PUT 要替换的单个资源对象 Body 端点 + ID 替换除了ID外整个资源 无需返回 使用预定义的标识进行创建 PUT 要创建的单个资源对象 Body 端点 + ID 创建了新的资源 返回新创建的资源 移动/删除 DELETE 无 可含Query 端点 + ID 删除资源 无需返回 ","date":"2021-02-03T23:45:55+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-webapi-note4-http_method/","title":"GET、POST都是什么——常用的HTTP方法——ASP.NET Core Web API(4)"},{"content":" 这篇博客出了亿点问题，很奇怪的和前面那个重复了，但是我明明写了的呜呜呜。可能是删错了（x\n前言 根据杨旭老师在哔哩哔哩上的课程 ASP.NET Core 3.x 构建 RESTful API 记录的笔记，以后的笔记会根据课程进行更新。\n这一节主要是说说啥是REST，REST的优点与约束以及成熟度模型。\nRESTful API 主要是 REST 的概念和介绍（挺无聊的，抄 PPT）\n什么是 REST REST:状态表述转换\n符合 REST 的良好 Web 应用设计：\n一组网页的网络（一个虚拟状态机）； 点击链接来前进（状态转换）； 点击链接的结果是下一个网页（程序的下一个状态）。 REST 是一种架构风格，而不是规范或者标准，它需要一些规范、协议和标准来实现。REST 与协议无关。JSON 与 HTTP 并不是 REST 强制的（但是大部分都是）。\n优点 简单高效； 可扩展性、可修改性高； 可移植性； 可靠性； 可视性。 REST 的约束 考虑到以下约束，并确定不保证互不干扰\n客户端-服务端：独立部署（前后端分离）； 无状态：服务端不需要客户端的会话（相关请求需要全部包含，客户端要维护自己的状态）； *统一的资源接口：API 接口必须统一，用相同标准的接口； 资源的标识：URI、数据类型（？）、媒体类型对数据进行描述（application/json 等）； 通过表述对资源进行操作：获取的时候服务端将删除或修改操作的 URI 返回； 带有自我描述的信息：把相关的信息随着请求一起发送到服务端； 超媒体作为应用程序状态的引擎：？； 多层系统：多层架构，每一层与不相邻的层解耦； 可缓存：每个响应信息都应返回它是否可缓存； （按需编码）：服务器可以拓展客户端的功能，比如发送一些 JavaScript 给网页客户端。 如果一个 Web API 没有实现这五个约束，则不是 RESTful API。不是 RESTful API 并不能说明它不好。\nRichardson 成熟度模型 用来评估 RESTful API 的成熟度，有四个级别\nLv.0 沼泽 仅仅使用 HTTP 协议，其余部分没有实现。比如在同一个 URI 上同一个 HTTP 动词做不同的操作（反正就是垃圾的一批）\nLv.1 资源 URI 正确使用，不同的资源有 URI 做区分。但是 HTTP 动词没有正确（比如查询使用POST方法）\nLv.2 动词 HTTP 动词正确使用，返回 HTTP 状态码正确（符合统一资源接口）。\n我也就这样了\nLv.3 超媒体 前面全部正确。同时返回了其它操作的链接。\n这仅仅是 RESTful 的前提，只有达到 Lv.3 才可能是 RESTful API。\n","date":"2021-02-03T00:49:55+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-webapi-note3-standard/","title":"怎么设计优雅的API——普通API对外合约——ASP.NET Core Web API(3)"},{"content":"经常听说 RESTful API ，那么究竟什么是 REST，怎么判断一个 API 的成熟度呢？\n前言 根据杨旭老师在哔哩哔哩上的课程 ASP.NET Core 3.x 构建 RESTful API 记录的笔记，以后的笔记会根据课程进行更新。\n这一节主要是说说啥是 REST，REST 的优点与约束以及成熟度模型。\n关于 API 设计的规范，可以看微软的 API 指南：microsoft/api-guidelines: Microsoft REST API Guidelines\nRESTful API 主要是 REST 的概念和介绍（挺无聊的，抄 PPT）\n什么是 REST REST: 状态表述转换\n符合 REST 的良好 Web 应用设计：\n一组网页的网络（一个虚拟状态机）； 点击链接来前进（状态转换）； 点击链接的结果是下一个网页（程序的下一个状态）。 REST 是一种架构风格，而不是规范或者标准，它需要一些规范、协议和标准来实现。REST 与协议无关。JSON 与 HTTP 并不是 REST 强制的（但是大部分都是）。\n优点 简单高效； 可扩展性、可修改性高； 可移植性； 可靠性； 可视性。 REST 的约束 考虑到以下约束，并确定不保证互不干扰\n客户端-服务端：独立部署（前后端分离）； 无状态：服务端不需要客户端的会话（相关请求需要全部包含，客户端要维护自己的状态）； *统一的资源接口：API 接口必须统一，用相同标准的接口； 资源的标识：URI、数据类型（？）、媒体类型对数据进行描述（application/json 等）； 通过表述对资源进行操作：获取的时候服务端将删除或修改操作的 URI 返回； 带有自我描述的信息：把相关的信息随着请求一起发送到服务端； 超媒体作为应用程序状态的引擎：即使用 HTTP 状态码； 多层系统：多层架构，每一层与不相邻的层解耦； 可缓存：每个响应信息都应返回它是否可缓存； （按需编码）：服务器可以拓展客户端的功能，比如发送一些 JavaScript 给网页客户端。 如果一个 Web API 没有实现这五个约束，则不是 RESTful API。不是 RESTful API 并不能说明它不好。合适才是最好的。\nRichardson 成熟度模型 用来评估 RESTful API 的成熟度，有四个级别\nLv.0 沼泽 仅仅使用 HTTP 协议，其余部分没有实现。比如在同一个 URI 上同一个 HTTP 动词做不同的操作（反正就是垃圾的一批）\n比如以前常见的 POST https://api.example.com/cmd.php?command=\u0026quot;getpost\u0026quot;\u0026amp;arg=\u0026quot;page\\=3\u0026quot; 多了之后容易令人迷迷糊糊，调试起来也不方便。\nLv.1 资源 URI 正确使用，不同的资源有 URI 做区分。但是 HTTP 动词没有正确（比如查询使用POST方法）\nLv.2 动词 HTTP 动词正确使用，返回 HTTP 状态码正确（符合统一资源接口）。\n我也就这样了\nLv.3 超媒体 前面全部正确。同时返回了其它操作的链接。\n这仅仅是 RESTful 的前提，只有达到 Lv.3 才可能是 RESTful API。\n","date":"2021-02-02T15:48:49+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-webapi-note2-restful/","title":"什么是 REST——RESTful API 简介——ASP.NET Core Web API(2)"},{"content":"前言 根据杨旭老师在哔哩哔哩上的课程 ASP.NET Core 3.x 构建 RESTful API 记录的笔记，以后的笔记会根据课程进行更新。\n这一节主要是做一些准备工作，进行项目的创建。杨旭老师的教程里根据课程而编写了一个 RESTful Web API，我也将同步打代码，相关代码会储存在 GitHub 上。\nGet Start 准备工作 IDE Visual Studio 2019 或 Rider、Visual Studio Code、VS for MAC 工具 Postman Web API API: 应用程序接口 Web API: 使用 HTTP 协议并通过网络调用的 API，当然，也可以理解为使用 HTTP 网络协议的 Web API。 Web API 就是一个 Web 系统，通过访问 URI 可以与其进行信息交互。\nRESTful API RESTful API 是一套 API 约束规范或者叫架构风格。\n大多数的 Web API 并不是完全符合 RESTful API\nMVC 模式 前面我 MVC 的理解可能不太正确，它并不是一种前后端不分离的模式。MVC 并不是一个完整的应用程序架构，它只是 UI 的一种架构模式。\n用于构建 UI 的一种架构模式，特点是松耦合和关注点分离。\nModel——模型\n负责程序数据的逻辑\nView——视图\n负责展示数据，在构建 API 的时候 View 就是数据或资源的展示，通常来说是 JSON 格式的文本。\nController——控制器\n负责视图和模型之间的交互。包括 API 消费者传入和请求的数据。\n创建项目 模板选择 “ASP.NET Core Web 应用程序”，项目模板选择 “.NET Core”、 “ASP.NET Core 5.0” 和 “ASP.NET Core Web API”\nProgram.cs 程序入口，创建 HostBuilder，调用 StartUp.cs\nStartUp.cs 构造函数注入了应用程序的设置 Configuration\n方法 ConfigureServices 用来注册服务：\n1 2 // 添加一个Singleton的服务 services.AddSingleton\u0026lt;接口, 实现\u0026gt;(); 生命周期分为三种：\nTransient : 每次被请求这个服务的时候都会生成一个新的实例； Scoped : 每次 Web 请求的时候生成一个新的实例，生命周期到 Web 请求最终处理完； Singleton : 一旦被创建，每次请求都是这一个实例； 方法 Configure 用来加入管道中间件：\n1 2 // 加入管道中间件路由 app.UseRouting(); 管道概念是HTTP请求通过的一个 “管子”，中间穿插有各种中间件进行处理，比如身份认证、路由等。\n如果某个中间件处短路，则不会递给下一中间件而直接返回这个中间件对它处理的结果。比如身份验证未通过等。\n如果一切正常则会在管道里一直走，到最后一个中间件进行处理，然后从管道里返回。\n中间件的顺序是非常重要的\n默认的启动配置是在 ./Properties/launchSettings.json 中\n数据存储 这里 ORM 框架使用 EF（EntityFrameworkCore），数据库使用 SQLite\n安装NuGet包 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Tools 建立Model 创建文件夹 Entities； 创建模型类\n可以键入prop 然后按两下 TAB 键使用代码片段自动补全字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Company { public Guid Id { get; set; } public string Name { get; set; } public string Introduction { get; set; } public ICollection\u0026lt;Employee\u0026gt; Employees { get; set; } } public class Employee { // 主键 public Guid Id { get; set; } // 外键 public Guid CompanyId { get; set; } public string EmployeeNo { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public Gender Gender { get; set; } public DateTime DateOfBirth { get; set; } public Company Company { get; set; } } public enum Gender { Man, WoMan } 建立数据库上下文 创建文件夹 Data 创建类 RoutineDbContext ，继承于 DbContext ，构造函数需要包含参数。并且要调用父类的构造函数将其传入。 1 2 3 4 public RoutineDbContext(DbContextOptions\u0026lt;RoutineDbContext\u0026gt; options): base(options) { } 添加 DbSet 属性 1 2 3 public DbSet\u0026lt;Company\u0026gt; Companies { get; set; } public DbSet\u0026lt;Employee\u0026gt; Employees { get; set; } 对于实体一些属性的限制（比如是否必填等），通过重写 OnModelCreating 来操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 对实体的限制 protected override void OnModelCreating(ModelBuilder modelBuilder) { // 设置名称为必填 modelBuilder.Entity\u0026lt;Company\u0026gt;() .Property(it =\u0026gt; it.Name).IsRequired(); // 设置简介的长度限制 modelBuilder.Entity\u0026lt;Company\u0026gt;() .Property(it =\u0026gt; it.Introduction).HasMaxLength(500); modelBuilder.Entity\u0026lt;Employee\u0026gt;() .Property(it =\u0026gt; it.Id).IsRequired(); modelBuilder.Entity\u0026lt;Employee\u0026gt;() .Property(it =\u0026gt; it.FirstName).IsRequired(); modelBuilder.Entity\u0026lt;Employee\u0026gt;() .Property(it =\u0026gt; it.LastName).IsRequired(); // 设置实体的关系 // Employee 对应一个 Company，一个 Company 对应多个 Employee。外键为CompanyId // OnDelete 是删除时如果 Company 有 Employee 则无法删除 modelBuilder.Entity\u0026lt;Employee\u0026gt;() .HasOne(it =\u0026gt; it.Company) .WithMany(it =\u0026gt; it.Employees) .HasForeignKey(it =\u0026gt; it.CompanyId) .OnDelete(DeleteBehavior.Restrict); // 初始化添加一些成员 modelBuilder.Entity\u0026lt;Company\u0026gt;() .HasData( new Company { Id = Guid.NewGuid(), Name = \u0026#34;Microsoft\u0026#34;, Introduction = \u0026#34;巨硬公司\u0026#34; } ); } 创建服务 创建文件夹 Services 创建一个接口 ICompanyRepository\n写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface ICompanyRepository { Task\u0026lt;IEnumerable\u0026lt;Company\u0026gt;\u0026gt; GetCompaniesAsync(); Task\u0026lt;Company\u0026gt; GetCompanyAsync(Guid companyId); Task\u0026lt;IEnumerable\u0026lt;Company\u0026gt;\u0026gt; GetCompaniesAsync(IEnumerable\u0026lt;Guid\u0026gt; companyIds); void AddCompany(Company company); void UpdateCompany(Company company); void DeleteCompany(Company company); Task\u0026lt;bool\u0026gt; CompanyExistsAsync(Guid companyId); Task\u0026lt;IEnumerable\u0026lt;Employee\u0026gt;\u0026gt; GetEmployeesAsync(Guid companyId); Task\u0026lt;Employee\u0026gt; GetEmployeeAsync(Guid companyId, Guid employeeId); void AddEmployee(Guid companyId, Employee employee); void UpdateEmployee(Employee employee); void DeleteEmployee(Employee employee); Task\u0026lt;bool\u0026gt; SaveAsync(); } 创建接口的实体类 CompanyRepository 写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 public class CompanyRepository : ICompanyRepository { private readonly RoutineDbContext _context; public CompanyRepository(RoutineDbContext context) { _context = context ?? throw new ArgumentNullException(nameof(context)); } public async Task\u0026lt;IEnumerable\u0026lt;Company\u0026gt;\u0026gt; GetCompaniesAsync() { return await _context.Companies.ToListAsync(); } public async Task\u0026lt;Company\u0026gt; GetCompanyAsync(Guid companyId) { if (companyId == Guid.Empty) { throw new ArgumentNullException(nameof(companyId)); } return await _context.Companies .FirstOrDefaultAsync(it =\u0026gt; it.Id == companyId); } public async Task\u0026lt;IEnumerable\u0026lt;Company\u0026gt;\u0026gt; GetCompaniesAsync(IEnumerable\u0026lt;Guid\u0026gt; companyIds) { if (companyIds == null) { throw new ArgumentNullException(nameof(companyIds)); } return await _context.Companies .Where(it =\u0026gt; companyIds.Contains(it.Id)) .OrderBy(it =\u0026gt; it.Name) .ToListAsync(); } public void AddCompany(Company company) { if (company == null) { throw new ArgumentNullException(nameof(company)); } company.Id = new Guid(); foreach (var employee in company.Employees) { employee.Id = new Guid(); } _context.Companies.Add(company); } public void UpdateCompany(Company company) { // 实际上EF对实体都有追踪，不需要显式的更改它们 /* if (company == null) { throw new ArgumentNullException(nameof(company)); } _context.Entry(company).State = EntityState.Modified; */ } public void DeleteCompany(Company company) { if (company == null) { throw new ArgumentNullException(nameof(company)); } _context.Companies.Remove(company); } public async Task\u0026lt;bool\u0026gt; CompanyExistsAsync(Guid companyId) { if (companyId == Guid.Empty) { throw new ArgumentNullException(nameof(companyId)); } return await _context.Companies.AnyAsync(it =\u0026gt; it.Id == companyId); } public async Task\u0026lt;IEnumerable\u0026lt;Employee\u0026gt;\u0026gt; GetEmployeesAsync(Guid companyId) { if (companyId == Guid.Empty) { throw new ArgumentNullException(nameof(companyId)); } return await _context.Employees .Where(it =\u0026gt; it.CompanyId == companyId) .OrderBy(it =\u0026gt; it.EmployeeNo) .ToListAsync(); } public async Task\u0026lt;Employee\u0026gt; GetEmployeeAsync(Guid companyId, Guid employeeId) { if (companyId == Guid.Empty) { throw new ArgumentNullException(nameof(companyId)); } if (employeeId == Guid.Empty) { throw new ArgumentNullException(nameof(employeeId)); } return await _context.Employees .Where(it =\u0026gt; it.CompanyId == companyId \u0026amp;\u0026amp; it.Id == employeeId) .FirstOrDefaultAsync(); } public void AddEmployee(Guid companyId, Employee employee) { if (companyId == Guid.Empty) { throw new ArgumentNullException(nameof(companyId)); } if (employee == null) { throw new ArgumentNullException(nameof(employee)); } _context.Employees.Add(employee); } public void UpdateEmployee(Employee employee) { // 同样，EF 会追踪其中的对象，不用做更改。 } public void DeleteEmployee(Employee employee) { if (employee == null) { throw new ArgumentNullException(nameof(employee)); } _context.Remove(employee); } public async Task\u0026lt;bool\u0026gt; SaveAsync() { // 通常保存不写在Repository里 return await _context.SaveChangesAsync() \u0026gt;= 0; } } 我觉得可以把 _context.Employees 等 看作 一个 List\u0026lt;Employee\u0026gt; 类型的变量。 在 StartUp 中注册服务 1 2 3 4 5 6 7 8 9 10 // 注册服务 Scoped: 每次HTTP请求实例化一次 services.AddScoped\u0026lt;ICompanyRepository, CompanyRepository\u0026gt;(); // 连接字符串 var connectionStr = @\u0026#34;Data Source=test.db;\u0026#34;; // 注册数据库上下文 services.AddDbContext\u0026lt;RoutineDbContext\u0026gt;(option =\u0026gt; option.UseSqlite(connectionStr) ); 初始化数据库 在 NuGet 包管理器控制台中依次输入：\n1 Add-Migration InitialCreate 和\n1 Update-Database 或者使用 dotnet cli：\n1 dotnet ef migrations add InitialCreate 和\n1 dotnet ef database update 有关迁移这部分的概述可以看 迁移概述 - EF Core | Microsoft Docs\n!重要：杨旭老师在这里对 Program.cs 进行了一些修改，以便于后期讲解，我没有进行这些更改，弹幕说是个坑，先记住，如果出了什么奇怪问题就回来看看。\n","date":"2021-01-30T18:47:49+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-webapi-note1-start/","title":"如何创建 ASP.NET Core Web API——准备工作——ASP.NET Core Web API(1)"},{"content":"前言 这是学习 ASP.NET Core 的笔记，主要是根据微软 MVP 杨旭的课程来走的，当然也有自己的偏向。关于这些内容的笔记和代码以及更多的简介在Github上。\nSignalR 是.NET Core 的实现实时通讯的开源框架，抽象于长轮询、SSE 和 WS 这三种技术之上。用于实时的 web 应用。 这一篇主要是SignalR的介绍和 ASP.NET Core 项目使用SignalR等内容。\nSignalR SignalR 是.NET Core 的开源实时框架，抽象与三种技术（见下）之上。无论使用哪种技术，使用 SignalR 是没有感觉到区别的。\n用于实时的 web 应用。\n传统的是浏览器发送请求、服务器处理请求、返回 payload；实时的 web 应用由 web 服务器主动通知客户端数据有变化。\n技术 SignalR 使用了三种“底层”的技术来实现实时 Web。分别是：\nLong Polling: 长轮询； Server Sent Event; Websocket. Signal 采用了回落机制，优先使用 WS，如果浏览器不支持再降级为 SSE 和 Long Polling。\n轮询 Polling 是定期向服务器发送请求，有变化则更改数据，很简单，但是浪费资源。\n长轮询：与轮询的不同之处是如果服务器上面的数据没有更改，则保持连接（不会立即返回 HTTP 204 并断开），直到超时。超时后再次请求。\nServer Sent Events (SSE) 使用 SSE，web 服务器可以在任何时间发送数据。而客户端（浏览器）会一直监听进来的信息，这个连接也会一直开放，直到服务器主动关闭。\n浏览器会使用一个叫做 EventSource 的对象来处理传过来的信息。\n优点：使用简单，HTTP 协议。 缺点：浏览器有最大并发、只能发送文本，只能单项通讯。\nWebSocket WS 是不同于 HTTP 的另一个 TCP 协议。\n优点 使用 WS 消息可以双向发送（全双工）； 没有 HTTP 的延迟，信息流没有完成的时候 TCP 端口始终打开； 大部分情况下（现代浏览器） SignalR 会使用 WS 协议，这也是最有效的传输方式； WS 可以传输文本或者二进制文件； WS 不受 SSE 连接数限制，大部分浏览器对 WS 连接支持数为 50 个。 生命周期 发送一个 HTTP 请求到服务器进行握手； 通讯； 关闭（会返回关闭原因）。 HTTP 握手 每一个 WS 开始的时候都是一个简单的 HTTP 连接； 客户端发送 GET 请求升级 Socket(HTTP 101)； 服务器同意的话（HTTP 101），升级为 WebSocket。 消息类型 消息类型可以是文本或二进制。\n每个消息由一个或多个 Frame 组成。\nRPC RPC 的优点是可以像调用本地方法一样调用远程服务。 SignalR 采用了 RPC 范式来进行通讯。服务端和客户端可以相互调用彼此的方法。SignalR 负责序列化和反序列化。\nHub Hub 是 SignalR 的一个组件，是服务端的一个类。 在 ASP.NET Core 中自己创建的 Hub 类需要继承与基类 Hub。\n在 Hub 类里面可以调用客户端上面的方法，客户端也可以调用 Hub 类里面的方法。\nHub 可以序列化和反序列化，被序列化的参数的格式叫做 Hub 协议。Hub 的默认协议是 JSON，也支持 MessagePack（二进制的，更紧凑更快速）。\n横向扩展 负载均衡器会保证每个进来的请求按照一定的逻辑分配。但是长轮询时候请求发送到不同的服务器就很容易出问题。\n实践 配置项目 在 StartUp 中注册服务：\n1 2 3 4 5 6 7 public void ConfigureServices(IServiceCollection services) { // 添加控制器 services.AddControllers(); // 添加SignalR services.AddSignalR(); } 自定义一个测试用的类（这里写个计数调用的）\n1 2 3 4 5 6 7 public class CountService { private int Count; // 获取计数 public int GetLatestCount() =\u0026gt; Count++; } 注册服务\n1 services.AddSingleton\u0026lt;CountService\u0026gt;(); 创建一个 Hub，命名为 CountHub.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using Microsoft.AspNetCore.SignalR; namespace SignalRDemo { public class CountHub(CountService countService, ILogger\u0026lt;CountHub\u0026gt; logger): Hub { // 获取总和 public async Task GetLatestCount() { var userName = Context.User.Identity.Name; logger.LogDebug(\u0026#34;user name: {name}\u0026#34;, userName); int cnt; do { cnt = countService.GetLatestCount(); Task.Delay(100); // 向所有客户端（正经写应该是返回给Connect的客户端？）返回新的数据 await Clients.All.SendAsync(\u0026#34;ReceiveUpdate\u0026#34;, cnt); } while (cnt \u0026lt; 10); await Clients.All.SendAsync(\u0026#34;Finished\u0026#34;); } // ... // Code // ... } } 使用 Hub：配置端点，加入\n1 2 // 使用Hub，参数为亲求的端点 endpoints.MapHub\u0026lt;CountHub\u0026gt;(\u0026#34;/count\u0026#34;); 创建一个控制器 CountController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace SignalRDemo.Controllers { [Route(\u0026#34;api/count\u0026#34;)] public class CountController: Controller { private readonly IHubContext\u0026lt;CountHub\u0026gt; CntHub; // 注入Hub public CountController(IHubContext\u0026lt;CountHub\u0026gt; cntHub) { CntHub = cntHub; } // Post请求时返回执行客户端上的方法\u0026#34;SomeFunc\u0026#34;，传递参数对象 public async Task\u0026lt;IActionResult\u0026gt; Post() { await CntHub.Clients.All.SendAsync(\u0026#34;SomeFunc\u0026#34;, new { random = \u0026#34;object\u0026#34; }); return Accepted(1); } } } 在 Hub 中重写 OnConnectedAsync() 来执行一些方法：\n1 2 3 public override async Task OnConnectedAsync() { } 常见的操作有：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 获取ConnectId var ConnectId = Context.ConnectionId; // 获取当前客户端 var client = Clients.Client(ConnectId); // 执行客户端上面的一个方法，参数为 方法名、参数（对象） await client.SendAsync(\u0026#34;SomeFunc\u0026#34;, new { }); // 除了这个客户端（指定ConnectId）以外，其它的客户端执行 await Clients.AllExcept(ConnectId).SendAsync(\u0026#34;SomeFunc\u0026#34;); // 将某个客户端加入组，参数为ConnectId和字符串组名 await Groups.AddToGroupAsync(ConnectId, \u0026#34;myGroup\u0026#34;); // 将某个客户端移除，参数同上 await Groups.RemoveFromGroupAsync(ConnectId, \u0026#34;myGroup\u0026#34;); // 对某组中的客户端执行某个方法 await Clients.Group(\u0026#34;myGroup\u0026#34;).SendAsync(\u0026#34;SomeFunc\u0026#34;); 使用 Hub 身份认证，需要加入 [Authorize] 属性\n可以使用\n1 var userName = Context.User.Identity.Name; 获取认证的用户名。其它属性也类似。\n至于 SignalR，我会以后有时间来研究一下。\n客户端 使用 libman 安装 SignalR@next\nJavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 let connection = null; setupConnection = () =\u0026gt; { // 设置连接，其中withUrl是请求的url connection = new signalR.HubConnectionBuilder().withUrl(\u0026#34;/api/count\u0026#34;).build(); // 获得返回值，这里的第一个字符串参数是Hub中Clint.SendAsync(\u0026#34;ReceiveUpdate\u0026#34;, cnt)中的第一个参数（？可以看作是双方的一个约定） connection.on(\u0026#34;ReceiveUpdate\u0026#34;, (update) =\u0026gt; { // 打印返回的更新数据 console.log(update); // 更改ID为resultDiv的节点内容（jq） $(\u0026#34;##resultDiv\u0026#34;).text(update); }); connection.on(\u0026#34;SomeFunc\u0026#34;, function (obj) { console.log(obj); // SomeFunc是客户端的方法，obj则是传入的参数 }); // 开始这个连接 connection .start() .catch((error) =\u0026gt; console.error(\u0026#34;ERROR!\u0026#34; + error.toString())); }; setupConnection(); // 执行服务端方法，字符串参数为方法名，后面为参数 connection.invoke(\u0026#34;GetLatestCount\u0026#34;, id); ","date":"2021-01-30T13:32:57+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-note5-signalr/","title":"在 ASP.NET Core 中的实时通信——SignalR 实时通信——ASP.NET Core 入门(3)"},{"content":"前言 这是学习ASP.NET Core的笔记，主要是根据微软MVP杨旭的课程来走的，当然也有自己的偏向。关于这些内容的笔记和代码以及更多的简介在 Github 上。\nASP.NET Core 提供了一个默认的配置文件——\u0026ldquo;appsettings.json\u0026rdquo;，这个文件中写了启动ASP.NET Core的一些配置，比如环境、log 等级等，也支持写入自定义的 JSON 对象。\n这一篇主要是看 ASP.NET Core 项目的配置文件等内容。\nASP.NET Core 中的配置信息 特点 使用键值对； 存储在内存、JSON、XML、INI 等文件，或者系统环境变量； 配置信息与配置系统是解耦的，不是和某一部分写死的； 可以依赖注入。 第 2 条即配置可以以多种形式分别存储，并不是某一个固定的文件，他们共同组成了逻辑上的“配置”。\n信息源 按照查找顺序排序\n配置文件通常为 appsettings.json 和 appsettings.{Environment}.json Secret Manager（一种 .NET 命令行工具，用于管理用户机密）（优先级高于 appsettings.json ） 环境变量 命令行参数（优先级最高） 自定义配置 在 appsettings.json 里面添加自定义信息； 在 StartUp 的构造方法中添加参数，类型为 IConfiguration ，赋值给一个 readonly 的私有变量，或者只有 get 访问器的变量； 使用索引获取 实际上这个接口对象实际上是一个存有配置信息键值对的列表，可以通过索引比如：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;Logging\u0026#34;: { // ... // Some Key-value // ... }, \u0026#34;AppConfig\u0026#34;: { \u0026#34;port\u0026#34;: 3306 } } CSharp\n1 2 var myConfig = Configuration[\u0026#34;AppConfig:port\u0026#34;]; // string myConfig = \u0026#34;3306\u0026#34; 映射到模型 但是 C# 作为强类型语言，比较好的做法是用强类型表示，可以避免很多错误。\n将自定义的 JSON 对象映射到一个 类/结构体/记录 中：\n创建类 1 2 3 4 5 public record AppConfig { // 字段名称和JSON文件中应该是对应的 public int Port { get; set; } } 注册服务 1 2 3 4 // 其中GetSection的参数是string 键 services.Configure\u0026lt;AppConfig\u0026gt;( Configuration.GetSection(nameof(AppConfig)) ); 使用自定义配置文件，如 config.json ，需要更改 CreateHostBuilder 方法，使其返回值调用 ConfigureAppConfiguration 方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) // 调用这个方法 .ConfigureAppConfiguration((context, configBuilder) =\u0026gt; { // 清除源 configBuilder.Sources.Clear(); // 添加json文件夹 configBuilder.AddJsonFile(\u0026#34;config.json\u0026#34;); }) // ... // Code // ... ; 使用配置 完成上文的服务注入后：\n在接口中注入，构造函数添加以下参数：\n1 2 3 4 5 6 public SomeMethod(IOptions\u0026lt;AppConfig\u0026gt; options) { // ... // Codes // ... } ","date":"2021-01-28T02:19:14+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-note3-config/","title":"如何配置 ASP.NET Core 应用程序——配置文件——ASP.NET Core 入门(2)"},{"content":"前言 不知不觉新的一年来了，大学半年生活也落下帷幕。经过这半年和各位大佬们的摸鱼，深感自身技能不足，趁着寒假没什么事情，学习一下 web 框架——ASP.NET Core（主要是后端部分）。选择 ASP.NET Core 是因为 ASP.NET Core 是高效的 web 框架，同时自己用了挺长时间的 C# ，转战其它语言也挺不习惯。另外，算是半个软粉了。\n不过有一个缺点是，ASP.NET 这玩意老是自动蓝成链接。\n这是学习 ASP.NET Core的笔记，主要是根据微软 MVP 杨旭的课程来走的，当然也有自己的偏向。关于这些内容的笔记和代码以及更多的简介在Github上。\n这一篇主要是看 ASP.NET Core 项目的结构、配置以及一些基础的内容。\nASP.NET Core ASP.NET Core 和 ASP.NET 不是一回事，ASP.NET Core 基于.NET Core（或者 .NET 5 以及更新的版本），它的效率远高于基于 .NET Framework 的 ASP.NET。\nASP.NET Core 项目本质上仍然是 .NET Core 控制台应用。\n项目基本结构（旧模板） Main 方法 程序入口点，配置整个 ASP.NET Core 然后运行。\n调用了一个静态方法\n1 IHostBuilder CreateHostBuilder(string[] args) 调用这个方法，返回 IHostBuilder 执行 Build() 方法后控制台项目转变为了 ASP.NET Core 项目，然后执行 Run() 方法启动。\nCreateHostBuilder 方法 lambda 表达式\n1 2 3 4 5 6 7 public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults( // ... // Code // ... ); ，右侧返回调用 Host 静态类的一个静态方法 CreateDefaultBuilder() 的返回调用 ConfigureWebHostDefaults() 方法，配置 ASP.NET Core。\n第二个 lambda 表达式\n1 2 3 4 5 6 7 8 // ... // Code // ... Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); 左侧参数名为自动推断类型的 webBuilder ，将 WebBuilder 的一些方法返回作为参数传入。\n这部分可以配置 ASP.NET Core 相关的内容，只需要调用 webBuilder.\u0026lt;方法\u0026gt;()\n然后 webBuilder 使用 StartUp 类来初始化。\nStarUp 类文件 这个类没有实现任何的接口等，这里面方法的名称是运行时的约定名称，运行时通过名字来进行调用两个方法：ConfigureServices和Configure。\nConfigureServices 方法 负责配置依赖注入（DI）等\n依赖注入 DI 它是 ASP.NET Core 不可分割的一部分，依赖于 IoC 容器。\n首先在 ASP.NET Core 启动时会进行注册，可以向 IoC 容器请求被注册的服务的示例。在注册时可以配置被注册的服务的生命周期。\n生命周期分为三种：\nTransient : 每次被请求这个服务的时候都会生成一个新的实例； Scoped : 每次 Web 请求的时候生成一个新的实例，生命周期到 Web 请求最终处理完； Singleton : 一旦被创建，每次请求都是这一个实例； 注册服务 使用通过 IServiceCollection 接口的变量 service 注册服务，比如 MVC 的注册方法：\n1 services.AddControllersWithViews(); // 传统 ASP.NET Core MVC 不需要 Views 做 API 只用 Controllers 则使用\n1 services.AddControllers(); // 添加控制器 自定服务 创建一个文件夹(通常命名为\u0026quot;Services\u0026quot;)\n新建一个接口，比如 IClock\n1 public interface IClock {} 新建 CSharp 类，实现接口\n1 public class ChineseClock: IClock {} 注册自己写的服务：\n1 2 3 4 services.AddTransient\u0026lt;\u0026gt;(); services.AddScoped\u0026lt;\u0026gt;(); services.AddSingleton\u0026lt;\u0026gt;(); // 注册指定生命周期的服务 比如：\n1 2 // 泛型：有实例请求IClock接口的对象,返回ChineseClock类型的实例 services.AddSingleton\u0026lt;IClock, ChineseClock\u0026gt;(); 使用服务：\n建立文件夹 Controllers ，ASP.NET Core 一般都有一个文件夹叫做这个名字，里面放着所有的控制器；\n新建类 xxxxController.cs ，按照约定，应该以 \u0026quot;Controller\u0026quot; 结尾;\n首先让新建的这个类（比如 HomeController ）继承 Controller（在命名空间 Microsoft.AspNetCore.Mvc 下，疑似已经更改为 ControllerBase）这个父类；\n写构造函数，参数类型为前面定义的接口；\n1 2 3 4 5 6 public class HomeController: Controller { public HomeController(IClock clock) { } } 注册服务后，传给控制器的参数的类型为泛型的第二个参数；这样写实现一个接口可以保证在更改服务注入其它类的时候不需要更改控制器的传入参数。这样可以使控制器和具体的服务类解耦。\nDI 的优点 解耦，没有强依赖，利于进行单元测试； 不需要了解具体的服务类； 不需要手动管理服务类的生命周期。 Configure 方法 实际上传入的参数 IApplicationBuilder app 对应的是一个服务，通过依赖注入（在 CreateHostBuilder() 时候）注入进来。\n此方法用来配置 ASP.NET Core 对处理 HTTP 请求的管道（pipeline），指定整个应用对 HTTP 请求的处理方法，HTTP 请求从管道进去，又从管道返回。\n管道与中间件 如果管道什么也没有，那么对 HTTP 请求不会做任何处理。\n放在管道里面、处理请求的叫做中间件。\n中间件：开发模式设置 1 2 3 4 5 6 // 判断是否为开发模式 if (env.IsDevelopment()) { // 开发模式中间件：显示错误信息页面 app.UseDeveloperExceptionPage(); } 可以通过设置环境变量来启用或关闭开发模式。开发模式时 env.IsDevelopment() 即返回 true 。\n环境变量名称为： ASPNETCORE_ENVIRONMENT 值为：\n开发环境——\u0026ldquo;Development\u0026rdquo; 生产环境——\u0026ldquo;Production\u0026rdquo; 预发布环境——\u0026ldquo;Staging\u0026rdquo; 自定义环境——\u0026ldquo;自定义字符串\u0026rdquo; 使用 env.IsEnvironment(\u0026quot;自定义字符串\u0026quot;) 来判断自定义环境变量。\n中间件：路由 1 app.UseRouting(); // 中间件：使用路由 路由中间件能判断 HTTP 请求出现在那个端点。\n中间件：端点 端点就是 HTTP 请求的 URL 的结尾部分。这一部分会被中间件件处理。\n比如 https://api.gaein.cn/WebCommitApi/write 中 WebCommitApi/write 就是端点。\n1 2 3 4 5 6 7 8 9 app.UseEndpoints(endpoints =\u0026gt; { // 对端点进行配置 endpoints.MapGet(\u0026#34;/\u0026#34;, async context =\u0026gt; { // 匹配端点后在浏览器打印HW await context.Response.WriteAsync(\u0026#34;Hello World!\u0026#34;); }); }); 通过 lambda 表达式来配置端点。\n如果使用属性标签（就是在 Action 上面中括号书写路由的话），只需要这样就可以了。\n1 2 3 4 app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); }); 中间件：静态文件 如果需要静态文件的话（返回 HTML、JS 等）需要中间件。\n1 app.UseStaticFiles(); 想要使用静态文件，需要新建文件夹名为wwwroot，在文件夹里面的静态文件可以被访问到（不需要在 URL 加上\u0026quot;wwwroot\u0026quot;）。\n图片存储的路径为 ./wwwroot/daily-picture/today.png\n则 url 为 https://api.gaein.cn/daily-picture/today.png\n中间件：强制 HTTPS 如果需要将 HTTP 请求强制跳转到 HTTPS 则需要中间件。\n1 app.UseHttpsRedirection(); 中间件顺序 中间件的顺序就是处理的顺序，顺序很重要。比如 Auth 会放在前边，路由、端点等写在认证的后边。\n项目基本结构（新模板） 新的模板使用了顶级语句来作为程序入口，详见 Top-level statements - programs without Main methods - C# | Microsoft Learn。\n开头即使用 WebApplication 的静态方法来创建 builder。\n1 var builder = WebApplication.CreateBuilder(args); 之后使用 builder 的 Services 属性和 Configuration 属性来访问和添加服务，具体代码与上文相同。\n之后通过\n1 var app = builder.Build(); 来构建主机，构建后设置中间件与上文相同。\n运行 ASP.NET Core 应用 在 VS 中运行时，有两个选项：可以选择 IIS Express，也可以选择项目本身（ASP.NET Core 控制台应用内嵌了一个 Web 服务器，名叫 Kestrel）。\n可以在“项目”-\u0026gt;“右键”-\u0026gt;“属性”来配置启动时候的工作。\n环境设置 通过环境变量设置； 通过约定名称方法，比如 Configure() 方法和 ConfigureDevelopment() 方法。 通过约定名称类，比如 StarUpDevelopment 类。注意，需要设置 Program.cs 文件中的 webBuilder ，将其更改为 1 webBuilder.UseStartup(typeof(Program)); 包管理 后端 NuGet 前端 但是实际上手的话前后端分离香一些\nNPM 添加 package.json 文件（有模板） 在 devDependencies 中添加包，使用 json 键值对来设置包和版本，比如： 1 2 3 \u0026#34;devDependencies\u0026#34;: { \u0026#34;aPlayer\u0026#34;: \u0026#34;1.10.1\u0026#34; } LibMan “右键”-\u0026gt;“添加”-\u0026gt;“添加客户端库” “提供程序”选择\u0026quot;unpkg\u0026quot; 搜索、安装，会自动安装到 wwwroot 文件夹 ","date":"2021-01-26T22:35:31+08:00","permalink":"https://blog.gaein.cn/passages/aspnetcore-note1-projects/","title":"ASP.NET Core 代码各个文件都是什么——项目结构——ASP.NET Core 入门(1)"},{"content":"使用 GLFW 库自带的函数设置窗口置于顶层前端显示。起因：一位群友问到这个问题，在网上查找 GLFW 前端显示窗口和 OpenGL 前端显示窗口无果后翻阅 GLFW 的 docs 找到了解决方案。写个博客记录一下。\n起因 群友在群里问有没有会 OpenGL 的，虽然我不会但是肯定要凑热闹假装会啊。它的需求是创建一个窗口，显示在最顶层（即使是有全屏程序的情况下）大概就是类似于录屏工具的样子。\n过程 在网上几番搜索没用结果后我干脆直接翻看了 GLFW 的官方文档（果然那玩意才是最好用的）\n一开始我以为是在创建窗口glfwCreateWindow()时候传入参数里面设置置顶。但是并没有相关的参数，倒是发现了全屏的方法。\n继续查阅函数列表，希望找到一个能置顶窗口的函数，类似于glfwSetWindowTop()这样名字的。但是一番查找无果。像glfwShowWindow ( GLFWwindow * window ) 显示窗口和void glfwFocusWindow ( GLFWwindow * window ) 聚焦窗口都不是我想要的，聚集窗口会把焦点移动到窗口上，如果你打游戏时候干了这怕是要被打死。\n最后引起我注意的是函数\n1 2 3 4 void glfwSetWindowAttrib\t(\tGLFWwindow * window, int attrib, int value ) 它的意思是设置窗口的属性，我想，置顶不正是一种属性嘛？于是我跳转到了glfwSetWindowAttrib()的页面，用法很简单，和想象的一样。里面有个链接到Window attributes，及窗口的所有属性列表。在这里我们可以看到一个叫做GLFW_FLOATING属性，它的介绍是：\nGLFW_FLOATING indicates whether the specified window is floating, also called topmost or always-on-top. This can be set before creation with the GLFW_FLOATING window hint or after with glfwSetWindowAttrib.\n它可以让窗口浮动，也就是置顶（always-on-top）这正是我们想要的了！\n实施 随便打开了以前测试 OpenGL 环境的项目，我的想法是按下T键置顶，这样可以有一个前后对比。在监听按键的函数里面如下写道：\n1 2 3 4 5 6 // 按下T设置浮动 if (glfwGetKey(window, GLFW_KEY_T) == GLFW_PRESS) { printf(\u0026#34;[INFO]监测到置顶窗口\u0026#34;); glfwSetWindowAttrib(window, GLFW_FLOATING, GLFW_TRUE); } 启动程序，点击其它程序发现可以覆盖我们的窗口。焦点在窗口时按下T，然后再将其它程序拖动过去，发现不能覆盖。 全屏播放视频和全屏游戏也不能将我们的窗口覆盖。至此目的达成。\n总结 使用如下代码将窗口置顶，其中window是窗口指针\n1 glfwSetWindowAttrib(window, GLFW_FLOATING, GLFW_TRUE); 使用如下代码取消窗口置顶，其中window是窗口指针\n1 glfwSetWindowAttrib(window, GLFW_FLOATING, GLFW_FALSE); 参考 GLFW 文档\nGLFW 文档 -\u0026gt; 窗口参考\nGLFW 文档 -\u0026gt; 窗口参考:glfwSetWindowAttrib\nGLFW 文档 -\u0026gt; 窗口导览 -\u0026gt; 窗口属性\nGLFW 文档 -\u0026gt; 窗口导览 -\u0026gt; 窗口属性:GLFW_FLOATING\n","date":"2020-12-26T01:27:00+08:00","permalink":"https://blog.gaein.cn/passages/glfw-window-float/","title":"OpenGL GLFW 窗口前端显示"},{"content":"SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用 C 语言写成。SDL 提供了数种控制图像、声音、输出入的函数。简单易用。这篇文章介绍一下我在 Windows 下 CLion 配置 SDL2 开发环境的方法。\n配 SDL2 还是由于大一的 C 语言程序设计课设。由于我始终不愿意使用 EasyX，却由于 GLFW 太过复杂而担心无法完成作业\n其实我的担心是多余的，以我的实力，根本不用担心，就是完不成\n所以采用了学 姐 长 @HelloWorld 的建议，使用了 SDL。不过配置的过程中遇到了很多问题，在这里记录并分享一下。\n环境：\nCLion 2020.3 Build 203.5981.166 Windows10 20H2 19042.685 MinGW-w64 GCC 8.1.0(x86_64-posix-seh-rev0) SDL2-2.0.12 [DEV] SDL2 配置 下载 SDL2 打开 SDL 官网的下载页 LibSDL.org 下载 \u0026ldquo;Development Libraries\u0026rdquo; (开发版)中的 \u0026ldquo;Windows\u0026rdquo;-\u0026gt;\u0026ldquo;MinGW 32/64-bit\u0026rdquo;\n我下载的是\u0026ldquo;SDL2-devel-2.0.12-mingw.tar.gz\u0026rdquo;\n(注：此链接不确保时效性，请去官网下载最新版本)\n配置 SDL2 解压缩下载的 \u0026ldquo;SDL2-devel-2.0.12-mingw.tar.gz\u0026rdquo; ，将 \u0026ldquo;x86_64-w64-mingw32\u0026rdquo; 中的所有文件复制到你 MinGW-w64 的目录中。\n如果你的 MinGW 是 i686 则复制\u0026quot;i686-w64-mingw32\u0026quot;中的所有文件。 (注：在终端中使用 gcc -v 可以查看到 MinGW-w64 的版本) 在项目目录下新建一个文件夹\u0026quot;SDL\u0026quot;，将\u0026quot;include\u0026quot;中的\u0026quot;SDL2\u0026quot;，复制到项目目录下\u0026quot;SDL\u0026quot;文件夹中 CMake 配置 新建 在 CLion 中点\u0026quot;文件\u0026quot;-\u0026gt;\u0026ldquo;新建项目\u0026rdquo;，选择 C++(C 也可以) 配置 将\u0026quot;CMakeLists.txt\u0026quot;按照如下内容修改：\n(注：文件的内容根据你的项目决定，一般来说不用修改默认生成的) 1 2 3 4 5 6 7 8 9 10 11 12 # 设置CMake需要的版本 cmake_minimum_required(VERSION 3.17) # 设置项目名称 project(SDL2_Test) # 设置C++版本 set(CMAKE_CXX_STANDARD 20) # 设置includePath include_directories(SDL) # 生成文件 add_executable(SDL2_Test main.cpp) # 链接库 target_link_libraries(SDL2_Test mingw32 SDL2main SDL2) 测试 在 \u0026ldquo;main.cpp\u0026rdquo; 中写入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;SDL2/SDL.h\u0026#34; int main(int argc, char *argv[]) { // 初始化SDL SDL_Init(SDL_INIT_VIDEO); // 创建SDL窗口指针 SDL_Window *window = SDL_CreateWindow( \u0026#34;SDL2Test\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, 0 ); // 创建渲染器 SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE); // 设置渲染器 SDL_SetRenderDrawColor(renderer, 0, 0, 0, SDL_ALPHA_OPAQUE); SDL_RenderClear(renderer); // 渲染 SDL_RenderPresent(renderer); // 等待3000ms SDL_Delay(3000); // 销毁窗口\u0026amp;退出 SDL_DestroyWindow(window); SDL_Quit(); return 0; } 点击右上角的三角运行，如果出现\n无法找到头文件：检查是否复制\u0026quot;include\u0026quot;和设置\u0026quot;include_directories(SDL)\u0026quot; 找不到WinMain：检查是否复制库。或者尝试调换\u0026quot;target_link_libraries(SDL2_Test mingw32 SDL2main SDL2)\u0026ldquo;中库的顺序 说明 有些同学可能很迷惑：为什么要把SDL扔进MinGW-w64的目录里面呢？因为我在外面的目录尝试的时候各种报错，后来看了 CSDN:CLion配置SDL2开发环境（Windows系统）。貌似把SDL扔进mingw目录就能解决。具体原因还有待深究。 其它方法：使用vcpkg可以安装，也可以使用CMake模块： GitHub:SDL2-CMake-Scripts GitHub:CMake-SDL 参考：\nSDL官网:SDL-WIKI Trenki\u0026rsquo;s Dev Blog:Using SDL2 with CMake JetBrains-Community:Configuring SDL2 with CLion adolfans:SDL中文教程 CSDN:CLion配置SDL2开发环境（Windows系统） CMake:FindSDL ","date":"2020-12-16T23:51:22+08:00","permalink":"https://blog.gaein.cn/passages/config-sdl2-on-clion-win/","title":"Windows下CLion配置SDL2开发环境"},{"content":"学校的C语言程序设计课设是编写一个图形化的程序，学校方面采用的是EasyX，当然也允许其它图形库，因此我准备学习OpenGL\nEasyX虽然可能比OpenGL简单一些，但是可能不如OpenGL应用面更广泛，也不如OpenGL更有挑战性。\n基本 笔记 OpenGL是一个图形API，需要一个编程语言来工作，因此我选择C/C++，在不需要用到C++特性的情况下会使用C来编写（因为毕竟是C语言程序设计课设）。我使用的教程是LearnOpenGL CN和《OpenGL编程指南》（忘了是那一版了，实验室的书；大部分情况下会使用LearnOpenGL CN网站的教程）\nOpenGL 早期的OpenGL使用立即渲染模式（固定渲染管线），这个模式下绘制图形很方便。从OpenGL3.2开始，立即渲染模式开始被废除，鼓励使用核心模式。\nOpenGL自身是一个巨大的状态机：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。 （OpenGL自己搓了面向对象）一般来说，我们创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。\nGLFW GLFW是一个库，提供了渲染物体的最低限度的接口。\n获取 官方网站下载页\n使用预编译的二进制版本时下载32位，因为64位可能有奇奇怪怪的问题。\n链接 “右键项目”-\u0026gt;“属性”-\u0026gt;“VC++目录”，在“包含目录”和“库目录”中添加GLFW的include文件夹； 在“链接器”-\u0026gt;“输入”-\u0026gt;“附加依赖项”中加入\u0026quot;glfw3.lib\u0026quot;、\u0026quot;opengl32.lib\u0026quot; GLAD 由于OpenGL驱动版本众多，因此大多数函数在编译时没有确定的位置，在运行时查询的工作量很大，因此使用GLAD库来解决。\n配置GLAD 打开GLAD在线服务； 设置语言为C/C++； OpenGL版本选择3.3及以上； 模式设置为Core； 选中生成加载器(Generate a loader)； 点击生成(Generate)按钮。 使用GLAD 将生成的文件添加到include目录中 引用头文件\n1 ##include \u0026lt;glad/glad.h\u0026gt; 来使用\n你好，窗口 在main()函数中\n","date":"2020-11-13T20:50:55+08:00","permalink":"https://blog.gaein.cn/passages/opengl-note1-firstwindow/","title":"OpenGL学习笔记——第一个窗口"},{"content":"中北大学 AI+移动互联创新实验室 C语言培训作业，力扣第20题有效的括号 题解\n这道题感觉很简单，但是吧，做起来还真不简单。对于人类来说理解判断似乎不难，但是对于计算机来说可能就比较麻烦了。起初我写了很多判断，但是依旧无法实现。经过党明学姐的启发，我觉得使用栈，官方题解上使用的是数组，其实数组就可以做一个简单的栈。不过数组很可能造成内存的浪费，经过李涛的启(qī)发(piàn)自己搓了一个链式栈。\n题干 [力扣-有效的括号]\n给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串，判断字符串是否有效。 有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1:\n1 2 输入: \u0026#34;()\u0026#34; 输出: true 示例 2:\n1 2 输入: \u0026#34;()[]{}\u0026#34; 输出: true 示例 3:\n1 2 输入: \u0026#34;(]\u0026#34; 输出: false 示例 4:\n1 2 输入: \u0026#34;([)]\u0026#34; 输出: false 示例 5:\n1 2 输入: \u0026#34;{[]}\u0026#34; 输出: true 栈 思路 起初我写了很多判断，但是依旧无法实现。经过党明学姐的启发，我觉得使用栈，官方题解上使用的是数组，其实数组就可以做一个简单的栈。不过数组很可能造成内存的浪费，经过李涛的启(qī)发(piàn)自己搓了一个链式栈。\n做法是首先判断是否为空字符串，为空则返回true，不为空则遍历字符数组，当匹配到左括号{、[、(时候，将左括号入栈。\n继续遍历，发现右括号后将其和栈顶的左括号匹配，匹配成功则将其出栈，继续进行循环，直到读取到'\\0'为止。\n如果\n没有任何括号入栈 遍历结束后栈不为空 则返回false 代码 官方题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 char pairs(char a) { if (a == \u0026#39;}\u0026#39;) return \u0026#39;{\u0026#39;; if (a == \u0026#39;]\u0026#39;) return \u0026#39;[\u0026#39;; if (a == \u0026#39;)\u0026#39;) return \u0026#39;(\u0026#39;; return 0; } bool isValid(char* s) { int n = strlen(s); if (n % 2 == 1) { return false; } int stk[n + 1], top = 0; for (int i = 0; i \u0026lt; n; i++) { char ch = pairs(s[i]); if (ch) { if (top == 0 || stk[top - 1] != ch) { return false; } top--; } else { stk[top++] = s[i]; } } return top == 0; } 我的题解 由于手搓了一个链式栈，所以代码很长\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 /*AI+移动互联创新实验室 C语言培训练习题 有效的括号 | 力扣-20*/ ##include \u0026lt;stdio.h\u0026gt; ##include \u0026lt;stdbool.h\u0026gt; ##include \u0026lt;string.h\u0026gt; ##include \u0026lt;malloc.h\u0026gt; // 结构体栈 typedef struct _Node { char value; struct _Node *next; struct _Node *last; } Node; // 结构体栈 typedef struct _Stack { Node *top; } Stack; // 函数声明 void stackPush(Stack *st, char val); char stackPop(Stack *st); bool isOdd(int num); Stack *stackInit(char in); void bracketsTableInit(); char bracketsTable(char ch); // 定义对应表 char table[126] = { 0, }; // bool isValid(char *s); // int main(int argc, char const *argv[]) // { // char ch[] = \u0026#34;()[]{}\u0026#34;; // if (isValid(ch)) // { // printf(\u0026#34;%s \\n\u0026#34;, \u0026#34;有效\u0026#34;); // } // else // { // printf(\u0026#34;%s \\n\u0026#34;, \u0026#34;无效\u0026#34;); // } // return 0; // } // 测试用代码 bool isValid(char *s) { int LENGTH = strlen(s); bool ret = true; if (!isOdd(LENGTH)) { bracketsTableInit(); if (bracketsTable(*s)) { // 匹配到左括号 Stack *st = stackInit(*s); // 入栈 s++; // 移到下一个字符 bool hasR = false; // 默认有对应的右边为false for (int i = 1; i \u0026lt; LENGTH; i++, s++) { // 循环遍历字符数组 if (bracketsTable(*s)) { // 左括号入栈 stackPush(st, *s); } else { //右括号，设置hasR为true并且出栈 hasR = true; char inSt = bracketsTable(stackPop(st)); // printf(\u0026#34;%c %c\\n\u0026#34;,inSt,*s ); if (inSt != *s) { // 无法匹配 ret = false; break; } else { // 匹配并跳到下一循环 continue; } } } if (!hasR) { // 未找到右括号 ret = false; } if (st-\u0026gt;top != NULL) { // 栈未出空 ret = false; } } else { ret = false; } } else { ret = false; } return ret; } Stack *stackInit(char in) { Node *newNode = (Node *)malloc(sizeof(Node)); // 新建栈节点 Stack *newSt = (Stack *)malloc(sizeof(Stack)); // 新建栈 newNode-\u0026gt;value = in; // 节点值 newNode-\u0026gt;next = NULL; // 置空节点next newNode-\u0026gt;last = NULL; // 置空节点last newSt-\u0026gt;top = newNode; // 栈顶指向节点 return newSt; } // 入栈 void stackPush(Stack *st, char val) { Node *newNode = (Node *)malloc(sizeof(Node)); // 新建栈节点 newNode-\u0026gt;value = val; // 设置栈节点的值 newNode-\u0026gt;next = NULL; // 置空节点next newNode-\u0026gt;last = NULL; if (st-\u0026gt;top != NULL) { // 判空 st-\u0026gt;top-\u0026gt;next = newNode; // 将节点加入栈 newNode-\u0026gt;last = st-\u0026gt;top; // 设置节点的last } st-\u0026gt;top = newNode; // 指向新节点 } // 出栈 char stackPop(Stack *st) { char ret = \u0026#39;\\0\u0026#39;; if (st-\u0026gt;top != NULL) { if (st-\u0026gt;top-\u0026gt;last == NULL) { // 仅有一个栈 ret = st-\u0026gt;top-\u0026gt;value; // 取值 st-\u0026gt;top = NULL; // 置空 // free(st-\u0026gt;top); } else { Node *del = st-\u0026gt;top; // 临时节点 st-\u0026gt;top = del-\u0026gt;last; // 修改栈顶 st-\u0026gt;top-\u0026gt;next = NULL; // 取消栈与del节点的链接 del-\u0026gt;last = NULL; // 取消del节点与栈的链接 ret = del-\u0026gt;value; // 取ret值 free(del); // 释放内存 del = NULL; // 设置NULL } } return ret; } // 判断是否能出栈 bool stackCanPop(Stack *st) { return (st-\u0026gt;top != NULL); } // 判断是否为奇数 bool isOdd(int num) { return num \u0026amp; 1 ? true : false; } // 初始化对应表 void bracketsTableInit() { table[\u0026#39;(\u0026#39;] = \u0026#39;)\u0026#39;; table[\u0026#39;[\u0026#39;] = \u0026#39;]\u0026#39;; table[\u0026#39;{\u0026#39;] = \u0026#39;}\u0026#39;; } // 查询对应空格 char bracketsTable(char ch) { return table[ch]; } 这次只使用了C语言，因为CSharp反转链表应该不难，list.Reverse();（逃）\n结果 仅有一次循环，使用迭代的方法还是蛮快的，完成了力扣的任务。但是递归我实在不会，甚至不能很好的区分它们。所以暂时就没有写递归方法。 最后 这道题的话还是比较简单的，毕竟画起图来感觉不难，但是实际写起来还是有一定挑战性的。通过这道题顺手复习了忘干净的链表，也是非常好的。链表的题先画图理解一下有很大帮助，尤其是自己用笔手动遍历一下，利于理解过程。\n","date":"2020-11-13T11:25:24+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-20-validparentheses/","title":"有效的括号-力扣20 栈"},{"content":"中北大学 AI+移动互联创新实验室 C语言培训作业，力扣第206题反转链表 题解\n反转链表听起来蛮难的，但是也就是一次迭代改变链表中指针的指向，将其反向指回去。这种方法比复制一个链表出来效率要高。当然，作为单向链表来说，去复制链表也不是什么简单的好办法。\n题干 [力扣-反转链表]\n反转一个单链表。\n示例:\n1 2 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n迭代 思路 说实话迭代是什么也不是很理解，廖雪峰有一篇文章介绍了迭代：[廖雪峰的官网] 大致上可以理解为遍历吧。大致过程就是不断的改变指针指向，将本节点指向下一个节点的指针指向上一个节点，因此需要临时的结构体指针来保存节点（毕竟是单向链表，不能回去）。为了方便理解，粗略的画了一下图，在实际应用中关于链表的问题画图确实比较好理解一些。（u1s1，surface的笔是真的爽，买电脑不能只看性能啊，另外字太丑了\u0026hellip;）\n在开始的时候，定义临时节点nextNode，然后更改head-\u0026gt;next指向NULL，然后定义临时节点lastNode用于保存上一节点，将head指向nextNode\n循环，修改nextNode、lastNode、head等指针的指向，不断的将节点-\u0026gt;next反转，并向前移动head\n当head-\u0026gt;next == NULL的时候即为最后一个节点，此时结束循环并修改最后一个节点的指向，然后返回链表。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * 单向链表的结构体定义 * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode *reverseList(struct ListNode *head) { struct ListNode *lastNode = head; struct ListNode *temp = head; if (head != NULL \u0026amp;\u0026amp; head-\u0026gt;next != NULL) { for (int isFirst = 1; head-\u0026gt;next != NULL; temp = head) { head = head-\u0026gt;next; if (isFirst == 1) { temp-\u0026gt;next = NULL; isFirst = 0; } else { temp-\u0026gt;next = lastNode; } lastNode = temp; } head-\u0026gt;next = lastNode; } return head; } 这次只使用了C语言，因为CSharp反转链表应该不难，list.Reverse();（逃）\n结果 仅有一次循环，使用迭代的方法还是蛮快的，完成了力扣的任务。但是递归我实在不会，甚至不能很好的区分它们。所以暂时就没有写递归方法。 最后 这道题的话还是比较简单的，毕竟画起图来感觉不难，但是实际写起来还是有一定挑战性的。通过这道题顺手复习了忘干净的链表，也是非常好的。链表的题先画图理解一下有很大帮助，尤其是自己用笔手动遍历一下，利于理解过程。\n","date":"2020-11-13T00:00:59+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-206-reverselinkedlist/","title":"反转链表-力扣206 迭代"},{"content":"中北大学 AI+移动互联创新实验室 C语言培训作业，力扣第一题两数之和 题解\n其实两数之和这道题在一个月前用Java写过一次，难度应该是不算高。但是力扣判题变得丧心病狂了，一个月前通过了的相同代码到现在就疯狂超时，所以还要看看这题。\n题干 [力扣-两数之和]\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n1 2 3 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 暴力解法 思路 用最暴力的算法两层循环还是非常简单的，只需要让第二层从i + 1开始循环即可防止重复，匹配到后将数组下标i和j添加到返回的数组里面即可\n代码 Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; // 临时储存结果 for (int i = 0; i \u0026lt; nums.length; i++) { // 循环第一层 for (int j = i + 1; j \u0026lt; nums.length; j++) { // 循环第二层 // j从i+1开始，即不重复加 if (nums[i] + nums[j] == target) { result[0] = i; result[1] = j; // 将结果的索引存储在result数组中 return result; } } } } } CSharp(Microsoft Java) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Solution { public int[] TwoSum(int[] nums, int target) { int[] result = new int[2]; // 临时储存结果 for (int i = 0; i \u0026lt; nums.Length; i++) { // 循环第一层 for (int j = i + 1; j \u0026lt; nums.Length; j++) { // 循环第二层 // j从i+1开始，即不重复加 if (nums[i] + nums[j] == target) { result[0] = i; result[1] = j; // 将结果的索引存储在result数组中 return result; } } } } } C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int *twoSum(int *nums, int numsSize, int target, int *returnSize) { int *result = NULL; // 定义空指针用来存储返回数据 *returnSize = 0; // 默认的返回大小为0 for (int i = 0; i \u0026lt; numsSize - 1; i++) { // 循环第一层 for (int j = i + 1; j \u0026lt; numsSize; j++) { // 循环第二层 if (nums[i] + nums[j] == target) { result = (int *)malloc(sizeof(int) * 2); // 为返回结果的指针分配内存 *result = i; // 赋值result result[1] = j; // 赋值第二项 *returnSize = 2; // 设置返回大小 goto end; // 跳出两层循环 } } } end: return result; } p.s.别骂我的goto，使用goto跳出C的两层循环还是蛮方便（逃）\n结果 一个月前的Java代码，那个时候还能通过，现在提交同样的代码也会超时\nC语言暴力算法结果（超时）\n哈希表法 思路 这是实验室巨佬和我说的，所以我去了解了一下这个思路。大概的实现是这样的：遍历一次数组将值存入哈希表中，同时检查哈希表中是否存在 target - num 存在和话返回下标，不存在继续循环并将当前插入哈希表，直到循环结束则无结果。\n官方题解使用的HashMap是开源项目 uthash leetcode已经默认包含其头文件，可以直接使用（官方文档： https://troydhanson.github.io/uthash/userguide.html）\n代码 p.s. 写起来还是有点自闭的，现在已经是12:35了，才刚通过一个\np.s. 代码很长，有很多被注释掉的是当时测试用的，不舍得删掉了(最后还是删了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /*AI+移动互联创新实验室 C语言培训练习题 两数之和 | 力扣-1*/ ##include \u0026lt;stdio.h\u0026gt; ##include \u0026lt;malloc.h\u0026gt; ##include \u0026lt;math.h\u0026gt; ##include \u0026lt;stdbool.h\u0026gt; // 头文件 ##include \u0026#34;uthash\\uthash.h\u0026#34; ##define DEFAULT_SIZE 0 ##define FOUND_SIZE 2 ##define INT2_SIZE sizeof(int) * 2 // 定义常量 PART1 typedef struct _hashMap { int key; int val; UT_hash_handle hh; } HashMap; // 哈希表结构体 ##define HASH_SIZE sizeof(HashMap) * 2 // 定义常量 PART2 int *twoSum(int *nums, int numsSize, int target, int *returnSize); int hashFind(int key, HashMap *in); bool hashInsert(int key, int val); // 函数声明 HashMap *numHash = NULL; // 新哈希表 int *twoSum(int *nums, int numsSize, int target, int *returnSize) { int *ret = NULL; *returnSize = DEFAULT_SIZE; for (int i = 0; i \u0026lt; numsSize; i++, nums++) { int other = target - *nums; // 计算另一个orher int index = hashFind(other, numHash); // 将other作为键寻找 if (index != -1) { // 找到则进行返回 ret = (int *)malloc(INT2_SIZE); *ret = index; ret[1] = i; // printf(\u0026#34;%d %d\\n\u0026#34;,index,i ); *returnSize = FOUND_SIZE; break; } else { // 未找到则插入数据 hashInsert(*nums, i); // 插入数字作为键，i作为值 } } numHash = NULL; // 置空哈希表，因为在力扣上面是多次运行，而哈希表会保留上次运行的数据 return ret; // 哈希表查找值 int hashFind(int key, HashMap *in) { HashMap *tmp = NULL; HASH_FIND_INT(in, \u0026amp;key, tmp); int ret = -1; if (tmp != NULL) { ret = tmp-\u0026gt;val; } return ret; } // 哈希表插入值 bool hashInsert(int key, int val) { bool ret = false; int it = -1; if (HASH_COUNT(numHash) != 0) { it = hashFind(key, numHash); } if (it == -1) { HashMap *newHash; newHash = malloc(HASH_SIZE); newHash-\u0026gt;val = val; newHash-\u0026gt;key = key; HASH_ADD_INT(numHash, key, newHash); // free(newHash); // 加上这一行会爆炸 ret = true; } return ret; } 结果 C语言的代码，时间还算不错，内存占用大了一点\n最后 说起这题来真是心酸啊，跨越了一个月，也通过这道题学(zì)会(bì)了很多 ","date":"2020-11-09T12:29:51+08:00","permalink":"https://blog.gaein.cn/passages/leetcode-1-twosum/","title":"两数之和-力扣1 暴力算法/哈希表"},{"content":"前言 总感觉 cmd、PowerShell 太丑。以前折腾过一阵子的 cmder 感觉也就一般。听学姐们吹了挺长时间的 Windows Terminal。今天试一下，确实效果非常好，美观好用。不得不说巨硬Micro$oft 正经去做某个东西还是非常好的。\n2022年11月9日更新如下：\n修改名称 “Powershell 7” 为 “Powershell”，“Powershell 5” 为 “Windows Powershell”； 修改部分失效的配置 修改安装方式等 （其实还改了很多，毕竟已经两年过去了）\n安装 这次主要有以下几个目的：\n使用 PowerShell 代替系统自带的 Windows PowerShell； 优化 PowerShell 字体、配色等； 在 Windows Terminal 里面添加 python 控制台； 合并 PowerShell、Git Bash、cmd 和 python 到 Windows Terminal 中，并取消其它的右键菜单，为 Windows Terminal 添加右键菜单。 可参阅： Windows Terminal Startup Settings | Microsoft Docs\nWindows Terminal Windows Terminal 简介 是一款新式、快速、高效且强大的终端应用程序。通过它可以使用命令提示符、PowerShell、WSL 等诸多 shell。Windows Terminal 支持多选项卡、窗格、Unicode 和 GPU 加速文本渲染引擎，同时也支持丰富多彩的用户自定义主题。\n安装 Windows Terminal 可以使用多种方式安装：\n包管理器 winget 和 scoop 等均有 windows terminal 的包，Windows 11 自带 Windows Terminal（中文版显示为“终端”）。\n应用商店：\n打开系统的 Microsoft Store； 搜索\u0026quot;Windows Terminal\u0026quot;； 点击\u0026quot;安装\u0026quot;。 由于网络环境不同等待时间也可能不一样 在未来某个版本的Windows会默认安装Windows Terminal，但是是几百年后就不知道了（x Windows 11 已经预装。\n菜单里出现 Windows Terminal，打开后如图所示即为安装完成。\nPowerShell 所以 Powershell 和 Windows Powershell 有啥不同？\nPowershell 简介 最初，Windows PowerShell 是在 .NET Framework 基础之上构建而成，仅适用于 Windows 系统。 在最新版本中，PowerShell 使用 .NET Core 3.1 作为运行时。 PowerShell 在 Windows、macOS 和 Linux 平台上运行。 新的 PowerShell 拥有更高的效率和诸多优点。 PowerShell Core 是 GitHub 上面的开源项目，使用 MIT 许可证。\n安装 Powershell 官方有详细的安装文档，见 Microsoft DOCS\n建议参考官方文档选择适合自己的方式安装，我目前系统中的WT是作为dotnet CLI 全局工具安装的\n我使用下载-安装的方式而没有使用包管理器。\n从GitHub 的 Release中下载PowerShell-7.1.0-win-x64.msi； 下载完成后找到下载的文件夹，双击运行；\n如果提示 “不是有效的 WIN32 应用程序” 请返回刚才的 Release 页面下载PowerShell-7.1.0-win-x86.msi\n一直点击\u0026quot;Next\u0026quot;，直到安装完成，点击\u0026quot;Finish\u0026quot;。 配置 PowerShell Core 准备 安装模块 打开 PowerShell 7，输入以下命令：\n1 Install-Module posh-git -Scope CurrentUser 1 Install-Module oh-my-posh -Scope CurrentUser 先输入一个命令，光标会移动到下一行的最左侧。这时候不要着急输入另一个，稍等一会如果出现提示那么就按Y。安装完成（左侧有显示\u0026quot;PS xxx\u0026quot;字样）再安装另外一个。两个不分先后。\n安装 PowerLine 字体 这一部分微软官方文档有写，详见 Microsoft Docs\n打开 Cascadia Code GitHub 发布页，下载最新的 Release CascadiaCode-2009.22.zip；\n下载完成后解压文件，进入解压后的文件夹-\u0026gt;ttf，双击里面.ttf结尾的文件，安装。\n配置 从菜单栏打开安装好的 PowerShell 7。如果电脑安装有 Visual Studio Code 的话在里面输入以下内容：\n1 code $profile 如果你没有安装或者不知道什么是 Visual Studio Code 的话输入以下内容：\n1 notepad $profile 输入完成后按下回车，VSCode（或记事本）将会打开一个文件（可能是空的），在里面输入以下内容后保存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # by Gaein nidb , https://www.Gaein.cn Clear-Host # 清除屏幕 $time = Get-date -Format \u0026#34;现在是yyyy年MM月dd日 HH时mm分\u0026#34; $path = $pwd.path # 获取路径 if ( $path.split(\u0026#34;\\\u0026#34;)[-1] -eq \u0026#34;Windows\u0026#34; -xor $path.split(\u0026#34;\\\u0026#34;)[-1] -eq \u0026#34;System32\u0026#34;) { ## 默认路径为桌面 $desktop = \u0026#34;C:\\Users\\\u0026#34; + $env:UserName + \u0026#34;\\Desktop\\\u0026#34; ## 切换到桌面 Set-Location $desktop } Write-Output $time $motdPath = \u0026#34;C:\\Users\\\u0026#34; + $env:UserName + \u0026#34;\\Documents\\PowerShell\\motd.txt\u0026#34; Get-Content $motdPath # 欢迎消息 # 导入模块 Import-Module posh-git Import-Module oh-my-posh # 设置主题 Set-Theme PowerLine 如果你想自定义的话建议先备份后修改。\n在此电脑-\u0026gt;文档-\u0026gt;PowerShell文件夹，点击新建文本文档，文件名为\u0026quot;motd.txt\u0026quot;，写入以下内容：\n1 2 3 4 5 6 7 PowerShell 7.1.0 (Windows10专业版 x64 20H2) * 终端: https://docs.microsoft.com/zh-cn/powershell/ * 系统: https://support.microsoft.com/zh-cn/windows/ * 指令: https://docs.microsoft.com/zh-cn/dotnet/api/ 欢迎使用PowerShell Core 这里的内容是完全自定义的，算是欢迎消息，即打开 PowerShell 输出的一段话。你可以随便写。\n配置 Windows Terminal 自定义设置 打开 Windows Terminal，点击 下箭头-\u0026gt;设置 或按下 Win+, 打开设置文件 向设置文件写入以下内容：\n注意，现在打开默认是图形化设置，需要进入图形设置再点击左侧栏目下方的设置图标。\n首先修改全局设置（即 profiles.defaults 节点）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026#34;defaults\u0026#34;: { // 默认设置 \u0026#34;acrylicOpacity\u0026#34;: 0.75, // 不透明度 \u0026#34;closeOnExit\u0026#34;: true, // 退出时关闭 \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, // 配色方案 \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, // 颜色 \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, // bar \u0026#34;fontFace\u0026#34;: \u0026#34;Cascadia Code PL\u0026#34;, // 字体 \u0026#34;fontSize\u0026#34;: 10, // 字号 \u0026#34;historySize\u0026#34;: 9001, // 历史记录 \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, // 内部显示位置 \u0026#34;snapOnInput\u0026#34;: true, // ? \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, // 打开目录 \u0026#34;useAcrylic\u0026#34;: true // 使用亚克力效果 }, 然后添加Python控制台，并将不想看到的自动生成的三个的 hidden 属性设置为 true:\n1 2 3 4 5 6 7 8 { // Python Console \u0026#34;guid\u0026#34;: \u0026#34;{de7c0f31-aa6b-c0f6-44a8-fe162d8f31fc}\u0026#34;, // 随机生成一个guid即可 \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Python 3.9\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;C:\\\\Users\\\\Gaein\\\\Documents\\\\WindowsTerminal\\\\python-logo.png\u0026#34;, // 自定义python图标 \u0026#34;commandline\u0026#34;: \u0026#34;C:\\\\Program Files\\\\Python39\\\\python.exe\u0026#34; // python路径 }, 整个配置文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // 文档: https://aka.ms/terminal-documentation // 默认设置在点击设置按钮时按住\u0026#34;Alt\u0026#34;键 // by Gaein nidb, https://www.gaein.cn // rev 1.0.0 { // 全局设置 \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{574e775e-4f2a-5b96-ac1e-a2962a402336}\u0026#34;, // 默认打开的 \u0026#34;copyOnSelect\u0026#34;: false, // 自动复制选中的内容到剪切板 \u0026#34;copyFormatting\u0026#34;: false, // 复制格式，将选中文字的颜色、背景等也复制 \u0026#34;initialCols\u0026#34;: 120, // 初始化大小（栏） \u0026#34;initialRows\u0026#34;: 38, // 初始化大小（行） // 打开的选项的设置，文档: https://aka.ms/terminal-profile-settings \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { // 默认设置 \u0026#34;acrylicOpacity\u0026#34;: 0.75, // 不透明度 \u0026#34;closeOnExit\u0026#34;: true, // 退出时关闭 \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, // 配色方案 \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, // 颜色 \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, // bar \u0026#34;fontFace\u0026#34;: \u0026#34;Cascadia Code PL\u0026#34;, // 字体 \u0026#34;fontSize\u0026#34;: 10, // 字号 \u0026#34;historySize\u0026#34;: 9001, // 历史记录 \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, // 内部显示位置 \u0026#34;snapOnInput\u0026#34;: true, // ? \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, // 打开目录 \u0026#34;useAcrylic\u0026#34;: true // 使用亚克力效果 }, \u0026#34;list\u0026#34;: [ { // PowerShell Core \u0026#34;guid\u0026#34;: \u0026#34;{574e775e-4f2a-5b96-ac1e-a2962a402336}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;PowerShell Core\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;pwsh.exe -NoLogo\u0026#34; }, { // Python Console \u0026#34;guid\u0026#34;: \u0026#34;{de7c0f31-aa6b-c0f6-44a8-fe162d8f31fc}\u0026#34;, // 随机生成一个guid即可 \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Python 3.9\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;C:\\\\Users\\\\Gaein\\\\Documents\\\\WindowsTerminal\\\\python-logo.png\u0026#34;, // 自定义python图标 \u0026#34;commandline\u0026#34;: \u0026#34;C:\\\\Program Files\\\\Python39\\\\python.exe\u0026#34; // python路径 }, { // 自带的旧版PowerShell \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;PowerShell(旧版)\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34; }, { // 命令提示符 \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;命令提示符(cmd)\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34; }, { // 默认生成的Azure Cloud Shell \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; } ] }, // Add custom color schemes to this array. // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes \u0026#34;schemes\u0026#34;: [], // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ] } 可以按需进行修改\n添加到右键菜单 注意：这部分可能不再需要。貌似现在的wt装完之后自动添加了右键菜单。\nWin + R 输入 regedit 打开注册表编辑器； 转到计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell； 新建项Terminal，将默认值修改为在此处打开 Windows Terminal； 下载图标(从Gaein.cn)，保存到某个路径； 在Terminal里新建字符串，名字为icon，右键-\u0026gt;修改，值为图标的路径； 在Terminal新建项，名字为command，值为wt.exe 参考 Microsoft Docs:Windows Terminal Microsoft Docs:从 PowerShell5 迁移到 7 知乎 @tnnmigga:Windows Terminal 终端入门 简书 @码农小胖哥:Windows 命令行终端 PowerShell 美化计划 ","date":"2020-11-09T01:43:18+08:00","permalink":"https://blog.gaein.cn/passages/windows-terminal-usage/","title":"个性化你的 Windows Terminal 终端与 PowerShell"},{"content":"距离笔记1大概有两周了，由于Java、C、C++、CSharp都是C like语言，它们的有很多相似之处，因此没有再细致一点点看，而是从数组开始看起，将《零基础学习Java看完》。当然这几节只是非常基础的课程，所以笔记也比较简短。已经了解之处就不再做笔记了。\n终于没有忍住去跟课程进度，而是去看了上次开课的视频。下一步的计划是看进阶的Java，或者是学习一下python。最近用python写了一个QQ bot，发现很是好用。\n下一篇笔记 计算——零基础学Java语言笔记（一）\n下一篇笔记 暂无\n2.1 比较 Java语言使用// notes和/*notes*/来作注释\nJava语言的关系运算符有\u0026gt;、\u0026lt;、==、\u0026gt;=、\u0026lt;=、!= 6个\n1 2 System.out.println(5==3); // 输出false System.out.println(5\u0026gt;=3); // 输出true 所有关系运算符的优先级比算数运算符的低，但比赋值运算符=高\n2.2 判断 建议不管有几条语句在if或else后总要跟上一对花括号，这样利于人类阅读\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 if (/*条件*/){ // 代码 // ... } // if语句 if (/*条件*/){ // 代码 // ... } else { // 代码 // ... } // if-else语句 if (/*条件*/){ // 代码 // ... } else if (/*条件2*/){ // 代码 // ... } // if-elseif语句 2.3 分支 switch-case\n1 2 3 4 5 6 7 8 9 10 11 12 switch (/*控制表达式，通常是某个变量*/){ case /*常量*/: // 语句 // ... break; case /*常量*/: // 语句 // ... default: // 语句 // ... } 执行完分支中的语句后，如果后面没有break;，就会进入下面的case里面去，直到遇到break;或者switch结束为止\n2.4 判断语句常见错误 2.x 小测验 1.写出以下代码段的执行结果： 1 2 3 4 5 int num=34, max=30; if ( num \u0026gt;= max*2 ) System.out.println(\u0026#34;zhang\u0026#34;); System.out.println(\u0026#34;huang\u0026#34;); System.out.println(\u0026#34;zhu\u0026#34;); huang\\n\n2.写出以下代码段的执行结果： 1 2 3 4 5 6 7 8 9 10 int limit = 100; int num1 = 15; int num2 = 40; if ( limit \u0026lt;= limit) { if ( num1 == num2 ) System.out.println(\u0026#34;lemon\u0026#34;); System.out.println(\u0026#34;lime\u0026#34;); } System.out.println(\u0026#34;grape\u0026#34;);zhu lime\\ngrape\n第二周编程题 第一题——时间换算 题目内容： UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。\n现在，你的程序要读入一个整数，表示BJT的时和分。\n整数的个位和十位表示分，百位和千位表示小时。\n如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。\n有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。\n你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。\n整数的个位和十位表示分，百位和千位表示小时。\n如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。\n提醒：要小心跨日的换算。\n输入格式:\n一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而且分小于10分，需要保留十位上的0。\n输出格式： 一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而且分小于10分，需要保留十位上的0。\n输入样例：933\n输出样例：133\n时间限制：500ms内存限制：32000kb\n需要注意的问题：\n是从BJT转到UTC UTC = BJT - 8 跨日期需要加上24小时 提交的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.Scanner; public class Main { public static void main(String[] Args){ Scanner in = new Scanner(System.in); int BJT = in.nextInt(); // 输入北京时间 int UTC = BJT - 800; // 转换成UTC if (UTC \u0026lt; 0) // 判断是否跨日 { UTC += 2400; } System.out.println(UTC); } } 第二题——信号报告 题目内容： 无线电台的RS制信号报告是由三两个部分组成的：\nR(Readability) 信号可辨度即清晰度.\nS(Strength) 信号强度即大小.\n其中R位于报告第一位，共分5级，用1—5数字表示.\n1---Unreadable\n2---Barely readable, occasional words distinguishable\n3---Readable with considerable difficulty\n4---Readable with practically no difficulty\n5---Perfectly readable\n报告第二位是S，共分九个级别，用1—9中的一位数字表示\n1---Faint signals, barely perceptible\n2---Very weak signals\n3---Weak signals\n4---Fair signals\n5---Fairly good signals\n6---Good signals\n7---Moderately strong signals\n8---Strong signals\n9---Extremely strong signals\n现在，你的程序要读入一个信号报告的数字，然后输出对应的含义。如读到59，则输出：\nExtremely strong signals, perfectly readable.\n输入格式:\n一个整数，信号报告。整数的十位部分表示可辨度，个位部分表示强度。输入的整数范围是[11,59]内有效的数字，这个范围外的数字不可能出现在测试数据中。\n输出格式：\n一句话，表示这个信号报告的意义。按照题目中的文字，先输出表示强度的文字，跟上逗号和空格，然后是表示可辨度的文字，跟上句号。注意可辨度的句子的第一个字母是小写的。注意这里的标点符号都是英文的。\n输入样例：\n33\n输出样例：\nWeak signals, readable with considerable difficulty.\n时间限制：500ms内存限制：32000kb\n需要注意的问题：\n输出时候先输出S再输出R 输出的格式为S,□R.（“□”代表空格） R的第一个字母要小写 解决方案：\n获取R和S数字值： 假设输入的是input，那么我们用input除以10可以得到十位上的数字，对它取余10可以得到个位上的数字 1 2 int r = input / 10; int s = input % 10; 出题者的意图显然是用switch-case来解决问题，但是未免太麻烦了点，至少看起来很难受。因为懒得用map所以我的解决方案是使用字符串数组，按顺序将字符串放在单元中，然后用s或者r减去1的值作为索引就可以了。 提交的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.util.Scanner; public class Main_2 { public static void main(String[] Args) { Scanner in = new Scanner(System.in); int input = in.nextInt(); // 获取输入 int r = input / 10; // 解析获取R int s = input % 10; // 解析获取S String[] rDic = { \u0026#34;unreadable\u0026#34;, \u0026#34;barely readable, occasional words distinguishable\u0026#34;, \u0026#34;readable with considerable difficulty\u0026#34;, \u0026#34;readable with practically no difficulty\u0026#34;, \u0026#34;perfectly readable\u0026#34;, }; // 定义字符串数组存储R对应的字符串 String[] sDic = { \u0026#34;Faint signals, barely perceptible\u0026#34;, \u0026#34;Very weak signals\u0026#34;, \u0026#34;Weak signals\u0026#34;, \u0026#34;Fair signals\u0026#34;, \u0026#34;Fairly good signals\u0026#34;, \u0026#34;Good signals\u0026#34;, \u0026#34;Moderately strong signals\u0026#34;, \u0026#34;Strong signals\u0026#34;, \u0026#34;Extremely strong signals\u0026#34;, }; // 定义字符串数组存储S对应的字符串 System.out.println(sDic[s - 1] + \u0026#34;, \u0026#34; + rDic[r - 1] + \u0026#34;.\u0026#34;); // 输出结果 } } ","date":"2020-10-04T14:43:04+08:00","permalink":"https://blog.gaein.cn/passages/java-note2-compare/","title":"比较——零基础学Java语言笔记（二）"},{"content":"链表是一种实现大小可变的、类似于数组的数据类型，每个node至少包含一个存储的值和指针，指向下一个node\u0026hellip;这样把链表连接起来。其实这东西还是挺烧脑的，后期会把自己尝试写的链表发上来。跟随着翁恺教授的课记了一些笔记。\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 上一篇笔记 文件——C语言程序设计笔记（六）\n字符串 由于这些笔记都是用OneNote手写的，听到那写到那，所以就没有排版可言了（逃\n下载 LinkedList.pdf|3.99MB\n","date":"2020-09-23T16:48:50+08:00","permalink":"https://blog.gaein.cn/passages/c-note7-linkedlist/","title":"链表——C语言程序设计笔记（七）"},{"content":"这节课讲了C操作文件的一些方法，包括格式化的输入输出、读写文本和二进制文件等。跟随着翁恺教授的课记了一些笔记。\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 上一篇笔记 程序结构——C语言程序设计笔记（五）\n下一篇笔记 链表——C语言程序设计笔记（七）\n文件 由于这些笔记都是用OneNote手写的，听到那写到那，所以就没有排版可言了（逃\n下载 File.pdf|4.31MB\n","date":"2020-09-23T16:07:31+08:00","permalink":"https://blog.gaein.cn/passages/c-note6-file/","title":"文件——C语言程序设计笔记（六）"},{"content":"程序结构使整个程序变得更加“优雅”、利于后期维护和更新，在做大型程序的时候是不可或缺的。翁恺教授讲解了本地变量、全局变量等以及预编译处理指令、如果编译多个.c文件等等。跟随着翁恺教授的课记了一些笔记。\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 上一篇笔记 结构类型——C语言程序设计笔记（四）\n下一篇笔记 文件——C语言程序设计笔记（六）\n程序结构 由于这些笔记都是用OneNote手写的，听到那写到那，所以就没有排版可言了（逃\n下载 ProgramStructure.pdf|3.66MB\n","date":"2020-09-23T15:39:27+08:00","permalink":"https://blog.gaein.cn/passages/c-note5-programstructure/","title":"程序结构——C语言程序设计笔记（五）"},{"content":"那么看完了C语言的课程之后呢，在@伞菌大佬的指点下我准备下一步去学习Java语言，至于课程选择嘛我就直接选择了浙江大学翁恺教授的课（毕竟看了有一段时间了有点不舍emm）并且这门课是国家精品课程，不过是面向零基础的。Java和CSharp很像，本来没有想这么细致的去学习，但是碰巧又赶上这门课程在开课，可以去讨论区互动和交作业等，于是便准备养老一般的跟着课程走。\n那么Java这门语言呢，我准备跟着开课的进度一点一点学。（当然我看了一眼进度有点猴急，准备跟着上一次开课去学，然后跟着这个次开课去做题）。毕竟它和CSharp非常相似，我觉得把课跟下来应该不是特别难，当然，学好是另外一回事了。因为前面几周很多东西都偏基础，所以这些笔记可能会很短、很短\n浙江大学-零基础学习Java\n下一篇笔记 比较——零基础学Java语言笔记（二）\n1.1 第一个Java程序 IDEA新建项目、新建模块、然后新建包、新建类，在class中写入\n1 2 3 public static void main(String[] args){ System.out.println(\u0026#34;HelloWorld\u0026#34;); } 来输出HelloWorld，其中main函数是主函数，程序的入口点\n输出时println函数括号里面的运算要用括号括起来，比如：\n1 2 System.out.println(\u0026#34;3 + 2 = \u0026#34; + 3 + 2); // 输出32 System.out.println(\u0026#34;3 + 2 = \u0026#34; + (3 + 2)); // 输出5 Java语言使用“+”来拼接字符串\n1.2 变量与计算 1.2.1 输入 Java获取输入需要首先定义一个Scanner\n1 Scanner in = new Scanner(System.in); 并且在前面\n1 import java.util.Scanner; // 自动生成 然后使用\n1 2 3 in.nextLine(); // 读取一行输入 in.nextInt(); // 读取输入的整数 // 其余类型的类似 1.2.2 变量 Java是强类型语言，所有的变量在使用前都需要经过定义并且有明确的类型并且被初始化。\n使用 \u0026quot; 变量类型 + 变量名 \u0026quot; 定义变量，比如：\n1 int myVar = 0; 变量的名字叫做标识(zhi4)符，只能由字母、数字和下划线，第一个字符只能是字母或下划线，不能用Java的关键字做标识符\n在一行当中定义多个变量，每一个变量都应该有单独的赋值，比如：\n1 2 int amount = 0, price = 0; // [!]推荐一行定义一个变量 final int AMOUNT = 0; // 在前面加上final来定义常量 1.2.3 赋值 等于号 \u0026quot; = \u0026quot; 是赋值运算，将右边的值给左边\n1.3 浮点数计算 1.3.1 浮点数 double用于定义double类型的浮点数变量 浮点数计算是有误差的\n1.3.2 计算的优先级 如果不能确定计算的优先级可以加上括号来确保万无一失 大部分计算的优先级是按照人正常的思维来规定的 单目运算符只有一个算子，通常单目运算符的优先级较高\n1.3.3 类型的转换 Java使用(类型)进行强制转换（和C一样） 比如说：\n1 int i = (int)((3.0 / 2) * 5); 1.x 在中国大学MOOC上面提交编程作业： 需要将 package 以下的内容复制过去 将class名改为Main 第一周编程题 题目内容： 写一个将华氏温度转换成摄氏温度的程序，转换的公式是：\n°F = (9/5)*°C + 32\n其中C表示摄氏温度，F表示华氏温度。\n程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。\n提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式：\n(int)x;\n其中x是要转换的那个浮点数。\n注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。\n这道题目要求转换后的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。\n输入格式:\n一个整数\n输出格式：\n一个整数\n输入样例：\n100\n输出样例：\n37\n时间限制：500ms 内存限制：32000kb\n需要注意的问题：\n给的公式是摄氏度转华氏度，而程序的目的是华氏度转摄氏度\n提交的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int F = in.nextInt(); // F代表读取的华氏度 double C = 0; // C代表读取的摄氏度 C = (F-32)/(9/5.0); // 根据公式运算（需要把公式导一下） System.out.println((int)C); // 输出，并强制转换为int } } ","date":"2020-09-22T20:56:21+08:00","permalink":"https://blog.gaein.cn/passages/java-note1-calculation/","title":"计算——零基础学Java语言笔记（一）"},{"content":"从结构类型开始学习了一些自定义的结构，其中struct是较为重要的。跟随着翁恺教授的课记了一些笔记。\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 上一篇笔记 字符串——C语言程序设计笔记（三）\n下一篇笔记 程序结构——C语言程序设计笔记（五）\n结构类型 由于这些笔记都是用OneNote手写的，听到那写到那，所以就没有排版可言了（逃\n下载 Struct.pdf|2.58MB\n","date":"2020-09-22T17:23:09+08:00","permalink":"https://blog.gaein.cn/passages/c-note4-struct/","title":"结构类型——C语言程序设计笔记（四）"},{"content":"C语言的字符串实际上是char数组。跟随着翁恺教授的课记了一些笔记。\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 上一篇笔记 指针——C语言程序设计笔记（二）\n下一篇笔记 结构类型——C语言程序设计笔记（四）\n字符串 由于这些笔记都是用OneNote手写的，听到那写到那，所以就没有排版可言了（逃\n下载 String.pdf|2.65MB\n","date":"2020-09-22T16:58:09+08:00","permalink":"https://blog.gaein.cn/passages/c-note3-string/","title":"字符串——C语言程序设计笔记（三）"},{"content":"从指针开始，难度便变高了，因此每一周的课程都做了一些笔记、摘要。虽然以前学C++的时候接触过指针，但是也忘得差不多了。所以课还是要听的。\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 上一篇笔记 基础结构——C语言程序设计笔记（一）\n下一篇笔记 字符串——C语言程序设计笔记（三）\n指针 由于这些笔记都是用OneNote手写的，听到那写到那，所以就没有排版可言了（逃\n下载 Pointer.pdf|1.83MB\n","date":"2020-09-22T16:32:51+08:00","permalink":"https://blog.gaein.cn/passages/c-note2-pointer/","title":"指针——C语言程序设计笔记（二）"},{"content":"简介 ASCII 是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646。ASCII 第一次以规范标准的类型发表是在 1967 年，最后一次更新则是在 1986 年，到目前为止共定义了 128 个字符（一个 char）\n内容 下面是完整的 ASCII 表，0 ～ 31 及 127(共 33 个)是控制字符或通信专用字符，其余为可显示字符\n转换 将字符转换为 ASCII 十进制码 输入 操作 转换 清空 结果 转换结果 将十进制码转换为 ASCII 字符 输入 操作 转换 清空 结果 转换结果 ","date":"2020-09-22T14:05:19+08:00","permalink":"https://blog.gaein.cn/passages/ascii-code-convertor/","title":"ASCII 码对照表和转换器"},{"content":"趁着假期呢看了一些中国大学MOOC中浙江大学翁恺教授的C语言程序设计，也算是预习大学课程吧。因为有一点编程基础因此前边一些听起来也不是很吃力，因此前边很多章节都没有记笔记，准备记在一起（其实是懒得记吧hhh）\n趁着假期呢看了一些中国大学MOOC中浙江大学翁恺教授的C语言程序设计，也算是预习大学课程吧。因为有一点编程基础因此前边一些听起来也不是很吃力，因此前边很多章节都没有记笔记，准备记在一起（其实是懒得记吧hhh）\n浙江大学-C语言程序设计\nC语言笔记目录 基础结构——C语言程序设计笔记（一） 指针——C语言程序设计笔记（二） 字符串——C语言程序设计笔记（三） 结构类型——C语言程序设计笔记（四） 程序结构——C语言程序设计笔记（五） 文件——C语言程序设计笔记（六） 链表——C语言程序设计笔记（七） 下一篇笔记 指针——C语言程序设计笔记（二）\n程序设计与C语言 C语言是一门古老的、低级的、底层的、面向过程的语言\nHelloWorld 1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } 程序从main函数开始，如上是最基础的Hello World\n通常来说C语言是编译-运行的\n输入输出 在C语言中，使用printf()函数来输出内容，其中，传递给printf的参数是：\n1 2 3 int i = 64; printf(\u0026#34;字符串\\n\u0026#34;); printf(\u0026#34;格式字符，比如%d\u0026#34;, i); 运行程序会输出：\n1 2 \u0026gt;字符串 \u0026gt;格式字符，比如64 格式字符 格式字符是%+一个或多个字符，用于控制输出的格式。比如说，后面传入的参数i是int类型的，那么使用%d来输出整数\n常见的格式字符有：\n更多的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int i = 64; int *p = i; double d = 32.64128; char c = \u0026#39;c\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;HelloWorld\u0026#34;); // %s:字符串 printf(\u0026#34;%c\\n\u0026#34;, c); // %c:字符 printf(\u0026#34;%d\\n\u0026#34;, i); // %d:整数（十进制） printf(\u0026#34;%5d\\n\u0026#34;, i); // %5d:五位整数，不足五位前面补充空格 printf(\u0026#34;%05d\\n\u0026#34;, i); // %05d:五位整数，不足五位前面补充0 printf(\u0026#34;%-5d\\n\u0026#34;, i); // %-5d:五位整数，不足五位后面补充空格 printf(\u0026#34;%u\\n\u0026#34;, i); // %u:打印无符号数 printf(\u0026#34;%x\\n\u0026#34;, i); // %x:整数（十六进制） printf(\u0026#34;%o\\n\u0026#34;, i); // %o:整数（八进制） printf(\u0026#34;%f\\n\u0026#34;, d); // %f:浮点数 printf(\u0026#34;%0.0f\u0026#34;, d); // %0.0f不保留小数 printf(\u0026#34;%0.100f\u0026#34;, d); // %0.100保留三位小数 printf(\u0026#34;%p\u0026#34;); // %p取指针的地址 输出大致如下（其中%p的例子仅做示范，“□”代表空格）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 HelloWorld c 64 □□□64 00064 64□□□ 64 40 100 32.64128 32 32.641 0x7fff5cc109d4 更多情况见C语言格式字符（还没写先挖坑）\nC语言使用scanf()函数来获取输入，其中的参数是格式字符，另外一个参数是\u0026amp;变量名（\u0026amp;是取地址）\n转义（逃逸）字符 常见转义字符有：\n\\n:换行\n\\t:制表符\n\\\u0026quot;:\u0026quot;\n\\':'\n\\\\:\\\n运算 在C语言中这样定义变量：\n1 变量类型 变量名; 可以在变量定义的时候给其赋值，否则不会初始化\n1 int myVar = 64; 在这中等号代表赋值而不是相等\n变量区分大小写，即MyVar和myVar完全是不同的两个变量\n使用typeof()函数可以输出变量占据的字节，typeof是静态的，括号里面的运算不会被进行\n在C语言中有多种运算符常见的有+、-、、\\、以及+=、-=、=、+和++、\u0026ndash;\n程序流控制 判断 if 语句用于判断，其结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 if (/*条件*/) { // 语句; } else if (/*条件*/) { // 语句; } else { // 语句; } if 是可以嵌套的\n在条件中判断值是否相等使用“==”而不是“=”，单个的等号是赋值运算。括号内1表示是，0表示非。\n比如说\n1 int result = 3 \u0026lt; 6; 条件成立则3 \u0026lt; 6 的结果为1即result的值为1\nelse if 等同于：\n1 2 3 4 5 6 7 8 9 10 11 12 if (/*条件1*/) { // 语句; } else { if (/*条件2*/) { // 语句; } ... } 虽然单行的语句可以不使用{}，但是建议使用\nswitch case语句的结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 switch (/*变量*/) { case \u0026#39;0\u0026#39;: { // 语句1; } case \u0026#39;1\u0026#39;: { // 语句2; break; } default: { // 语句; } } switch的作用是根据变量的值将代码跳转到某个地方，如果case后面没有break;那么会接着走下一行\n循环 while 1 2 3 4 while (/*条件*/) { // 执行语句; } while循环的过程如下：\n判断是否满足条件 满足条件进入循环体，执行语句；不满足条件则跳出 返回1 do while 1 2 3 4 5 do { // 执行语句; } while (/*条件*/) do while循环的过程如下：\n执行语句 判断是否满足条件，满足条件返回1；不满足条件则跳出 1 2 3 4 for(/*表达式1*/;/*表达式2*/;/*表达式3*/) { // 执行语句; } for 循环是一种古老的循环（所以它看起来比较怪），它的执行过程如下：\n求解表达式1（通常是初始化计数变量） 求解表达式2（其实是条件），符合条件继续运行，不符合则跳出 执行语句 求解表达式3（通常是计数变量） 回到2步执行 也就是 for 循环改写成 while 相当于：\n1 2 3 4 5 6 7 // 表达式1; while (/*表达式2*/) { // 执行语句; // ... // 表达式3; } 在很多时候使用 for循环 会很方便（虽然我没感觉但是代码短了）\n比如需要计数时\n1 2 3 4 5 for (int i = 1; i \u0026lt;= 100; i++) { printf(\u0026#34;%d\u0026#34;, i); } // 从1数到100 数据类型 整型 char short int long long long\n整数的二进制表示 在计算机内部所有变量都是二进制的。\n为了表示负数，使用了补码，比如：\n-1为 11111111\n1 为 00000001\n进行二进制加法时，11111111 + 00000001 = 100000000\n然而，进位上去的1被舍弃了，从而实现 -1 + 1 = 0\n整数的范围 如果某个类型占据n个字节\n那么它的范围是 -2^(n-1)~2^(n-1)-1\n// 这里的\u0026quot;^\u0026quot;表示次幂而不是异或\n字符类型char char既是整型数字又是字符，将字符赋值给char时应该用单引号\u0026quot; \u0026rsquo; \u0026ldquo;包裹，比如\n1 char ch = \u0026#39;a\u0026#39;; 可以将字符作为整数输出、计算、输入，字符的整数值是它的ASCII码\nASCII码对照表和转换器\n浮点数 float double long double\n!注意：浮点数是有精度的，它们可能不是准确的，制作计算器程序应该使用BCD\n其实个人觉得整型也是一个道理，通常来说只用int就行了\n逻辑 bool bool类型只有true和false两个值，使用bool需要添加头文件\u0026lt;stdbool.h\u0026gt;\n逻辑运算 \u0026amp;\u0026amp;逻辑且\n当逻辑且左右的条件全成立时返回1，否则返回0\n||逻辑或\n当逻辑或两侧任意的一个条件成立时返回1，全不成立则返回0\n数组 数组的定义 可以使用以下形式定义一个数组\n1 int arrayInt[30]; 这个数组具有30个单元，通过arrayInt[i]来访问，索引从0开始，不能超过30 - 1，否则数组会越界\n数组的初始化 可以在定义时去初始化数组：\n1 int arrayInt[4] = {0, 3, 9, 2,}; 这样初始化会使得数组被赋值为大括号中的数字，如下：\n1 2 3 4 arrayInt[0] = 0; arrayInt[1] = 3; arrayInt[2] = 9; arrayInt[3] = 2; 使用\n1 int arrayInt[] = { /* ... */ }; 来创建自动设置大小的数组\n!注意：这样的数组大小仍然是固定的，只是在初始化的时候根据大括号内容自动算了大小\n使用\n1 int arrayInt[5] = {[1] = 3,}; 来创建指定单元被初始化为指定值的数组\n使用\n1 int arrayInt[5] = {0,}; 来让整个数组的每个单元初始化为0（实际上，当大括号内的数字数量比数组的大小小时，会默认填充每个单位为0）\n数组的运算 数组不能由一个数组赋值给另外一个数组\n数组的每个单元都可以进行运算\n二维数组 使用\n1 int a[5][3]; 来定义一个二维数组，可以把它看成是一个5行3列表格（或者矩阵）\n1 2 3 a[0][0] a[0][1] a[0][2] a[1][0] a[1][1] a[1][2] a[2][0] a[2][1] a[2][2] a[3][0] a[3][1] a[3][2] a[4][0] a[4][1] a[4][2] 如表所示\n数组的遍历，使用\n1 2 3 4 for (int i = 0; i \u0026lt; Length; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } 来完成\n强制类型转换 C语言会将小范围-\u0026gt;大范围的做自动类型转换，比如说5/7.0（int\\double）结果是double\n在C语言中使用(类型)变量来做强制类型转换，比如说\n1 (int*)malloc(sizeof(int)*4); 函数 函数的定义 其实int main()就是函数\n1 2 3 4 5 int myFunc(int foot,int inch /*参数表*/ ) // 函数头 { int ret = (int)((foot + inch/12.0)*0.3); // 函数体 return ret; } 函数由以下内容构成：\n1 2 3 \u0026lt;数据类型\u0026gt; \u0026lt;函数名\u0026gt;(\u0026lt;参数表\u0026gt;){ // 语句 } 如果把函数定义在main函数的后面则需要在main函数的前面声明函数原型（其实就是把函数头copy过去并改成分号结尾）以便于编译器“认出”函数\n使用 void 定义一个不返回值的函数，不能用 return 语句\n注意：请使用 int main 来定义主函数，没有任何标准规定可以使用 void main 定义主函数。\n!注意：使用函数时有多个可以return的时候建议遵循单一出口原则，即定义一个本地变量（通常叫做ret）来存储结果，然后最后返回这个本地变量\n调用函数时传递的参数是值而不是变量本身，在函数内修改传过去的变量不会对main中的变量造成影响（指针除外）\n基础部分的笔记到此结束，剩下的我想每周一个文（其实我已经看完了啦啦啦）\n","date":"2020-09-19T20:06:23+08:00","permalink":"https://blog.gaein.cn/passages/c-note1-basics/","title":"基础结构——C语言程序设计笔记（一）"},{"content":"VSCode 是轻量级的、跨平台的编辑器。相对于使用 DEVC++来说，使用 VSCode 开发 C/C++有很大的优势（至少它好看）。鉴于环境配置对新人不是很友好，我就写了一个一键安装程序。\n发行说明 平台 适用于 Windows7/8/8.1/10 64 位操作系统\n注意：其中 Windows7 版本需要安装.NET Framework 4.5.2 及以上版本\n开发 使用 CSharp .NET Core 编写（其中 Windows7 版本使用.NET Framework）\n版本 当前版本为 1.12.0\n安装 Visual Studio Code 1.48.2 LLVM v10.0.0 mingw64-w64 8.1.0-release-posix-seh-rt_v6-rev0 插件 vscode-icons-team.vscode-icons ms-vscode.cpptools MS-CEINTL.vscode-language-pack-zh-hans formulahendry.code-runner HookyQR.beautify zhuangtongfa.Material-theme christian-kohler.path-intellisense VisualStudioExptTeam.vscodeintellicode esbenp.prettier-vscode 下载 码云-gitee.com\n项目 项目地址：码云-gitee.com\nVSCode 配置文件来自 中北大学·AI+移动互联创新实验室\n使用方法 下载文件 双击运行后点击“开始” 等待进度条满后进入文件夹“VSCode+C” 双击文件“VSCode+C Installer.exe”，系统弹窗提示后点击是 点击“开始安装” 安装完成后会自动打开 VSCode，关闭安装程序。 在 C:\\VSCode+C\\UserCode\\C-Project 文件夹下创建 c 语言源代码文件；在 C:\\VSCode+C\\UserCode\\C++-Project 文件夹下创建 c++源代码文件 在文件夹内右键\u0026gt;在 code 中打开，或者在 VSCode 中点击文件\u0026gt;打开文件夹，然后浏览选择 C:\\VSCode+C\\UserCode\\C-Project 或 C++的 开发过程 本来想打包 msi，后来无论怎么尝试都不行，干脆就使用 CSharp写一个安装器\n安装实现 VSCode 从官网下载安装包 VSCode 使用 Inno Setup，通过 Process 类中的方法调用其安装程序并传递参数，查阅 Inno Setup 的文档后，我使用的安装的命令行参数如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /SP- ## 不显示“是否安装” /VERYSILENT ## 超级静默安装（不弹窗） /NOCANCEL ## 禁止取消安装 /NORESTART ## 不重启电脑 /CLOSEAPPLICATIONS ## 关闭影响安装的程序 /ALLUSERS ## 为所有用户安装 /DIR=\u0026#34;C:\\VSCode+C\\Microsoft Visual Studio Code\\\u0026#34; ##设置安装目录 /MERGETASKS=\u0026#34;!runcode,desktopicon,quicklaunchicon,addcontextmenufiles,addcontextmenufolders,associatewithfiles,addtopath\u0026#34; ## 安装的任务： ## !runcode 安装完成后不启动vscode ## desktopicon 桌面图标 ## quicklaunchicon 开始菜单 ## addcontextmenufiles 文件右键菜单 ## addcontextmenufolders 文件夹右键菜单 ## associatewithfiles 关联文件 ## addtopath 添加到环境变量 附：Inno Setup 官方文档\nMERGETASKS 的内容我一直不知道该怎么写（毕竟这个是编译 Inno Setup 前 VSCode 的开发者写的），但是我突然想到 VSCode 是开源的！于是我查阅了GitHub 仓库。在分支 joao/innosetup6中的 build/win32/code.iss中找到了如下内容：\n1 2 3 4 5 6 7 8 [Tasks] Name: \u0026#34;desktopicon\u0026#34;; Description: \u0026#34;{cm:CreateDesktopIcon}\u0026#34;; GroupDescription: \u0026#34;{cm:AdditionalIcons}\u0026#34;; Flags: unchecked Name: \u0026#34;quicklaunchicon\u0026#34;; Description: \u0026#34;{cm:CreateQuickLaunchIcon}\u0026#34;; GroupDescription: \u0026#34;{cm:AdditionalIcons}\u0026#34;; Flags: unchecked; OnlyBelowVersion: 0,6.1 Name: \u0026#34;addcontextmenufiles\u0026#34;; Description: \u0026#34;{cm:AddContextMenuFiles,{##NameShort}}\u0026#34;; GroupDescription: \u0026#34;{cm:Other}\u0026#34;; Flags: unchecked Name: \u0026#34;addcontextmenufolders\u0026#34;; Description: \u0026#34;{cm:AddContextMenuFolders,{##NameShort}}\u0026#34;; GroupDescription: \u0026#34;{cm:Other}\u0026#34;; Flags: unchecked Name: \u0026#34;associatewithfiles\u0026#34;; Description: \u0026#34;{cm:AssociateWithFiles,{##NameShort}}\u0026#34;; GroupDescription: \u0026#34;{cm:Other}\u0026#34;; Flags: unchecked Name: \u0026#34;addtopath\u0026#34;; Description: \u0026#34;{cm:AddToPath}\u0026#34;; GroupDescription: \u0026#34;{cm:Other}\u0026#34; Name: \u0026#34;runcode\u0026#34;; Description: \u0026#34;{cm:RunAfter,{##NameShort}}\u0026#34;; GroupDescription: \u0026#34;{cm:Other}\u0026#34;; Check: WizardSilent 顺利解决问题\nLLVM 从官网下载安装包，访问速度可能有些慢，可以考虑使用代理 LLVM 使用 NSIS（问了中北的学姐），通过 Process 类中的方法调用其安装程序并传递参数，查阅 NSIS 的文档后，我使用的安装的命令行参数如下\n1 2 /S ## 静默安装 /D=\u0026#34;C:\\VSCode+C\\LLVM\u0026#34; ## 设置安装目录 附：NSIS 官方文档\nmingw64-w64 mingw64-w64 下载下来是一个压缩包，因此我们直接去解压文件就好 从sourceforge下载 mingw64-w64 在这么多文件里面下载 Toolchains targetting Win64\u0026gt;Personal Builds\u0026gt;mingw-builds\u0026gt;8.1.0\u0026gt;threads-posix\u0026gt;seh\u0026gt;x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z （找对版本可真不容易）\n代码文件夹和.vscode 配置 我使用的是中北大学 AI+移动互联创新实验室的配置文件 GitHub 项目地址 下载、解压、提取需要的即可\n安装方案 我的方案是：VSCode、LLVM 使用安装包安装，mingw64-w64 和代码文件夹配置等直接打包成 data.zip 然后解压缩。VSCode 插件调用命令行使用 `C:\\VSCode+C\\Microsoft Visual Studio Code\\bin\\code.cmd \u0026ndash;install-extension 插件 由于国内网络原因某些插件安装的很慢或者根本无法安装\n","date":"2020-09-18T15:17:26+08:00","permalink":"https://blog.gaein.cn/passages/vscode-c-installer/","title":"VSCode 一键配置 C/C++环境程序"},{"content":"网站从2020年9月17日午13点起宕机，到当天22:00基本恢复访问\n宕机原因如下： 没事闲的使用rm -rf /*结果没有提示直接执行（人类迷惑行为）\n解决步骤： 当场懵了然后按下Ctrl+C 查看快照 尝试连接SSH，显示密码错误 更改SSH密码，无法连接 使用阿里云紧急救援，发现服务器已经无法开启 回滚到刚刚安装环境的快照 启动nginx，修改配置文件 上传网站页面，恢复主页等访问 开启PHP，修复数据库，恢复评论系统和旧博客的访问 应多使用快照功能以便在出现问题时及时回滚\n","date":"2020-09-17T22:26:55+08:00","permalink":"https://blog.gaein.cn/passages/errorlog-200917/","title":"2020年9月17日服务器宕机说明"},{"content":"高考志愿填报一直是很令各位同学、家长纠结的事情，关系到学生的升学。高考结束已经将近一个月，我也研究了大半个月的志愿填报，将经验分享在这里\n明确主体 高考志愿是大学录取的重要依据，关系到考生4年将在哪里读大学、在哪里生活，很大程度上也会影响之后的就业、组建家庭。所以，作为考生，志愿填报是自己的责任，不能考完试就玩去了，把填报的任务完全推给家长；更不能花钱交给机构，不闻不问！这件事情一定要自己来，家长可以提出建议适度干扰，但不要以强硬的姿态来决定！ 当然就算家长强硬决定了，报考密码在你手里呀~ 不过家长的建议要充分的去参考。\n明确目的 志愿填报的目的是升学，升学的目的是就业（至少大部分是，不排除少部分精英们要为国做贡献。但是大部分普通人的目的很简单、也要现实一点，就是就业） 就业还有两种情况，一种是本科/专科毕业后就业，另一种是考研（或者读博士）后再就业，两种就业对于学校的选择不一样。\n三个因素 报考学校有三个重要因素要考虑：\n一是地域 东部大城市，如北京、上海、南京等，大部分学校分数较高，一部分学校虽然是一本招生，但是在其省市内很有可能是二批乃至三批招生。这样学校优势就是地域，能够开拓视野，同时也会有更多的工作机会。 东部二三线城市，像青岛、大连等，这些地区学校有很多可以选择，视野相对较开阔，工作机会也比中西部地区多一点。 中部城市，像兰州等地，这里的学校比较有“性价比”，可以用相对少的分数报考一所实力相对好的学校。 西部地区，像新疆、西藏，这里的学校大部分分数很低，存在很多政策性的211学校（如青海大学、石河子大学）。 二是学校 这里比的因素是学校的教学水平、学习氛围、还有社会认可度等，具体可以看学校的博士硕士授予点数量、院士的数量等，还有在校友会、软科等的排名也算是有参考价值（注意：参考价值，仅供参考）。选择一所实力强的学校往往意味着能够学到更多的技能（当然是因人而异，一天到晚不学习还想会什么纯属做梦）。当然，可以比较的还有学校的“标签”：985、211、双一流。有时候“标签”会是某用人单位招聘的“门槛”。\n三是专业 两个方面，一是专业是否是好就业的专业，比如比较热门的自动化等（当然不代表它一直好就业，这个需要了解专业做出形势推测）。二是专业是否是学校侧重的专业，比如人民政法大学侧重于法学等、理工科学校侧重与工科，电子科技大学侧重电子信息类和计算机等。大部分学校都有它的侧重点，选择学校侧重的学科可能会获得更多的资源。\n选择专业 订购一本专业解读的书，详细了解各个专业的就业方向和对身体的要求，初步选择出自己比较敢兴趣的专业，不能太少，多选一些。\n初选学校 回到目的那里。\n本科毕业就业：选择东部沿海城市的实力相对较弱点学校的易于就业的专业，保证能报上那种。 研究生毕业就业：选择西部211（政策性）或者中部985，这些学校易于考研，选择学校实力较强、地域较差的学校，学习氛围较好的学校 如果你对某方面有强烈的兴趣爱好，不妨报考一所稳上某专业的学校，浪费点分就浪费点呗！ 根据以上要点初步筛选分数差不多的学校。\n注意：宿舍、食堂、商业街等不在考虑范围之内，你要想清楚去大学不是养大爷去了，是学习去了，能上一所实力强点的学校就是睡长椅都行。这些因素我在报考时压根都没有考虑，作为一个农村娃，我觉得所有大学的宿舍都很好，很棒，真的不用过分考虑这些。高中毕业大部分都成人了，应该明白那些重要、那些不重要。\n再筛学校 将自己的分数根据今年（2020）的一分一档查到对应的位次，记住这个位次，再根据过去三年（2017、2018、2019）的一分一档查到该位次对应的分数，记下这些数据用于参考。 根据书上或者学校官网的数据，比较自己和往年的差距，如果分数和提档线不相上下，则可以冲一冲；如果分数高于提档线2~3分，则学校可以上，但是专业无法选择。 如果冲的学校不是跨水平的学校（比如二本分数冲一本、一本分数冲211 算是跨水平），则不是很有必要冲。\n提档线是自然形成的而非人为划定的，在录取工作完成之前谁也不知道提档线是多少。按照比例进行调档的最后一个人的分数则是提档线。往年数据里最低分就是提档线。\n排除一些“坑”（就是学校不行分数不少）的学校 根据自己的专业意向，选择偏该专业的学校 挨个查看学校的招生章程：是否有分数级差，查看学校招生计划：是否扩招 专业选择 将分数较高、自己喜欢、学校侧重的专业排在前面，分数较低但是可以接受的专业写在后面，尽量不被调剂但是一定要服从专业调剂。\n志愿填报 不用过于害怕网络崩溃，但是也别过分不紧张。在河北省等不限次数更改的省份，可以先填报，不满意再更改。尽早完成。\n解释说明 报志愿时遇到的部分概念做解释说明。\n分数级差 一个志愿（比如山东科技大学）各个专业之间的级差，比如考生考了605分，今年山东科技大学的分数级差是3-0-0-0-0-0，那么第一专业按605分计算，第二第三个专业在录取时按照602分计算.\n专业调剂 在考生所填报的专业计划已经满的情况下，服从专业调剂会分配到未填报的其它计划数没有满的专业。服从专业调剂不一定会被调剂到冷门专业，专业调剂是随机分配的（但是热门专业计划数都满了\u0026hellip;调剂的很大可能就是冷门专业）。所以建议考生将分低的可以接受的专业写在后面，尽量避免专业调剂。\n但是，必须勾选服从专业调剂，因为如果整个学校招生计划没满，被提档，但是所填报的专业计划全部满，又不服从专业调剂会做退档处理！大部分省份一个批次只有一次投档机会，退档后其它志愿作废，到下一批次（期间有一个征集志愿，分数很高的）才能投档。也就是本来能报本科批的滑档到专科批！可没少亏！因此，不要害怕上不了喜欢的专业，至少比滑档到下一批次强。就是十拿九稳的也要服从专业调剂，多一份保障\n平行志愿 平行志愿是“分数优先，遵循志愿”的原则，不同于顺序志愿，平行志愿退档的概率更低（服从专业调剂的情况下）。整个录取工作只进行一轮检索，因此不用担心把学校报在C志愿会因为A、B两所学校而致使检索C时C被填满。录取的流程是这样的：\n将考生按总分排名，分数相同考生比较单科成绩排名（单科成绩全部相同考生比较学考成绩）。 按照排名检索，先检索全省第一，比方他A志愿填写的“1466 清华大学”，此时系统检索清华大学招生人数，未满，则提档；提档后检索该考生的专业，第一专业人数未满，则投档给清华、录取。 系统依次检索第二、三、四\u0026hellip;人的志愿，每人都是先检索A，再检索B、C\u0026hellip;志愿。如果A志愿所填报的学校招生计划已经满，则不做提档，检索B学校，直到检索到最后一所学校，如果仍然无法投档则进入下一批次。 调档比例 比如调档比例是105%，招生计划是100人，则实际调档105人。其中肯定有因为不服从专业调剂或者身体原因或者自己申请而退档的，那么实际招生也就差不多100人，如果超出计划则使用预留人数。大部分学校即使超出计划但是你服从专业调剂也不会退档，不过还是建议拨打招生办电话进行咨询。\n注意事项 服从专业调剂 原因说了，一定要服从专业调剂！！！\n院校代码 以省教育考试院公布或发行的书本为主，不要使用往年的代码。可能有部分省份使用国标代码，但是大部分省份都是自己省内编排的代码。\n大学推荐 说说几个宝藏大学吧！这些学校不是985、不是211，但是非常厉害！\n中北大学 （我报考的就是中北大学）兵工类学校，不是军校。彭德怀创立，解放军第一所兵工院校，有人民兵工第一校的美称。兵工七子之一，国家二级保密单位。位于山西省太原市，由于学校比较低调，知名度很低。在山西省内由于省内招生优惠，分数很低，所以在山西省内也不是很有名。测控技术与仪器、航空航天等专业为王牌专业，国庆展出的军事装备中很多研发都有中北师生的身影。\n燕山大学\n位于河北省秦皇岛，综合实力超过了很多211学校，在河北省内排名第一。是河北省人民政府、教育部、工业和信息化部、国家国防科技工业局共建的全国重点大学。\n桂林电子科技大学。电子、计算机类实力很强，很多地区是二本、三本招生，受生源和地域影响其它学科发展不是很好。四大电子科技大学之一 （末）。参与北斗卫星研发。\n杭州电子科技大学。实力超过很多211，四大电子科技大学之一。位于杭州阿里巴巴隔壁，工作机会较多。\n集美大学。位于厦门市集美区。环境优美，办学水平也很高。 最近看到，这所学校航海专业很强势，如果向往星辰大海可以考虑。\n石家庄铁道大学，就业率高，土木工程等专业排名靠前。（铁路类院校）\n兰州交通大学，就业率高，车辆、通信等发展较好。（铁路类院校）\n\u0026lt;1\u0026gt;排名不分先后\n\u0026lt;2\u0026gt;具体学校数据请以官网介绍为准，本文本部分凭印象所写，难免有偏差。\n最后，欢迎报考博主所报考的中北大学，一起来碗老陈醋！\n","date":"2020-08-02T15:52:25+08:00","permalink":"https://blog.gaein.cn/passages/cee-wish-guidance/","title":"高考志愿填报指津"},{"content":"要开学了，刚刚看了以前爹妈给买的一本逆袭。一晃自己已经要面临高考，三年学习就要画上句号了。\n三年，玩过浪过也努力过。不管是摄影、航模、还是计算机，抑或是高三第一学期的奋起直追，他们填充了我的生活。\n感觉，高三这一年就像人生的一个缩影，有起有落，有大起有大落。我用了半年的时间让别人两年的努力付诸东流、又用了两个月的时间让我自己的努力付诸东流。人生没有后悔药，历史已然过去，我们无法改变。一节网课没听的两个月，我写了订餐表软件、写了考勤系统、又搭了两个站，显然，我没有去吧重心放在学习上。不能把重心放对以后又怎么创业呢？昨天和一家公司的老板聊了聊，刚认识的时候他还是创业初期，高中三年过去，他的公司已经市值5000万。但是又有几个创业者能像他一样一次成功的呢？没有几个。在他的身上我看到了很多优点，包括对时间的规划等。\n人很重要的是要自律。但是有多少人会自律的呢？显然我不算，很多同学也不算，那些真正的学霸算是的，我觉得在他们那里学习是一种享受，就像我连夜写码一样，不知疲倦。\n好在，又是开学季。尽管心有不甘，为什么？我在别人元旦晚会开心看电影的时候去学习，在未来的两个月以及过去的半年里在别人睡觉的时候去学习，可是却在家里、有着大把自主安排的时间，却没有放在学习上。但是正如前文所说，历史无法改变，而且以我对自己的了解在给我两个月我可能也会浪费过去。好在今年高考延期，给了我反攻机会。我用了半年爬到了班级第一，看到了211的梦想，是否还能用两个月再回到那个时候呢？每一次考试对于自己都是奖励，我希望今后能这样。学习是有奖励机制的，只不过容易陷入循环（考得好\u0026gt;好好学\u0026gt;考得好or你懂的）。学长和我说要有个好的心态，希望吧。无论在开学后的考试如何翻车，也要坚持学习，因为我相信自己不会是一个平凡的人。我能用半年追到别人学习三年的成绩，凭什么不能用两个月干翻两个月？\n我想，高三一年是一部故事。我的故事一定会很奇特，毕竟这里有大起有大落，有欢笑有泪水。那么现在刚刚大落完的我，或许还能大起？\n展望一下未来，大学。在我喜欢的专业干我喜欢的事情。 日常语无伦次，今日有些感想记在此处。开学后奋起直追，力挽狂澜，夺回本属于自己的。\n穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云；抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也\n既然是青年，就该有青年的热血和奋发。红日初升，其道大光；河出伏流，一泻汪洋！\nGaein nidb\n2020 04 20\nLIVE FOR DREAM/爲夢而生\n","date":"2020-04-20T18:12:08+08:00","permalink":"https://blog.gaein.cn/passages/diary-20200420/","title":"最特殊的高三开学前的一些感想"},{"content":"由于博客和其它的程序，经常要接触MySQL数据库。自己暑假想要学习PHP，肯定也要用到MySQL数据库。为了避免经常上网查常用的命令，就写篇博客备用。\np.s. 为什么我感觉我从一个写桌面程序(CSharp.NET)的孩子变成了web运维(???)\n相关链接 菜鸟教程 MySQL官网下载\n终端命令 连接MySQL 1 mysql -p ##使用root连接，如果需要在命令行中输入密码，则密码与\u0026#34;-p\u0026#34;之间没有空格 参数\n1 2 3 4 5 -u ##指定用户 -p ##密码（必选，新版MySQL已经不支持无密码登录） -P ##端口，默认3306 -h ##服务器地址 -D ##数据库名 开启、关闭MySQL 1 2 3 4 mysqladmin -u root -p shutdown ##关闭MySQL，需要输入密码 ##切记！千万不要使用kill等命令关闭MySQL，可能会造成数据损坏 service mysqld start ##启动MySQL service mysqld status ##查看运行状态 查看默认密码 1 sudo grep \u0026#39;temporary password\u0026#39; /var/log/mysqld.log ##刚安装完MySQL时候使用此命令查看初始化的密码 备份与恢复 备份（导出.sql文件） 终端输入：\n1 mysqldump -u root -p 用户名 数据库名 \u0026gt; dump.sql 恢复（导入.sql文件） MySQL输入：\n1 SOURCE /data/文件路径; 修复 有时候错误的关闭MySQL会造成数据损害，此时可以尝试修复。MySQL内输入命令：\n1 2 3 CHECK TABLE 表名称;##检查数据表是否损坏 REPAIRE TABLE 表名称;##修复损坏的表 REPAIR TABLE EXTENDED 表名称;##速度慢，修复率高 MySQL命令 用户管理 新版MySQL的密码规则要求密码必须包含大小写字母、特殊字符、数字，并且长度在8个字符及以上。不符合会弹出\u0026quot;ERROR 1819 (HY000): Your password does not satisfy the current policy requirements\u0026quot; 在某些数据库中localhost可能是\u0026quot;%\u0026quot; ########## 新建用户\n1 CREATE USER \u0026#39;用户名\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; ########## 添加权限\n1 GRANT 权限 ON 数据库.数据表 TO \u0026#39;用户名\u0026#39;@\u0026#39;localhost\u0026#39; WITH GRANT OPTION; 其中权限有\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 1) 授予数据库权限时，\u0026lt;权限类型\u0026gt;可以指定为以下值： SELECT：表示授予用户可以使用 SELECT 语句访问特定数据库中所有表和视图的权限。 INSERT：表示授予用户可以使用 INSERT 语句向特定数据库中所有表添加数据行的权限。 DELETE：表示授予用户可以使用 DELETE 语句删除特定数据库中所有表的数据行的权限。 UPDATE：表示授予用户可以使用 UPDATE 语句更新特定数据库中所有数据表的值的权限。 REFERENCES：表示授予用户可以创建指向特定的数据库中的表外键的权限。 CREATE：表示授权用户可以使用 CREATE TABLE 语句在特定数据库中创建新表的权限。 ALTER：表示授予用户可以使用 ALTER TABLE 语句修改特定数据库中所有数据表的权限。 SHOW VIEW：表示授予用户可以查看特定数据库中已有视图的视图定义的权限。 CREATE ROUTINE：表示授予用户可以为特定的数据库创建存储过程和存储函数的权限。 ALTER ROUTINE：表示授予用户可以更新和删除数据库中已有的存储过程和存储函数的权限。 INDEX：表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。 DROP：表示授予用户可以删除特定数据库中所有表和视图的权限。 CREATE TEMPORARY TABLES：表示授予用户可以在特定数据库中创建临时表的权限。 CREATE VIEW：表示授予用户可以在特定数据库中创建新的视图的权限。 EXECUTE ROUTINE：表示授予用户可以调用特定数据库的存储过程和存储函数的权限。 LOCK TABLES：表示授予用户可以锁定特定数据库的已有数据表的权限。 ALL 或 ALL PRIVILEGES：表示以上所有权限。 2) 授予表权限时，\u0026lt;权限类型\u0026gt;可以指定为以下值： SELECT：授予用户可以使用 SELECT 语句进行访问特定表的权限。 INSERT：授予用户可以使用 INSERT 语句向一个特定表中添加数据行的权限。 DELETE：授予用户可以使用 DELETE 语句从一个特定表中删除数据行的权限。 DROP：授予用户可以删除数据表的权限。 UPDATE：授予用户可以使用 UPDATE 语句更新特定数据表的权限。 ALTER：授予用户可以使用 ALTER TABLE 语句修改数据表的权限。 REFERENCES：授予用户可以创建一个外键来参照特定数据表的权限。 CREATE：授予用户可以使用特定的名字创建一个数据表的权限。 INDEX：授予用户可以在表上定义索引的权限。 ALL 或 ALL PRIVILEGES：所有的权限名。 （权限列表摘自biancheng.net） ########## 回收权限\n1 REVOKE 权限 ON 数据库.数据表 FROM \u0026#39;用户名\u0026#39;@\u0026#39;localhost\u0026#39;; ########## 更改密码\n1 ALTER USER \u0026#39;用户名\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; ##更改密码 ########## 删除用户\n1 DROP USER \u0026#39;用户名\u0026#39;@\u0026#39;localhost\u0026#39;; 数据管理 ########## 列出数据库\n1 SHOW DATABASES; ########## 选中数据库\n1 USE 数据库名; ########## 查看数据库大小\n1 2 3 4 USE information_schema; select concat(round(sum(data_length/1024/1024),2),\u0026#39;MB\u0026#39;) as data from tables;##查看总大小 select concat(round(sum(data_length/1024/1024),2),\u0026#39;MB\u0026#39;) as data from tables where table_schema=\u0026#39;数据库名\u0026#39;;##查看指定数据库大小 select concat(round(sum(data_length/1024/1024),2),\u0026#39;MB\u0026#39;) as data from tables where table_schema=\u0026#39;数据库名\u0026#39; and table_name=\u0026#39;表名\u0026#39;;##查看指定表的大小 ########## 新建数据库\n1 CREATE DATABASE 数据库名; ########## 删除数据库\n1 DROP DATABASE 数据库名; ","date":"2020-04-17T15:10:44+08:00","permalink":"https://blog.gaein.cn/passages/mysql-usage/","title":"MySQL常用命令：导入导出、创建数据库等"},{"content":"缘由 最近阿里云的服务器到期了，由于阿里云学生机活动规则更改了，而我手里的服务器已经升级无法再使用优惠价格续费。只好中转其它服务器，再将手里的第二台服务器退款。总之是很折腾的\n过程 我选择的安装方式并不是一键安装包、也没有用面板。总感觉那些东西安装完成之后不在自己习惯的位置。用着很不舒服，改配置文件还要搜索。所以我使用熟悉的yum来进行安装\n使用我自己写的脚本 wget https://res.gaein.cn/files/bash/init.sh\u0026amp;\u0026amp;sudo ./init/sh\n进行自动化安装 （如果提示未知命令请先安装wget，参考下文）\n脚本因为用不到所以删了\n安装基础软件I 包括\nwget (下载) tmux (终端复用)。 没有他们无法完成下一步的配置yum源。\n安装wget 使用命令 wget\n如果输出\n1 2 3 wget: missing URL Usage: wget [OPTION]... [URL]... Try \u0026#39;wget --help\u0026#39; for more options. 则已经安装wget。\n如果输出未知命令之类的，则使用 yum install -y wget 安装wget。\n安装tmux tmux是一款优秀的终端复用神器，它可以在后端运行。也就是在里面运行的进程不会在你关闭SSH时结束。对于压缩转移大文件、下载大文件很有用（比如稍后我们安装MySQL用到将近一个小时，就是在tmux里面操作的）同时tmux还提供窗口切分、切换，让我们更方便的使用终端。\n目前已知tmux和lrzsz不兼容\n使用命令 tmux --help 来查看是否安装了tmux。如果输出\n1 2 usage: tmux [-2CluvV] [-c shell-command] [-f file] [-L socket-name] [-S socket-path] [command [flags]] 则已经安装，输出未知指令之类的，则使用 yum install -y tmux 进行安装\n使用tmux tmux采用快捷键 Ctrl+B 来激活控制台。同时按下键盘上面的Ctrl 和 B ，然后在按键盘就是tmux命令（快捷键）了。注意，使用 Ctrl+C 无法强制结束tmux，只会结束里面的任务。 Ctrl+B 后的常用快捷键（注意先按Ctrl+B再按下快捷键！）\nD隐藏tmux（类似于windows的最小化，隐藏窗口而不退出，里面的进程继续） X关闭tmux当前窗口（需要输入 y/n 确定或取消） N下一个窗口 P上一个窗口 %将窗口分为左右两块 \u0026quot;将窗口分为上下两块，注意是英文半角的\u0026quot; 记住这些命令也就暂时够了，其它的以后再研究\n配置yum源 默认的yum源速度较慢、而且提供的软件不是很多。\n配置epel 使用命令 yum install -y epel-release 安装epel\n使用阿里镜像 输入命令\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n下载repo文件\n配置WebStatic WebStatic提供最高到PHP7.2（目前我就需要PHP,yum默认的是PHP5.6）\n使用命令\nyum install -y https://mirror.WebStatic.com/yum/el7/WebStatic-release.rpm 安装rpm包\n配置完后别忘了使用\nyum clean all \u0026amp;\u0026amp; yum makecache 来清空yum的缓存，使用 yum update 来进行更新。\n安装基础软件II 操作服务器的一些常用软件。一般来说都预装的。可惜，我这神奇服务器没有。\n包括：\nvim(文本编辑) curl(下载) tar(tar压缩) 7za(7z压缩) lrzsz(通过XShell终端传输文件) git 对于这些软件我无所谓版本，直接 yum install 安装就可以(不说都是最新的也旧不了太多吧)\n这些软件都可以使用yum安装\nyum install -y curl lrzsz yum-utils vim p7zip git-core\n安装nginx 使用命令\nwget http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.16.1-1.el7.ngx.x86_64.rpm 下载rpm包，然使用命令\nrpm -ivh nginx-1.16.1-1.el7.ngx.x86_64.rpm\n安装nginx官方的rpm（版本1.16.1）需要其它可以自行到官方查看\nnginx官网\n注意：使用 yum install nginx 安装的为WebStatic源中的1.12版\n常用命令 1 2 3 4 5 nginx -v #查看nginx版本 service nginx start|stop|restart #启动|停止|重启nginx服务 nginx -t #检查配置文件是否正确 nginx -s reload #重载配置文件 nginx #启动nginx 安装PHP 使用命令\nyum install -y php72w-common php72w-fpm php72w-opcache php72w-gd php72w-mysqlnd php72w-mbstring php72w-pecl-redis php72w-pecl-memcached php72w-devel\n进行安装\n这里安装了PHP PHP-FPM和一些常用模块，可以自行裁决。一般这些模块已经可以完美的支持WordPress、ZBlog等博客程序了\n如果想要安装PHP其它版本，把72w改成版本+w就可以咯\n安装MySQL 参考以前写过的文章：\nCentOS部署MySQL8步骤\n进行，这里只写主要步骤\n下载rpm\nwget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm\n//由于MySQL的rpm很大，所以采用先下载后安装\n使用命令导入MySQL rpm\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\n使用命令\nyum install -y mysql-community-server 来安装\n常用命令 更多命令见 MySQL常用命令：导入导出、创建数据库等\n1 2 3 4 service mysqld start ##启动 service mysqld status ##查看状态 sudo grep \u0026#39;temporary password\u0026#39; /var/log/mysqld.log ##查看默认密码 mysql -u root -p ##连接 1 2 3 4 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;pWD123456-\u0026#39;; #更改密码 SHOW DATABASES; #显示数据库 USE 数据库名; #切换到数据库 exit #退出 ","date":"2020-04-16T15:40:30+08:00","permalink":"https://blog.gaein.cn/passages/config-lnmp-on-centos/","title":"CentOS配置PHP+Nginx+MySQL——记一次环境配置的过程"},{"content":"尽管全网都在说surface pro7的键盘盖不支持pro3，但是我还是义务反顾买了一个，结果发现，完美兼容！\nsurface pro3的键盘盖终于被我玩坏了，考虑到暑假也许会买pro7（和laptop3纠结半天了）所以我准备先买一个键盘盖防止到时候纠结（我真是个机灵鬼）看了一下官方的介绍，支持pro3.于是淘宝找了一家店准备入手，结果卖家告诉我不支持pro3，百度一番也都说支持到pro4。但是我给微软打电话后，微软肯定的告诉我支持pro3并且硬核告诉我其他渠道不用参考（是真的“巨硬”）。尽管卖家一再跟我说他们是实测的，我还是买了，不行就吃半年灰呗，早晚也要用到的啊！\n配置 说说我实测成功的pro3吧 最低配 Microsoft surface pro3 i3 64G 系统是Windows 10 1909（Surface OEM版本）\n我觉得他们不能兼容的或许就是自己重装的系统的问题，没法识别type cover。我的surface pro3收来的时候是w10专业版，我自己重装了OEM系统（就为了surface的LOGO！）\n上图 即使是老款的surface pro3，她仍然是那么漂亮! surface pro3的背面还是“surface”，到了pro4就改成了标志性的巨硬四方格标\n键盘材质非常棒，是微软大肆宣传的新一代 Alcantara 材质，摸上去确实很像皮革，非常舒服！据说还是非常耐脏的！ 说好的完美兼容，就要连大小都一样！下面的标已经是Microsoft了，pro3的键盘盖还是surface 键程适中的键盘，非常有感觉，比起pro3的键盘进步很大了（毕竟好多年了），pro3的键盘，几乎没有手感可言。而pro7的键盘，我感觉已经对得起她的价格了！另外锁定Fn也是一个非常实用的功能。\n如图是我的系统配置，丝毫不吹，完美兼容! ","date":"2020-02-28T14:23:25+08:00","permalink":"https://blog.gaein.cn/passages/newtypecover-on-surfacepro3/","title":"最新版surface pro7键盘盖兼容pro3！实测"},{"content":"闲来无事安装了Office2019，激活软件是从 HWIDGen 作者的 Github 上面拉下来的（顺手汉化了一下），KMS激活，180天\n2021.5.27 作者 GitHub 已经没了\n其实网上貌似有很多类似的，但是大多数都不怎么“讲究”，再者下载的激活软件很多不能用或者有病毒，虽然我不能保证我提供的激活100%安全，但是我还是选择相信HWIDGen的开发者。\n下载Office2019 注意，office2019仅支持Windows10系统，如果想要知道您的操作系统是什么，可以在属性中查看，或者直接看左下角开始菜单的标志，如果是“开始”，则为Windows XP系统，原型的Windows标志是Windows7系统，四方格标志是Windows10系统（不一定准确，但是大多没问题！）\n如果您使用的是Windows7操作系统可以安装Office2016，不可以安装Office2019\n如果您使用的是WindowsXP操作系统那么放弃吧，转WPS吧\n下面是Office2019和Office2016的下载链接，来自 MSDN，我告诉你\nOffice2019 : ed2k://|file|cn_office_professional_plus_2019_x86_x64_dvd_5e5be643.iso|3775004672|1E4FFA5240F21F60DC027F73F1C62FF4|/ Office2016 : ed2k://|file|cn_office_professional_plus_2016_x86_x64_dvd_6969182.iso|2588266496|27EEA4FE4BB13CD0ECCDFC24167F9E01|/ 可以使用迅雷等工具进行下载，复制“ed2k:\u0026hellip;..|/”并粘贴即可\n解压安装 我将文件下载到了D:\\安装包\n右键下载来的文件（它通常在D:\\迅雷下载里面 根据你设置的路径而定（在复制完链接下载之前有个对话框，里面有选择的）如果找不到可以打开迅雷，通常在已完成\u0026gt;你下载的文件边上有个文件夹的标志，点击它可以打开文件夹）\n右键之后选择“解压到\u0026hellip;”，如果没有这个选项可以选择“解压到当前文件夹”，如果都没有可以去安装压缩软件（推荐Bandizip，详见 这一篇博客），或者右键\u0026gt;挂载（仅限于Windows10操作系统）\n打开解压出来的文件夹（或者挂载的盘，他们通常是最后一个盘符）\n如果你希望自动安装，可以双击setup.exe（Office2019是默认安装64位，2016默认安装32位；希望手动安装可以进入office目录，安装相应版本，推荐64位）\n如果你听不懂小括号里面是啥就直接双击即可\n如果你准备安装Office2016，而且觉得自己电脑配置还行的话就进入Office目录，双击“setup-64.exe”（或者类似的名字）如果无法安装再双击“setup.exe”\n安装过程是全自动，你可以坐下来歇会，大概5分钟左右（Microsoft surface pro3），好一点的电脑应该会更快，不过也不排除我电脑有微软本家加成（如果你听不懂我在说什么等着就好）\n如图即为安装成功\n更改安全设置 如果您希望白嫖这款软件，后面的步骤是必须的。如果您希望支持微软可以去官方购买Office2019激活密钥或者淘宝购买\n在开始下面的操作之前可以新建一个文件夹，比如G:\\工具。稍后我们的激活操作将在这里面进行，请确保您能够找到此文件夹\n打开安全中心（如果您使用其它软件可以尝试直接进行下一步操作，再杀毒软件报告含有病毒时选择允许就可以了） 激活软件由于涉及到敏感操作，会被判定为病毒\n点击管理设置 添加或删除排除项 添加排除项\u0026gt;文件夹。选择我们刚才新建的文件夹G:\\工具\n激活Office 首先下载激活软件\n该软件和知名的系统数字权利激活软件HWIDGen为同一人开发，我选择相信软件开发者\n注意，在网上找到的激活软件仍然有含有病毒的可能性。我提供的软件是从作者的Github（源码仓库）获取的\n暂时不可用 点击此处下载: https://static.cdn.gaein.cn/files/tools/ActivateTools/激活office.zip\n（我已经将它翻译为了中文，当然还是混有部分英文的。不过以下的图片是全英文的）\n解压到文件夹 进入“v36” 右键，以管理员身份运行 出现此窗口，然后稍等片刻（大概有一两分钟吧） 程序会自动检查未激活的Windows系统和Office并激活他们。此时如果杀毒软件弹出任何禁止的东西，请选择允许运行\n出现到此即为成功（汉化之后的会有激活成功字样）\n（附汉化版图片） 5. 打开Office（word excel都行），弹窗，点击接受 6. 至此Office激活完成! 安装的是初始版本，可以点击更新进行更新 ","date":"2020-02-28T09:29:34+08:00","permalink":"https://blog.gaein.cn/passages/how-to-install-office19/","title":"Office 2019安装（附激活）"},{"content":"由于疫情原因，不能上学，学校只好把学习资料、试题发到同学们手中，于是我开始遇到各种提问，为什么打不开、打开是空白、公式乱码、缺页\u0026hellip;其中大多数是软件的问题，很多人都用了QQ浏览器。我就好奇腾讯你不好好开发浏览器搞什么飞机。\n** 既然您点进来了，一定是遇到了相应的问题，请阅读本文。感谢您的合作！ **\n文件的类型 首先来说一下经常遇到的文件类型，主要是看文件的后缀名，就是\u0026quot;.\u0026ldquo;后面的字符，比如VSCode.exe，那么后缀名就是.exe，由此判断是可执行程序\n.doc或.docx 最常见的文档类型，是word文档；.doc是旧版本的类型（word97-2003）文档 .xls或.xlsx是excel文档（表格文件） .ppt或.pptx是PowerPoint文档（就是我们常说的PPT） 以上这些属于一个类型，我们暂且叫他文档。\n.pdf,是“便携式文档格式”，PDF文件，无论在哪种打印机上都可保证精确的颜色和准确的打印效果，即PDF会忠实地再现原稿的每一个字符、颜色以及图象。PDF不会受软件不同而影响，使用非常广泛。而且一般软件不能编辑PDF内容，有利于保护内容不受篡改。通常我们就称之为PDF。 ** 强烈建议学校将文件排版好后输出为PDF文件，这样不会因为使用错误的word软件而造成公式乱码 **\n.txt文本。纯文本文件几乎可以使用任何文本查看软件打开，如果出现乱码电脑版可以下载notepad++，更改编码查看。不再赘述。\n. rar .7z 或.zip文件。是压缩文件，通常包含一个或多个文件。\n文档的打开方式 推荐两家的软件：\nMicrosoft Office 金山WPS 1，使用Microsoft Office 简介 使用Microsoft Office办公套件打开，Office办公套件包含word、excel、ppt等。我们在学习或者办公室常见的word2003就属于office（当然是老版本了）。 鉴于下发的文件有部分为docx、xlsx、pptx，无法使用老版本打开（或者打开后出现错误），推荐安装最新版Microsft Office 2019或者Office365。当然，这些软件都是收费的。\n注：Microsoft是微软，Office是微软的一个产品，微软目前是全球最大的电脑软件提供商，其创始人是比尔盖茨 * ** 注意，尽管office软件的名字是英文，但他们是全中文界面的 ** ** 注意，手机版的office是可以免费下载安装的，并且可以查看文档。但是想要编辑、保存文档需要付费 ** 安装电脑版Office 如图是我使用的Office Word 2019专业增强版\n如果你想要免费的永久安装使用Microsoft Office 2019，请看我的另外一篇博客：Microsoft Office 2019 安装与激活（点击跳转）\n安装手机版Office 如果想要使用手机版Microsfot Office办公套件，可以在软件商城里面搜索Word、Excel或者Powerpoint。结果通常会是金山WPS或者Microsoft Office Word或Microsoft Excel或Microsoft Office Powerpoint。注意下载安装您想要的（金山WPS或者Microsoft Office） 如图是Word的详情页面 请注意核实开发者或开发商为Microsoft Corporation或微软 如图便不是我们需要的Word，不要下载这种软件 ** 请确保下载的是正儿八经的Office Word（或Excel、Powerpoint），不推荐其他软件！ ** 如果你不能确保在软件商城里面找到的是真正的Office，请到官网（下面链接）下载 https://products.office.com/zh-cn/mobile/office-mobile-apps-for-android\n2，使用金山WPS 简介 另外一个类似于Microsoft Office的软件是金山WPS，包含WPS文字（功能对应Office Word）、WPS表格等等。金山WPS是免费的国产软件，相比于Office来说它的缺点是含有广告。如果你不是特别介意的话，可以使用金山WPS查看、编辑文件，如果你介意请参考上面那篇博客，免费安装Office 2019（略费事），或者花钱购买。* 为了保护版权，有能力最好要购买正版。 * 下载金山WPS直接在手机应用商城里面搜索WPS即可，有的应用商城搜索word等也会显示出金山WPS（为了保证结果准确，推荐搜索WPS）\n安装电脑版WPS 电脑版的金山WPS直接访问官网下载即可，金山官网链接：https://www.wps.cn/\n安装手机版WPS 如图，是苹果AppStore的搜索结果。第一个结果是Microsoft Office Word，属于我们介绍的Office办公套件；第二个结果就是金山WPS 金山WPS的详情页面 ** 为了防止下载错误的软件而带来不便或损失，请务必核实一下软件开发商/开发者为金山办公软件或金山办公软件有限公司或者Kingsoft **\n########## ** 再次强调，除了Office和WPS，不推荐任何其他的软件。这两家在处理文档方面是巨头，其他品牌的产品基本没有能与之媲美的 **\nPDF的打开方式 通常，任意浏览器都能打开PDF。但是我观察到有的同学在用QQ浏览器打开WPF文件时出现了缺页现象。 如果你感到自己的PDF文件缺页的话，请下载以下软件：\nAdobe Acrobat Reader 福昕PDF阅读器安卓版（或IOS版） 1，使用Adobe Acrobat Reader PDF是由Adobe公司出品的，同样Adobe Acrobat Reader也是该公司的产品之一（大名鼎鼎的PhotoShop也是改公司的产品，“PS”、“P图”则是由这个产品衍生出的词汇），Adobe Acrobat Reader有着良好的兼容性。缺点是体积较大。 图片是我使用的收费版Adobe Acroat Pro Adobe Acrobat Reader是免费软件。拥有编辑功能的Adobe Acrobat Pro是收费的。 如图是Adobe官方的介绍\n安装电脑版Acrobat Reader 到官网下载： https://get.adobe.com/cn/reader/?promoid=KSWLH 注意不要勾选“可选程序”中的可选程序：“是，请安装免费的 McAfee Security Scan Plus 工具以检测我的电脑安全。该工具不会更改现有防病毒程序或电脑设置。”；当然，如果您希望安装杀毒软件也可以勾选，McAfee Security Scan Plus是全球知名的杀毒软件。 下载界面\n安装手机版Acrobat Reader 在应用商城中搜索Acrobat Reader，安装即可。注意核实软件开发商/开发者为Adobe Inc.\n2，使用福昕PDF（Foxit PDF） 福昕软件开发有限公司（Foxit Corporation）是全球领先的PDF软件方案与服务提供商，也是国内为数不多的具有全球影响力和竞争力的中国的软件品牌和基础软件开发商之一。福昕PDF阅读器弥补了Adobe Acrobat Reader的缺点，启动更加迅速，体积小巧。但是免费版会在编辑后留下水印。\n安装电脑版福昕PDF 到官网下载： https://www.foxitsoftware.cn/pdf-reader/ 福昕的版本较多，可以下载其他版本尝试。注意，很多版本都是收费的。考虑到平常只涉及基础的PDF阅读查看，下载如上链接的PDF阅读器即可。\n安装手机版福昕PDF 在软件商城中搜索福昕PDF 注意核实开发者/开发商为‪Foxit Software Inc.或福昕软件 如果不能确定可以到官网下载 https://www.foxitsoftware.cn/pdf-reader-mobile/\n压缩文件的打开方式 手机 .7z .zip文件可以使用手机自带的解压缩功能（限于Android系统），如果希望查看.rar文件，或者手机系统自带的解压出来的文件有问题，可以下载ES文件浏览器，或者应用商城内搜索解压软件，随意下载即可。\n电脑 Windows10系统自带解压能够解压.7z .zip .rar文件，双击文件打开，点击上方提取即可。 如果不希望使用自带的解压功能可以考虑Bandizip或者winRAR\nBandizip 界面美观简洁的压缩解压软件，无任何广告且个人/家用100%免费 支持所有常见类型的压缩文件。官网下载链接： http://www.bandisoft.com/bandizip/ 界面如图 ** 我在测试版本中发现它加入了广告，但是目前的最新版是没有广告的，而且测试版只是下角有一个小框，写着购买专业版 **\nWinRAR 如图是加持广告的WinRAR 老牌压缩解压软件，缺点是个人免费版含有广告 实测压缩解压速度比bandizip稍快 http://www.winrar.com.cn/download.htm 下载选择免费个人版下载即可，如果您不知道自己的操作系统是32位还是64位下载32位即可。如果您有兴趣可以右键我的电脑（或计算机或此电脑）\u0026gt;属性 如果系统是Winows XP，那么很大可能是32位系统，如果在Windows XP后面注明了x64版则是64位版本 如果系统是Windows 7 则系统类型：那行会写出64位操作系统或32位操作系统 如果系统是Windows10，那么很大可能是64位系统，系统类型：那行会有64位操作系统或32位操作系统 全文终，感谢您的认真阅读 对应的文件格式一定要用相应的专业软件打开，像QQ浏览器这样的软件不知道害了多少人\n","date":"2020-02-20T08:29:59+08:00","permalink":"https://blog.gaein.cn/passages/openfile-in-rightway/","title":"打开文档公式乱码的解决办法——使用正确的软件"},{"content":"利用PHP实现简单的考勤打卡、人数统计功能。\n这什么屑玩意啊，黑历史黑历史。\n先讲个故事\u0026hellip; 由于疫情原因，开学延迟，班主任为了监督我们学习，所以叫我们每天打卡。那么就要到群里点人，还要统计，谁打卡了谁没打卡谁迟到\u0026hellip;我一想太麻烦了\n于是我在群里水了一句，要不然开发个考勤系统吧\n当然我当时的开发指的是“面向百度”编程（就是随便找个什么源码改一下title。\n结果我发现行不通\u0026hellip;没有符合我要求的源码，只好试试了。\n我虽然接触了点编程，不过PHP还真没碰过，想想编程语言也都是26个字母只好硬着头皮干了。\n要求 明确一下自己的期望吧：\n能记录打卡人（开始就这一个想法） 好的没有了。\n现在实现的功能（很多都是我晚上在被窝的新奇想法）\n记录打卡人，打卡时间，自动标注准时或者迟到； 打卡成功后返回页面，提示成功与否并且提示信息（非常智障的实现，我跳转了一个html并且get传参信息，当时自己不知道php echo能输出html）；（2021补:什么我为什么要用php echo来输出html？？？） 后台统计打卡人数、未打卡人数、迟到人数还有未打卡人名单； 准备 语言：思考来思考去，服务器只装着PHP，空间倒是有 .NET fw，不过看看还是PHP的网站居多； 实现：操作数据库一想就头大了，MySQL这玩意真玩不了，上次导入旧博客数据就差点没玩死我，想想还是直接磁盘上写文件吧； 服务器：本来想用我一个虚拟主机来着，不过那玩意权限有问题，写不了文件，无奈搬到网站服务器上面； IDE：没有专门去找PHP的IDE，直接用的vscode+网上随便找一个在线PHP作为调试； 开工 表单页面 表单创建 想来想去输入一个姓名就可以了，后来又想想需要一个时间，那么html如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;考勤打卡\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;process.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 姓名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 时间：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;time\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 日期：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;filename\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;打卡 \u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 看起来是这样的：\n（丑死了）\n\u0026lt;!DOCTYPE html\u0026gt; 和 meta 是必须的，否则有可能乱码。\nform 标签里面是表单，action 后面是提交到的地址，method 是方法（别问我为啥用 post ，因为它看起来好看）\ninput 中的 type 是输入的类型，text 自然就是文本啦，submit 是提交表单，name 是参数的名字（我日期参数是 filename 是因为我想把存储打卡信息的文件用日期命名），value 是默认的值。\n时间获取 那么又一个问题来了，时间和日期怎么获取？这就要用的javascript 了，js 获取时间和日期后再去改动 html，为了找到他们我把他们用 div 框起来然后给他们 id 为 0 和 1（懒死了）\njs 的时间获取百度一下就有，不过获取的都是浏览网页的人电脑上的时间，我怕别人通过修改本地时间来掩盖自己迟到的事实，所以我要去获取网络时间。\n我的方法是 get 请求自己的服务器，在返回的头里面有时间信息（服务器的）。当然，你也可以百度一下时间 api，调用起来也会很方便的。 js 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;script\u0026gt; function getTime(){ ajax() function ajax(option){ var xhr = null; if(window.XMLHttpRequest) { xhr = new window.XMLHttpRequest(); } else { // ie xhr = new ActiveObject(\u0026#34;Microsoft\u0026#34;) } // 通过get的方式请求当前文件 xhr.open(\u0026#34;get\u0026#34;,\u0026#34;/\u0026#34;); xhr.send(null); // 监听请求状态变化 xhr.onreadystatechange = function(){ var time = null, curDate = null; if(xhr.readyState===2) { // 获取响应头里的时间戳 time = xhr.getResponseHeader(\u0026#34;Date\u0026#34;); curDate = new Date(time); //下面修改HTML document.getElementById(\u0026#34;0\u0026#34;).innerHTML = \u0026#34;时间：\u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;time\u0026#39; value=\u0026#39;\u0026#34;+curDate.getHours()+\u0026#34;:\u0026#34;+curDate.getMinutes()+\u0026#34;\u0026#39; readonly\u0026gt;\u0026lt;br\u0026gt;\u0026#34;;//拼接时间 document.getElementById(\u0026#34;0\u0026#34;).innerHTML = \u0026#34;日期：\u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;filename\u0026#39; value=\u0026#39;\u0026#34;+curDate.getFullYear()+(curDate.getMonth()+1)+curDate.getDate()+\u0026#34;\u0026#39; readonly\u0026gt;\u0026lt;br\u0026gt;\u0026#34;;//通过readonly阻止修改时间 } } } } \u0026lt;/script\u0026gt; 页面代码 因为HTML是顺序加载的，所以我希望 HTML 加载完全后再读取js（否则 js 会找不到 id 为 0 的 div），所以我们写个 onload，为了刷新时间我在 getTime 函数里面利用 setTimeout 调用它自己实现定时（一分钟）刷新。HTML全文如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;考勤打卡\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; function getTime() { ajax() function ajax(option) { var xhr = null; if(window.XMLHttpRequest) { xhr = new window.XMLHttpRequest(); } else { // ie xhr = new ActiveObject(\u0026#34;Microsoft\u0026#34;) } // 通过get的方式请求当前文件 xhr.open(\u0026#34;get\u0026#34;,\u0026#34;/\u0026#34;);//可以把/改成https://www.baidu.com/ xhr.send(null); // 监听请求状态变化 xhr.onreadystatechange = function() { var time = null, curDate = null; if(xhr.readyState===2){ // 获取响应头里的时间戳 time = xhr.getResponseHeader(\u0026#34;Date\u0026#34;); curDate = new Date(time); //下面修改HTML document.getElementById(\u0026#34;0\u0026#34;).innerHTML = \u0026#34;时间：\u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;time\u0026#39; value=\u0026#39;\u0026#34;+curDate.getHours()+\u0026#34;:\u0026#34;+cur.DateGetMinutes()+\u0026#34;\u0026#39; readonly\u0026gt;\u0026lt;br\u0026gt;\u0026#34;;//拼接时间 document.getElementById(\u0026#34;1\u0026#34;).innerHTML = \u0026#34;日期：\u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;filename\u0026#39; value=\u0026#39;\u0026#34;+curDate.getFullYear()+(curDate.getMonth()+1)+curDate.getDate()+\u0026#34;\u0026#39; readonly\u0026gt;\u0026lt;br\u0026gt;\u0026#34;;//通过readonly阻止修改时间 } } } setTimeout(getTime, 60000); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;getTime()\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;process.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 姓名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;打卡 \u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 很可惜在自己家电脑上面是无法完成测试的，\n把html上传到服务器之后效果是这样的:\n虽然很丑，但是功能实现了，手动试一试确实无法修改时间、日期，而且时间也会每分钟刷新\nPHP页面 由于PHP较为奇特的语法，和跟没有一样的报错，坑了我很长时间。PHP中字符串用 . 拼接、变量无需声明前面加上 $ 即可\u0026hellip;建议先过一遍菜鸟教程或者w3school\n参数接收 PHP中接收到的POST的参数的值在\n1 $_POST[\u0026#34;参数名\u0026#34;] GET的在\n1 $_GET[\u0026#34;参数名\u0026#34;] 参数处理 文件名 1 $filename=$_POST[\u0026#34;filename\u0026#34;].\u0026#34;txt\u0026#34;;//拼接文件名 姓名 1 $name=$_POST[\u0026#34;name\u0026#34;]; 时间 1 2 3 4 5 6 7 8 9 $time = str_replace(\u0026#34;:\u0026#34;,\u0026#34;\u0026#34;,$_POST[\u0026#34;time\u0026#34;]);//把时间里的“:”去除掉 if ((int)$time\u0026gt;730)//7:30之后迟到 { $name=$name.\u0026#34;[迟到]\u0026#34;; } else { $name=$name.\u0026#34;[准时]\u0026#34;; } 写入文件 我使用的是函数\n1 file_put_contents(文件,内容,模式可选); 文件是文件的路径（字符串），比如/root/test.txt；（没有则创建一个文件）\n注意：当无法创建且无法写入文件时，应该检查是否有权限。当能够创建但是无法写入文件时，应该检查首次写入的字符串是否为空，再检查后续代码是否有相关的操作覆盖了该文件，最后记得check一下你的磁盘空间（真的，我的硬盘满了，我检查了一天代码\u0026hellip;）\n内容是需要写入文件的内容； 模式是写入文件的模式，它包括：\nFILE_USE_INCLUDE_PATH //检查 filename 副本的内置路径? FILE_APPEND //添加模式更改文件，向文件的末尾加入字符串 LOCK_EX //锁定文件 //如果模式为空则采用覆盖原内容的方式写入\n它相对于 fopen 再 write 再 close 来说更简洁，功能上几乎是一样的。 我们写入的文件要求内容格式大致如下：\n1 2 张三[准时] | 7:25 李四[迟到] | 7:33 这样后续我们可以通过计算“|”的数量来得出打卡人数，通过“[迟到]”的数量来得出迟到人数（当然我并不是这么办的，刚想起来这么机智的办法） 那么下面我们来写入文件：\n1 2 3 $str=$name.\u0026#34; | \u0026#34;.$_POST[\u0026#34;time\u0026#34;]; file_put_contents($filename,$str,FILE_APPEND); echo \u0026#34;打卡成功\u0026#34;; 那么PHP的全文是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php $filename=$_POST[\u0026#34;filename\u0026#34;].\u0026#34;txt\u0026#34;;//拼接文件名 $name=$_POST[\u0026#34;name\u0026#34;]; $time = str_replace(\u0026#34;:\u0026#34;,\u0026#34;\u0026#34;,$_POST[\u0026#34;time\u0026#34;]);//把时间里的“:”去除掉 if ((int)$time\u0026gt;730)//7:30之后迟到 { $name=$name.\u0026#34;[迟到]\u0026#34;; } else { $name=$name.\u0026#34;[准时]\u0026#34;; } $str=$name.\u0026#34; | \u0026#34;.$_POST[\u0026#34;time\u0026#34;].\u0026#34;\\n\u0026#34;;// \\n的目的是在文件里面换行 file_put_contents($filename,$str,FILE_APPEND) or die(\u0026#34;打卡失败\u0026#34;); echo \u0026#34;打卡成功\u0026#34;; ?\u0026gt; 让我们把前面的HTML代码保存到 index.html，上面的 php 保存到 process.php，上传到服务器试试吧！\n输入姓名提交表单：\nPOST到PHP，输出成功\n如果PHP不输出任何内容，可以考虑在第一行加入一个 echo \u0026ldquo;test\u0026rdquo;; ，如果仍然不输出任何内容，那么可能是你的代码有问题\n打卡前文件列表：\n打卡后文件列表：\nTXT内容：\n（一）完结 实在是太累了，其他功能在后续的（二）中说\n代码自己copy，成品会在（二）p.s.也没准是（三）中放出来\n如果你觉得有用或者有需要补充之处不妨评论一下\n","date":"2020-02-08T22:36:25+08:00","permalink":"https://blog.gaein.cn/passages/checker-webpage-1/","title":"PHP考勤系统源码 利用PHP实现简单的打卡考勤 超详细教程+实例+代码（一）"},{"content":"在上一篇博客中我介绍了WindowsToGo，那么如何在surface上面使用WTG呢？我重复设置了很多次也参考了网上设置surface Book的教程，终于找到了完美的解决方案。\n传送门：世界那么大，旅行时别忘了带上Windows——windows to go 入坑 https://blog.gaein.cn/passages/windows-to-go/\n进入UEFI固件设置（BIOS设置） 方法一：在关机时候进入UEFI固件设置\n关闭 Surface，然后等待大约 10 秒钟以确保其处于关闭状态。 按住 Surface 上的调高音量按钮，同时按下并释放电源按钮。 屏幕上会显示 Microsoft 或 Surface 徽标。继续按住调高音量按钮。显示 UEFI 屏幕后，释放此按钮。 方法二：通过 Windows 加载 UEFI 固件设置菜单\n选择“开始”菜单\u0026gt;“设置”\u0026gt;“更新和安全”\u0026gt;“恢复”。 在“高级启动”下，选择“立即重启”。 在“选择一个选项”下，选择“疑难解答”\u0026gt;“高级选项”\u0026gt;“UEFI固件设置”，然后选择“重启” 操作系统设置 打开“此电脑”观察系统盘图标上面是否有一个小锁的标准如果有，继续，没有则重启进入BIOS。 右键系统盘\u0026gt;“取消或关闭BitLocker” UEFI固件设置 关闭TPM\n更改启动顺序，将usb调到ssd之前 如图所示（别问我怎么拍照的，我扫描仪扫的）\n注意：我使用的是surface pro3，固件设置和后续的pro4、5、6、7图形界面有很大区别，但是选项是相通的嘛\n插入U盘，重新启动即可进入WTG系统 ","date":"2020-02-02T08:25:08+08:00","permalink":"https://blog.gaein.cn/passages/wtg-on-surface/","title":"在surface pro上使用WindowsToGo - surface pro启动win to go"},{"content":"Windows to go，说白了就是在U盘里面装Windows，随身带着Windows操作系统和软件。只要在BIOS里面设置了U盘启动就能进入U盘里面的Windows系统。\n官方说明详见 https://docs.microsoft.com/zh-cn/windows/deployment/planning/windows-to-go-overview （机翻）\n准备 如果使用Windows自带的Windows to go软件，需使用移动硬盘（插上电脑显示在设备和驱动器里，而不是可移动驱动器） 最好选购USB3.1或者USB3.0接口的移动硬盘或U盘，USB2.0由于速度瓶颈会严重影响使用体验 移动硬盘或U盘的容量在64GB及以上，32G可能无法正常运行（我选择的是256G的SSFD，读写可到2000MB/S） 电脑有键盘，用于修改BIOS Windows系统安装ISO镜像文件（我选择的是Windows10 企业版） 优缺点 优点：便携性 缺点：对U盘有一定要求，数据不是很安全，容易遭到破坏，而BitLocker又不能兼容IOS系统 软件 官方工具 萝卜头出品的WTGA 制作 基本上是下一步无脑操作，网上有很多类似帖子\n开机 开机按DEL进入主板BIOS，在BOOT中将U盘启动调到硬盘或者Windows boot manager前面，保存并退出 如果不希望更改BIOS，可以在启动列表中直接选择U盘\n","date":"2020-01-24T23:38:30+08:00","permalink":"https://blog.gaein.cn/passages/windows-togo/","title":"世界那么大，旅行时别忘了带上Windows——windows to go 入坑"},{"content":"暑假的时候做了一个高考倒计时兼目标的页面，由于高三实在是忙，一直没有时间写成博客\n网上有很多javascript实现倒计时的代码，但是我找到的都不是很好用，或者有bug，所以自己绞尽没有脑子的汁写了一个，算法智障还请多多包涵。\n[一]原理 其实原理非常简单，就是用高考开始的时间（河北省是6月7日9：00语文第一场开考）减去当前的时间（javascript函数获取的用户电脑时间），然后换算成天、时、分、秒，再舍去小数。每一秒钟调用一次自己，就实现了动态更新。\n[二]代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script language=\u0026#34;javascript\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt; function timerun(){ var now=new Date(); var end=new Date(\u0026#39;2020/06/07 09:00:00\u0026#39;); var day=Math.floor((end-now)/(24000*3600)); if(day\u0026gt;=0){ document.getElementById(\u0026#39;timeShowDay\u0026#39;).innerHTML=day; var hour=Math.floor(((end-now)-(day*24000*3600))/(1000*3600)); document.getElementById(\u0026#39;timeShowHour\u0026#39;).innerHTML=hour; var min=Math.floor(((end-now)-(day*24000*3600)-(hour*1000*3600))/(1000*60)); document.getElementById(\u0026#39;timeShowMin\u0026#39;).innerHTML=min;var sec=Math.floor(((end-now)-(day*24000*3600)-(hour*1000*3600)-(min*1000*60))/1000); document.getElementById(\u0026#39;timeShowSec\u0026#39;).innerHTML=sec; } else{ document.getElementById(\u0026#39;timeShow\u0026#39;).innerHTML=\u0026#34;高考已经开始\u0026#34;; } setTimeout(\u0026#39;timerun()\u0026#39;,1000) }; \u0026lt;/script\u0026gt; [三]效果 见 https://www.gaein.cn/live-for-dream/ 或标题图\n","date":"2019-12-01T09:54:14+08:00","permalink":"https://blog.gaein.cn/passages/javascipt-ceetime/","title":"javascript 制作高考倒计时网页"},{"content":"年前呢，在 b 站上看见有牛人拆了坏电视来做一盏效果超强、超棒的吸顶灯，而且成本也很低。看着就手痒痒。加上学长刚好有一个坏的屏幕，宿舍晚上断电需要照明，所以就干脆弄一个试试。\n制作灵感来自视频：哔哩哔哩:DIY-Perks——把坏掉的电视改造成日光灯，效果秒杀吸顶灯！\n参照这个视频来进行制作\n材料 坏的显示器面板，不显示、碎屏、花屏都可以用，而且有面板就行。可以考虑到本地垃圾场去捡一个，单买的话有点 败家。 注意：必须是 LCD 屏！\n注意：请使用其它视频源和连接线确保显示器是坏的，至少我不会希望把好的显示器拆开。 LED 灯带/灯条 注意：不是最小裁剪 1m 那种，而是裸板的 LED 灯带。这种： 12v 电源适配器，用于给 LED 灯带供电 DC 母座，方便插电用 18650 电池、电池盒 x3，用于停电时给灯供电 12v 供电切换模块，停电时切换供电 基本上的清单就是这样：\n当然还有一个显示屏\n制作 拆屏 需要的是显示屏内的背光部分，具体来说就是扩散层和一些膜（其实把显示器值钱的部分全扔了）\n拆解外壳 把显示器的外壳拆下来，一般来说背面有螺丝，侧面是卡扣的。但是因为没有找到窍门，我就暴力了一下。\n我用显卡翘的，结果都弯了\u0026hellip;\n最后暴力钻孔打穿了卡扣才卸下来。\n拆解面板 将后壳拿下来后里面大致是这样的\n将上面的胶带撕开，断开连接控制按钮的电线。\n将鼓起来那块放 PCB 的拆下，并断开电线\n这根电线粘在上面，要撕下来，这是给背光模组供电的。\n拆完后就剩下一个面板\n拆解背光 面板的四周是完全用卡扣固定的，轻轻的撬开就能将它打开。由于下面还有胶带粘住，只能先掀起来。\n黑色的是屏幕，去掉胶带后把黑色的屏幕拿下去，剩下的就是背光层。\n一层一层的把薄膜拿下来，最后一层是散光层\n侧面有一条LED灯带，作为光源。但是我这里不采用这个灯带，因为它的电压很高（我这个屏幕光源电压已经高于100V了），不是很安全。而且还要对供电进行魔改。所以我买了LED灯带。\n电路 为了实现断电时仍然能供电，我买了一些模块，用于供电。 大致就是，12v适配器用于平时供电与电池充电。断电时自动切换到电池进行供电。为了电压合适使用了3节18650电池串联。\n等待物资到货中。\n咕咕咕\n","date":"2019-07-16T08:22:58+08:00","permalink":"https://blog.gaein.cn/passages/how-to-diy-lamp/","title":"用废显示器自制充电柔和吸顶灯"},{"content":"最近闲来无事，做个mp3听歌用，准备加上锂电池充电使用，比较方便\n以前倒是做过一个，也是网上买的mp3解码板，但是供电用的是3节电池，实在是有点浪费，而且也没有喇叭。这次加入了一个3W 4Ω的扬声器，供电使用2000mah（典型值）的锂聚合物电池。\n焊接电池真的很累人，反正我是焊不好，图省心可以购买18650电池+电池盒\n[一]准备工作 首先想好需要买的东西：包括但不限于\nmp3解码板 开关（因为我家里有，就没有购买新的） 锂电池（2000mah用不太完，不用购买带保护的，因为充电模组就带保护） 锂电池充电板 电压表（用来显示剩余电量，注意购买合适电压的（锂电池3.7v-4.2v，USB5v）） 扬声器（根据板载功放的功率而定，推荐3W 4Ω） 导线、热缩管若干（导线我用的电压表上面的剪的\u0026hellip;） 电烙铁/焊台、焊锡等 拿到东西后拆开包装，检查是否齐全 画个简易的电路图，规划好怎么焊接 我的思路很简单：MP3分为3层，第一层是MP3解码器和电压表；第二层是锂电池；第三层是扬声器和充电模块。电路方面如图，先把MP3和充电模块并联起来\n充电模块有4个焊点，两个接电池正负极，另外两个接负载（MP3和电压表）正负极\n制作第一二层夹板 推荐使用快递盒子制作，或者其它质量更好的硬纸板。因为我手头没有，只能裁剪荷兰白卡，然后一张张粘了\n纸与纸之间用胶棒粘贴\n粘贴完成后形成一个厚纸板，由于MP3解码板下面焊点突起较大，在焊点处开孔\n夹板制作完成！\n标出电池正负极 为了方便制作，首先用记号笔在电池上面标出正负极 可以用万能表调到直流20V挡位测量，当然，也可以用买的电压表测量（注意是防反接的那种，反接不亮，正确接入后有读数）\n我惊喜的发现尽管我买错了表，仍然可以读数。\n[二]焊接 这是最主要的步骤了，如果不会焊接的画建议先找找东西练练手，能凑合了再焊（比如我这就是纯属凑合事(lll￢ω￢) ）\n焊接MP3与充电模块 MP3要焊接在充电模块 OUT+ OUT- 两个焊点上，注意正负极对应。充电模块在不接电池的情况下即使供电也不会给MP3供电的，上电没反应的不要慌。\n这块焊接不算困难，电路板很好焊。注意剥导线的时候尽量少弄断里面的丝，别像我一样就剩几根\u0026hellip;\n把焊锡化到烙铁上面，然后把导线插进电路板的孔里面，把烙铁上的焊锡沾到电路板上面的焊点，等到焊锡覆盖满焊点且渗到导线里面，拿开烙铁，用最吹冷却即可。推荐背面的焊点也这样弄，焊的比较牢固即可。\n焊完后可以拿万用表调到欧姆档测量电阻，如果接通电阻不会超过0.1Ω\n焊接电池与开关 我真的焊不好，这块费心费时最多，主要是电池极板面积太大，不好加热，不沾锡。电池这种东西又不能长时间受热。如果想了解怎么焊电池可以上网百度。反正我是不会\u0026hellip;\n另外开关也怕受热\u0026hellip;如果想焊好点的话推荐使用导线连接，因为开关的引脚也很大\u0026hellip;\n焊接电池与充电模块 根据电路图，电池的负极（还没焊开关那个）需要和充电模块的B- 焊点焊接。只能用导线相连。正极（有开关那个）在开关的另外一个引脚上面去连接充电模块的 B+ 焊点 焊接电压表，连接扬声器 没图\u0026hellip;\n电压表并联即可。也就是电压表正极连接充电模块的 B+ 焊点，负极连接 B- 焊点。缺点是没法看充电进度\u0026hellip;可以将导线焊接在充电模块背面，注意固定好以前焊接的MP3解码板和充电模块处，以防受热后弹出\n焊接导线与扬声器，导线另外一头可以直接用螺丝接到MP3解码板上面\n其实还是有图的，只不过surface pro3的相机\u0026hellip;不敢恭维:D\n[三]组装 其实也没啥可组装的\u0026hellip;按照之前说过的，三层\n扬声器和电压表不好固定，无奈只能使用胶带\u0026hellip; _(: 」∠)_\nP1怎么看着有点像相机？？？\n注意事项：\n不要和我一样在切割垫上焊接东西，千万不要！ 注意焊接电池时的时间不要太长，电池不耐高温 注意正负极 上电之前检查电路，以防发生危险 注意电池不要长时间满电保存 每焊接完一个模块，冷却后就要检查是否虚焊，如果没虚焊再进行下一步。 好像没了诶\u0026hellip; ","date":"2019-07-16T08:22:58+08:00","permalink":"https://blog.gaein.cn/passages/how-to-diy-mp3/","title":"自制可充电式MP3"},{"content":"早就想去写的一篇博文，因为我在部署现在这个网站的服务器时，使用了最新版的MySQL，按照网上的教程安装出现了不少问题，写在这里备忘。\n获取rpm 访问 https://www.mysql.com/downloads/ 选择Yum Repository 选择适合于自己系统的版本，比如我的是CentOS7，则选择这个，点击下载（Donwnload） 忽略下载页面的登录提示，右键\u0026quot;No thanks,just start my download.\u0026quot;，复制连接 连接到服务器，使用wget命令下载rpm 1 wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm 安装MySQL 导入rpm，使用命令： 1 sudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm 2. 完成后使用：\n1 yum install mysql-community-server 安装MySQL社区版 提示后按y开始安装，会自动下载文件，可能需要一段时间，依网速和服务器位置而定 提示\u0026quot;Is this ok\u0026quot;时再次输入y并回车，确认 设置MySQL 启动MySQL 使用 1 sudo service mysqld start 启动MySQL服务 使用\n1 sudo service mysqld status 查看状态 不能使用mysqld来启动，会启动失败 2. 连接到MySQL MySQL8不支持无密码登录，在初次安装时就自动生成了root用户的密码 使用\n1 sudo grep \u0026#39;temporary password\u0026#39; /var/log/mysqld.log 查看root用户的密码 使用\n1 mysql -u root -p 并输入默认密码（Linux系统输入密码时不会显示） 连接到MySQL服务器 修改默认密码 连接到MySQL服务器后，使用\n1 alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39;IDENTIFIED BY \u0026#39;pWD123456-\u0026#39;; 修改root的密码，其中\u0026rsquo;pWD123456-\u0026lsquo;是要修改成的新密码\n注意！MySQL8默认安装 validate_password 插件。这将要求密码包含至少一个大写字母，一个小写字母，一个数字和一个特殊字符， 并且密码总长度至少为8个字符。\n如果不符合密码规范，修改密码会失败\n1 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 修改成功会控制台输出\n1 Query OK, 0 rows affected (0.01 sec) 使用“exit”或“quit”命令退出MySQL\n","date":"2019-07-15T10:52:59+08:00","permalink":"https://blog.gaein.cn/passages/install-mysql8-on-centos7/","title":"CentOS部署MySQL8步骤"},{"content":"最近需要有网站程序连接到数据库，但网站程序放在另外一个服务器上，所以需要设置数据库的远程连接。不同于网上给root远程连接权限的方法，我准备新建一个用户。\n最近需要有网站程序连接到数据库，但网站程序放在另外一个服务器上，所以需要设置数据库的远程连接。不同于网上给root远程连接权限的方法，我准备新建一个用户。\n服务器环境： 操作系统：CentOS7 MySQL版本：8.0.16 MySQL Community Server\n########## 首先，登录服务器ssh 使用\n1 mysql -u root -p 并输入密码，进入mysql 由于我使用的是MySQL8，安全级别比以前高，不能同时创建用户并且赋值 首先创建用户\n1 create user testuser@\u0026#39;%\u0026#39; identified by \u0026#39;TestUserPWD0\u0026#39;; 再进行赋值\n1 grant all privileges on *.* to testuser@\u0026#39;%\u0026#39; with grant option; 刷新\n1 flush privileges 因为MySQL8使用的是caching_sha2_password加密规则，所以为了方便连接，需要更改一下规则\n1 ALTER USER \u0026#39;testuser\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;TestUserPWD0\u0026#39;; ########## 注意事项 testuser是你要创建的用户的用户名 TestUserPWD0是新创建的用户的密码 MySQL8默认安装 validate_password 插件。这将要求密码包含至少一个大写字母，一个小写字母，一个数字和一个特殊字符，并且密码总长度至少为8个字符。 如果无法连接，主要检查服务器防火墙或安全狗等规则限制\n","date":"2019-07-15T08:50:50+08:00","permalink":"https://blog.gaein.cn/passages/mysql8-connect/","title":"MySQL8服务器配置远程连接用户"},{"content":"来自国际纯粹与应用化学联合会和中国化学会的权威元素周期表高清下载。有最新的元素和最权威的数据\n因为刚好需要元素周期表就找了一下，网上大多数更新不及时而且样式不好看，数据不权威。终于在IUPAC官网和中国化学会找到了英文和中文（中国化学会译制的IUPAC周期表）\nIUPAC（国际纯粹与应用化学联合会）元素周期表[英文/English] International Union of Pure and Applied Chemistry (IUPAC) 国际纯粹与应用化学联合会，又译 国际理论（化学）与应用化学联合会， 是一个致力于促进化学相关的非政府组织，也是各国化学会的一个联合组织。 以公认的化学命名权威著称。 命名及符号分支委员会每年都会修改IUPAC命名法，以力求提供化合物命名的准确规则。 IUPAC 也是国际科学理事会的会员之一。\nIUPAC官网:IUPAC.org\n图片下载：[Gaein.cn | PTE-IUPAC.png | 225 KB] PDF下载：[Gaein.cn | PTE-IUPAC.pdf | 236 KB] //推荐下载PDF文件，更清晰，方便打印\nCCS（中国化学会）元素周期表[中文/Chinese] 中国化学会（Chinese Chemical Society，缩写CCS）是从事化学或与化学相关专业的科技、教育工作者自愿组成并依法注册登记的学术性、公益性法人社会团体，是中国科学技术协会的组成部分，是中国发展化学科学技术的重要社会力量。\n中国化学会于1932年在南京成立。1959年，中国化学会曾与中国化工学会筹委会合并成立中国化学化工学会。1963年，又分为化学、化工两个学会。中国化学会是国际纯粹与应用化学联合会（IUPAC）、亚洲化学学会联合会（FACS）等7个国际组织的成员。\nCCS官网：chemsoc.org.cn\n图片下载：[Gaein.cn | PTE-CCS.png | 217 KB] PDF下载：[Gaein.cn | PTE-CCS.pdf | 638 KB] //推荐下载PDF文件，更清晰，方便打印\n另外发现一个非常不错的在线元素周期表网站：periodic-table.io 这个网站有很多的优点\n元素：周期表 在一个界面中提供易于理解且有用的关于化学元素的信息。 点击一个元素符号去了解更多的关于其性质，历史，名字来源，图片，应用，危险性和电子层分布的图片。\n令人视觉愉悦的彩色表格 简单流畅的设计和丰富的信息 每个元素的详细描述 使用字母表顺序来浏览元素 每个元素的电子壳层示意图 在一个表格中比较两种元素的性质 用符号，原子序数或者名称来搜索元素 详情网站的超链接以便进一步学习 支持多国语言，建议各位使用，当然也存在部分中文元素汉字无法拼写的问题（字库没有字）\n另外 元素：周期表 开发了Windows10应用，请到 [Microsoft应用商店 元素：周期表] 下载\n有关版权的特别声明： 英文版化学元素周期表版权归国际纯粹与应用化学联合会（IUPAC）所有\n中文版化学元素周期表版权归中国化学会（CCS）所有\n元素：周期表 网站及应用程序版权归原作者所有\n本站仅撰写此文并转载元素周期表文件以及转换为PNG图片文件，未参与化学元素周期表的制作。向IUPAC及CCS和元素：周期表作者致敬\n","date":"2019-07-13T22:55:37+08:00","permalink":"https://blog.gaein.cn/passages/periodictable-of-theelements/","title":"最新官方版化学元素周期表高清大图下载"},{"content":"最近几天完善了一下网站，尤其是nginx默认的丑的要死的错误页面（标题图那样的）。今天把nginx配置错误页面的方法写在这里\n首先在网上搜教程，说必须要有 fastcgi_intercept_errors on; 自定义的错误页面才会生效，但是我删除这句话仍然可以正常跳转。大家依据实际需求添加。 接下来就是配置错误页面的具体代码了 error_page 404 /404.html; error_page 502 /502.html; location = /404.html{ root /data/errpages; } location = /502.html{ root /data/errpages; } error_page的意思是设置错误页，后面接状态码和页面文件，然后使用location来跳转。由于location的存在，这部分代码只能写在server区块里面。\n","date":"2019-06-07T18:40:33+08:00","permalink":"https://blog.gaein.cn/passages/nginx-error-page/","title":"nginX设置错误页面"},{"content":"Markdown是一种轻量级的 「标记语言」，它的优点很多，目前也被越来越多的写作爱好\u0026gt;者，撰稿者广泛使用。看到这里请不要被 「标记」、 「语言」 所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分 轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。\n根据作者\n转载请注明原作者\n转载\n作者：Te_Lee\n原文：https://www.jianshu.com/p/1e402922ee32\n如有侵权请联系删除\n转载请注明原作者，如果你觉得这篇文章对你有帮助或启发，也可以来请我喝咖啡\n导语 Markdown是一种轻量级的 「标记语言」，它的优点很多，目前也被越来越多的写作爱好\u0026gt;者，撰稿者广泛使用。看到这里请不要被 「标记」、 「语言」 所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分 轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。\nUlysses for Mac\n一，认识 Markdown 在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持 Mou 这类 Markdown 工具的直接上传。\nMarkdown 官方文档 这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。\n创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 使用 Markdown 的优点 专注你的文字内容而不是排版样式，安心写作。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。 可读、直观、学习成本低。 使用 Markdown 的误区 *We believe that writing is about content, about what you want to say – not about fancy formatting. *\n我们坚信写作写的是内容，所思所想，而不是花样格式。\n— Ulysses for Mac\nMarkdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。 [flowchart.js on Github（使用 Markdown 绘制流程图）](https://github.com/adrai/flowchart.js) 我该用什么工具？ Mou for Mac 在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题（Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 GitHub 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。 Mou 的编写与预览窗口 如果你从事文字工作，我强烈建议你购买 Ulysses for Mac，这款软件入围了苹果 Mac App Store 的 The Best of 2013。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。\nMac 上一些 Markdown 编辑器 由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 MarkdownPad ，另一款叫做 MarkPad。\niOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。\n在 Web端，我强烈推荐简书这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。\n简书的编辑预览模式 二，Markdown 语法的简要规则 标题 标题 标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 ## 号即可。\n## 一级标题\n#### 二级标题\n###### 三级标题\n以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。\n列表 熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\n无序列表与有序列表 引用 如果你需要引用一小段别处的句子，那么就要用引用的格式。\n例如这样\n只需要在文本前加入 \u0026gt; 这种尖括号（大于号）即可\n引用 图片与链接 插入链接与插入图片的语法很像，区别在一个 !号\n图片为：![]()\n链接为：[]()\n插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。\nURL 与图片 粗体与斜体 Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。\n例如：这里是粗体 这里是斜体\n表格 表格是我觉得 Markdown 比较累人的地方，例子如下：\n| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 这种语法生成的表格如下：\nTables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例：\n使用 tab 键即可缩进。\n分割线 分割线的语法只需要三个 * 号，例如：\n到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。\n三，相关推荐: 工具 图床工具用来上传图片获取 URL 地址\nDroplr Cloudapp ezShare for Mac 围脖图床修复计划 在线好用的Markdown工具，为印象笔记而生\n马克飞象，专为印象笔记打造的Markdown编辑器，非常推荐 相关文章阅读： 为什么作家应该用 Markdown 保存自己的文稿\nMarkdown写作浅谈\nMarkdown 工具补完\nDrafts + Scriptogr.am + Dropbox 打造移动端 Markdown 风格博客\n图灵社区，怎样使用Markdown\n为什么我们要学习Markdown的三个理由\nMarkdown 语法写作入门指南 by ibuick\n本文首发在少数派转载请注明原作者，如果你觉得这篇文章对你有帮助或启发，也可以来请我喝咖啡。\n利益相关：本篇文章所有涉及到的软件均为笔者日常所用工具，无任何广告费用。\n\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","date":"2019-04-28T00:23:38+08:00","permalink":"https://blog.gaein.cn/passages/hello-markdown/","title":"认识与入门MarkDown"},{"content":"网站有一段时间不能访问，原因是转备案到阿里云了。\n原因 最近网站没法访问了，原因很简单，不是服务器日常爆炸，而是拿去转备案了。 因为备案比较费事，不说材料准备，审核也要挺长时间（这次大概是15天）所以我不会轻易的转备案的。 不过最近仍然抛弃了陪伴我2年的主机屋，入了阿里云，原因很简单：\n阿里云确实在性能上比主机屋强 阿里云的学生云服务器（24岁以下）才114/年，相比较90/月的老服务器来说太值了！ 服务稳定，工作效率高 备案服务免费 功能齐全，其他各项服务也很优秀 当然，主机屋也有一定的优点，比如很少需要手机验证码（因为上学的原因，没办法接收短信，以至于在阿里云重启服务器都成了难题）\n购买前 实在是无法相信自己的眼睛，114/年，确认再三后终于入手。因为是放假前三天看见的，就提前在闲鱼买了阿里云的幕布（他自己印的，20块钱，这样比较方便）\n放假当天，先买了服务器，不过需要审核（因为限制24岁）\n流程：购买\u0026gt;审核\u0026gt;发放提货券\u0026gt;绑定账号\u0026gt;提取阿里云服务器。\n提货券有效期一个月，记得及时用啊！一开始我还以为商品有问题，那个有效期是服务器，还专门打了电话问一下。\n备案 到手后申请备案，然后打印核验单，把幕布粘墙上，架起三脚架和相机，拍照。家里有个相机是真的舒服。\n阿里云上传资料是不限制大小的，不过尽量不要上传太大的文件，容易由于网络原因出错，当然，也要保证清晰。\n第二天阿里云审核就给我来电话了，先后来了两次（清明节都不放假的？）\n第一次比较戏剧，客服跟我说我还没到年龄。我就很迷茫了，我初三就备案成功了，高二反而没到年龄？客服于是和我解释说阿里云这边要求16周岁（按照身份证上面的生日算），您还有两个个月才够岁数。蒙了一秒钟，我默默回复了一句，今年是2019年\u0026hellip;客服沉默了一下，才发现日期算错了\u0026hellip;\n第二次来电是提醒我域名快要到期，并且提醒我说如果中间到期备案是不会成功的，可见服务之细致。我还真忘了这码子事，赶紧续费一波。\n一番折腾，上传图片，终于进入到了管局审核阶段。\n部署 一狠心上了大佬们说很“优雅”的CentOS，以前都是用的Ubuntu（2021补：屑CentOS的时代过去了，Ubuntu好时代，来力！）\n一点点部署nginx，nodejs，hexo\u0026hellip;\u0026hellip;\n到现在主页也没有完成，虽然没感觉CentOS怎么好用（因为Ubuntu习惯了吧）不过确实学到了很多东西。具体部署可能会以后再发。\n","date":"2019-04-27T23:40:49+08:00","permalink":"https://blog.gaein.cn/passages/change-idc-to-alicloud/","title":"网站转战阿里云服务器"},{"content":"任何上过网的用户对浏览器是再熟悉不过了。只是用户看到仅仅只是浏览器本身，却很少能看到浏览器最核心的部分?浏览器内核。从第一款libwww（Library WorldWideWeb）浏览器发展至今已经经历了无数竞争与淘汰了。\n前言 任何上过网的用户对浏览器是再熟悉不过了。只是用户看到仅仅只是浏览器本身，却很少能看到浏览器最核心的部分—浏览器内核。从第一款libwww（Library WorldWideWeb）浏览器发展至今已经经历了无数竞争与淘汰了。现在国内常见的浏览器有：IE、Firefox、QQ浏览器、Safari、Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、遨游浏览器、世界之窗浏览器等。但目前最为主流浏览器有五大款，分别是IE、Firefox、Google Chrome、Safari、Opera。 浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。 简单介绍一下五大主流浏览器。（按时间顺序）\n主流浏览器(TOP5) 1. IE浏览器 IE是微软公司旗下浏览器，是目国内用户量最多的浏览器。IE诞生于1994年，当时微软为了对抗市场份额占据将近百分之九十的网景Netscape Navigator，于是在Windows中开发了自己的浏览器Internet Explorer，自此也引发了第一次浏览器大战。结果可想而知，微软大获全胜，网景不得不将自己卖给AOL公司。但实际上事情并没有结束，网景后来开发了风靡一时的Firefox火狐，至今Firefox也成为世界五大浏览器之一。 1996年，微软从Spyglass手里拿到Spyglass Mosaic的源代码和授权，开始开发自己的浏览器IE。后来，微软以IE和Windows捆绑的模式不断向市场扩展份额，使IE成为市场的绝对主流。现在装了Windows系统的电脑基本无法卸载IE。\n2. Opera浏览器 Opera是挪威Opera Software ASA公司旗下的浏览器。1995年，opera公司发布第一版Opera浏览器，使用自己研发的Presto内核。当时opera公司的开发团队不断完善Presto内核，使Opera浏览器一度成为顶级浏览器。直到2016年奇虎360和昆仑万维收购了Oprea浏览器，从此也丢弃了强大的Presto内核，改用当时Google开源的webkit内核。后来Opera浏览器跟随Google将浏览器内核改为Blink内核。自此Presto内核也淡出了互联网市场。\n3.Safari浏览器： 第二次浏览器大战是从苹果公司发布Safari浏览器开始的。2003年，苹果公司在苹果手机上开发Safari浏览器，利用自己得天独厚的手机市场份额使Safari浏览器迅速成为世界主流浏览器。Safari是最早使用webkit内核的浏览器也是现在苹果默认的浏览器。\n4.Firefox浏览器： Firefox浏览器使Mozilla公司旗下浏览器，也是刚才提到的网景公司后来的浏览器。网景被收购后，网景人员创办了Mozilla基金会，这是一个非盈利组织，他们在2004年推出自己的浏览器Firefox。Firefox采用Gecko作为内核。Gecko是一个开源的项目，代码完全公开，因此受到很多人的青睐。Firefox的问世加快了第二次浏览器大战的开始。第二次浏览器大战与第一次二元鼎力的局面不同，这一次的特点就是百家争鸣，也自此打破了IE浏览器从98年网景被收购后独步浏览器市场的局面。\n5.Chrome浏览器： Chrome浏览器是google旗下的浏览器。Chrome浏览器至发布以来一直讲究简洁、快速、安全，所以Chrome浏览器到现在一直受人追捧。最开始Chrome采用webkit作为浏览器内核，直到2013年，google宣布不再使用苹果的webkit内核，开始使用webkit的分支内核Blink。\n内核简介(TOP4) 以上是五大浏览器的简介，接下来是四大内核。在介绍五大浏览器的同时也已经顺便介绍了四大内核。四大内核分别是：Trident（也称IE内核）、webkit、Blink、Gecko。五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。像360浏览器、QQ浏览器都是采用双内核。 作为前端开发，熟悉四大内核是非常有必要的。四大内核的解析不同使网页渲染效果更具多样化。下面总结一下各常用浏览器所使用的内核。\n相关浏览器总结 IE浏览器内核：Trident内核，也是俗称的IE内核； Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核； Firefox浏览器内核：Gecko内核，俗称Firefox内核； Safari浏览器内核：Webkit内核； Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核； 360浏览器、猎豹浏览器内核：IE+Chrome双内核； 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、世界之窗内核：IE内核； 2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核； 写这篇文章主要是因为自己在前端开发过程常遇到浏览器兼容问题，以后有时间要对不同内核浏览器渲染效果的区别做一下总结。这是对不同浏览器和内核的总结，希望对大家有帮助。\n版权 作者：kookic 来源：CSDN 原文：https://blog.csdn.net/yuyanjing123456789/article/details/78689595 转载也是因为我遇到了兼容性方面的问题，看见这篇文章非常全面\n","date":"2019-03-16T22:33:45+08:00","permalink":"https://blog.gaein.cn/passages/introductions-of-browser/","title":"简析当前主流浏览器与内核"},{"content":"半个月前购入了一台Surface Pro 3 (i3/4G/64G)这里呢，贴一下验机步骤备用。最近两周一直在研究Surface系统（ 我在Microsoft官网下载的Surface恢复系统没有简体中文）\n前言 半个月前购入了一台Surface Pro 3 (i3/4G/64G)这里呢，贴一下验机步骤备用。最近两周一直在研究Surface系统（我在Microsoft官网下载的Surface恢复系统没有简体中文）\n外观 检查划痕，磕碰\n检查成色是否符合卖家描述\n检测背部可调节支架调节是否流畅\n屏幕 关机后检查是否有斑点\n对着灯（最好是我这样的条形LED）检查屏幕划痕\n开机后使用软件检测屏幕是否有坏点\n开机后在画图中检测触控是否完美\n使用触控笔和Surface自带的FreshPaint检测触控笔触控和压感是否正常\n真伪 目前基本没有伪造的Surface（一般人轻易搞不了）所以这里是针对更换屏幕、硬盘的\n使用软件检测配置，正品的屏幕一般是三星，硬盘是海力士 其它 在此电脑\u0026gt;属性中查看是否为Surface OEM系统\n在微软官网 https://support.microsoft.com/zh-cn/devices?brand=surface 页面注册Surface（序列号在背面，或者在“Surfcae”软件中查看）\n检查电池情况\n","date":"2019-03-16T16:34:35+08:00","permalink":"https://blog.gaein.cn/passages/sechand-surface-testing/","title":"Sueface二手电脑验机步骤 - 二手surface怎么验机"},{"content":"经常有人问怎么区分三星B-Die或者C-Die啥的，今天呢闲来无事看了一下，就写在这里啦\n版权声明：标题图引用自淘宝，内部部分图片和内容引用于网络（如ChipHell），如果侵权请联系 mail@Gaein.cn\n查询序列号 经常有人问怎么区分三星B-Die或者C-Die啥的，今天呢闲来无事看了一下，就写在这里啦\n首先要确定内存是三星的，具体可以用AIDA64软件来看，在主板\u0026gt;SPD\u0026gt;DRAM制造商一栏，比如我的是镁光公司制造的颗粒\n然后拆开内存的马甲（没有更省心啊哈哈）找到内存芯片上面的序列号\n]\n从第二行起：\n1 K4A8G085WB-BCPB 序列号含义 这是个B-Die芯片。我们来解释一下三星的序列号意义（部分内容为个人根据官网数据总结而来）：\nK4： 不同于ChipHell某个帖子的说法，我认为4并非代表DRAM产品。因为三星的LP-DDR3、LP-DDR4X产品中均出现了K3开头的型号，LP-DDR4X的中文名称是四代超低功耗双倍数据率同步动态随机存储器，双倍数据率同步动态随机存储器就是DRAM。而且在三星产品网页的网址\u0026quot;https://www.samsung.com/semiconductor/cn/dram/lpddr4x/\u0026ldquo;也能看出来其是DRAM产品，但并非K4开头。除此之外，HBM、HBM2均为KH开头。 （LP-DDR3、LP-DDR4X有K3，HBM、HBM2均为KH）\nA： 代表DDR4。（此外：F是LP-DDR4，U是LP-DDR4X，B是DDR3，Q（K3开头）或E（K4开头）是LP-DDR3，Z是G-DDR6，G是G-DDR5，A8是HBM/HBM2）\n8G： 代表容量（整个内存容量，如果是这样的话应该是1Gx8（单面条）或者512MX16（双面）或者2GX4）（除此之外，DDR4产品用AG代表6GB，LP-DDR4产品用2代表12GB、6代表16GB、H代表24GB、B代表32GB、4和8分别代表4G和8G，LP-DDR4X产品用H6代表48GB、用H7代表64GB、12GB 16GB 24FB 32GB同LP-DDR4，DDR3用1G2G4G表示容量，LP-DDR3用F3（K3开头）或者6E（K4开头）表示16GB、HE表示24GB、F4（K3开头）或者BE（K4开头）表示32GB、用FA表示64G）\nW后面的B： 代表版本：B，也就是B-Die颗粒（如果在三星官网找到那个内存颗粒的网页，然后点相关资源\u0026gt;DataSheet会发现标题写着“8Gb B-die DDR4 S-DRAM”）同样的，C就是C-Die，E是E-Die或者C-Die（对于其他产品如LP-DDR4等，并不适用）\n-BCPB 我不是特别清楚，可以参考：https://www.chiphell.com/thread-1625004-1-1.html 但是原文我感觉有误，因为B表示78 FBGA的话，为什么96也写的B？\n至于W前面的字母，应该是和架构有关\n最稳妥的知道规格的方法还是去三星官网查询：https://www.samsung.com/semiconductor/cn/dram/ddr4/\n当然，看W后面的字母就知道是否是B-Die啦\n实在不信，可以点击链接进到颗粒具体的页面，然后看看相关资源\u0026gt;DataSheet写的是什么就好啦\n那么如何根据已经知道的信息在不拆开马甲的情况下确定大概的序列号呢（这样无法判断是否为B-Die）\n首先观察单面或者双面，侧面看看颗粒数目，根据容量确定架构\n比如8G单面条，8个颗粒就是1G x 8啦，速率根据AIDA64\u0026gt;主板\u0026gt;存取速度（不带SPD的）确定。\n然后在三星官网：https://www.samsung.com/semiconductor/cn/dram/ 选择响应的产品（如DDR4）在网页下面的筛选器筛选即可。只能缩小范围，无法确定具体型号的\n","date":"2019-02-17T00:17:51+08:00","permalink":"https://blog.gaein.cn/passages/how-to-know-b-or-c-die/","title":"三星内存序列号含义——教你区分三星内存颗粒B-Die或者C-Die"},{"content":"网站从2019年2月12日早7点起宕机，到当天23:10基本恢复访问\n宕机原因 忘记续费服务器，超时一周后导致服务器被删除\n解决步骤： 上午同学发现网站无法访问联系我 更改DNS到虚拟主机，但发现虚拟主机里面的index.html已经丢失 下午到家联系IDC客服进行数据恢复 13:55购入新服务器 联系客服完成数据恢复 更改DNS回到网站服务器 晚上解决网卡设置问题（解决无法访问） 23:10恢复主页、博客、博客（旧）、文件和res资源服务器的访问 23:26恢复 SeaFile 客户端和网页版的访问 此后应牢记续费服务器事宜，及时备份服务器\n","date":"2019-02-12T23:18:56+08:00","permalink":"https://blog.gaein.cn/passages/errorlog-190212/","title":"2019年2月12日服务器宕机说明"},{"content":"编辑/etc/network/interfaces：\nvim /etc/network/interfaces\n内容如下：\n1 2 3 4 5 6 7 8 auto lo iface lo inet loopback auto eth0 iface eth0 inet static\t//指定为静态 address 43.226.***.**\t//服务器IP netmask 255.255.240.0\t//网关 gateway 43.226.156.1\t//子网掩码 不同的服务器或者不同的IDC配置文件有可能不同，请自行修改 修改完成后使用：\nsudo /etc/init.d/networking restart\n重启网络设备\n","date":"2019-02-12T21:04:35+08:00","permalink":"https://blog.gaein.cn/passages/config-ubuntueth/","title":"Ubuntu更改IP后重新配置网卡"},{"content":"前阵子为了给服务器做个启动器，需要正版登录，于是研究了一下这方面的内容\u0026hellip;结果百度上是千篇一律的： \u0026ldquo;向MOJANG服务器POST账号密码\u0026rdquo; 那么我们的当前的问题是： 1、接收账号密码的服务器地址/IP是什么 2、POST的格式 至于如何POST数据，百度一搜一把 于是我研究了一下HeyoX的代码，结果\u0026hellip;没看懂 又是一番艰苦卓绝的百度，终于发现了一些有用的东西 https://blessing.studio/minecraft-yggdrasil-api-third-party-implementation 原来MOJANG验证系统叫Yggdrasil啊\u0026hellip;或许搜这个能有所帮助 于是，发现了神级WIKI，正式我需要的！ https://wiki.vg/Authentication 这里面详细的写了包括登录、刷新、登出等 以下是翻译内容(\u0026quot;(?)是当前无法确定的翻译\u0026quot;)： 从 Minecraft 1.6 起引入了一个名为yggdrasil的新认证方案，它完全取代了以前的认证系统。Mojang的另一个游戏——Scrolls，也使用这种身份验证方法。Mojang表示，每个人都应该使用这个认证系统进行自定义登录，但是不应该从用户那里收集凭证。\n目录： 1.认证格式 2.错误 3.登录 3.1.端点 3.2.有效负载(?Payload) 3.3.响应 4.刷新 3.1.端点 3.2.有效负载(?Payload) 3.3.响应 5.生效(?Validate) 3.1.端点 3.2.有效负载(?Payload) 3.3.响应 6.登出 3.1.端点 3.2.有效负载(?Payload) 3.3.响应 7.失效 3.1.端点 3.2.有效负载(?Payload) 3.3.响应 8.加入服务器 请求格式 所有发送到ygdrasil的请求都发送到以下服务器： https://authserver.mojang.com 此外，它们还应遵守以下规则：\n是POST请求吗？ 将content-type头设置为\u0026quot;application/json\u0026quot; 包含一个JSON编码的字典作为有效负载(?Payload) 如果请求成功，服务器将响应： HTTP状态码200 在下面有一个符合规范的JSON编码字典 但是，如果请求失败，服务器将响应： 适当的非200 HTTP状态代码 遵循此格式（见下）的JSON编码字典： { \u0026ldquo;error\u0026rdquo;:\u0026ldquo;错误的简短描述\u0026rdquo;, \u0026ldquo;errormessage\u0026rdquo;:\u0026ldquo;可以向用户显示的较长描述\u0026rdquo;, \u0026ldquo;cause\u0026rdquo;:\u0026ldquo;错误原因\u0026rdquo;\t//可选 } 错误 以下是可能遇到的一些错误\n错误 原因 错误信息 笔记 Method Not Allowed 请求中的方法不允许用于请求URL的资源(?) 发送了除POST以外方法的请求 Not Found 服务器上未找到任何与URL相匹配的内容 发送到了不存在的端点 ForbiddenOperationException 用户迁移异常 无效的凭证。用户已迁移，请使用电子邮件作为用户名 ForbiddenOperationException 无效的凭证。用户名或密码错误 ForbiddenOperationException 无效的凭证 最近使用此用户名进行的登录尝试太多（详见/authenticate）。请注意，用户名和密码可能仍然有效！ ForbiddenOperationException 无效的令牌 accessToken失效 IllegalArgumentException 访问令牌已经分配了一个配置文件 选择配置文件尚未生效 IllegalArgumentException 凭证空 用户名/密码未提交 IllegalArgumentException 无效的salt版本 ？？？ Unsupported Media Type 服务器拒绝回复请求，因为请求的格式不受请求方法的支持 数据未作为\u0026quot;application/json\u0026quot;提交 登录 使用用户的密码进行登录\n端点 1 /authenticate 有效负载 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;agent\u0026#34;: { //默认是Minecraft \u0026#34;name\u0026#34;: \u0026#34;Minecraft\u0026#34;, //为了登录MOJANG的另外一款游戏Scrolls，应该使用\u0026#34;Scrolls\u0026#34; \u0026#34;version\u0026#34;: 1 //数字可能会增长 //未来的普通客户端(?by the vanilla client in the future) }, \u0026#34;username\u0026#34;: \u0026#34;MOJANG账户名\u0026#34;, //可以是电子邮件或者玩家名 //未迁移的账户（使用玩家名） \u0026#34;password\u0026#34;: \u0026#34;MOJANG账户的密码\u0026#34;, \u0026#34;clientToken\u0026#34;: \u0026#34;客户端标识符(client identifier)\u0026#34;,//可选 \u0026#34;requestUser\u0026#34;: true //可选，默认: false; 选择true将在响应中加入用户对象 } clientToken应该是随机生成的标识符，并且对于每个请求都必须是相同的。Vanilla启动程序在第一次运行时生成一个随机的（版本4）的uuid并保存它，在随后的每个请求中都重复使用它。如果它被省略，服务器将基于Java的UUID.toString()生成一个随机令牌，然后由客户端存储。但是，这也会使该用户以前获得的所有客户端访问令牌失效。\n响应 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { \u0026#34;accessToken\u0026#34;: \u0026#34;随机访问令牌（access token）\u0026#34;, // 十六进制或JSON-Web-Token (未确认) [正常的accessToken能够在payload of the JWT中找到(第二个由 \u0026#39;.\u0026#39;分割的Base64编码的 JSON object),在关键词 \u0026#34;yggt\u0026#34;中] \u0026#34;clientToken\u0026#34;: \u0026#34;客户端标识符(client identifier)\u0026#34;, // 与接收到的相同 \u0026#34;availableProfiles\u0026#34;: [ // 只有在收到agent字段时才出现 { \u0026#34;agent\u0026#34;: \u0026#34;minecraft\u0026#34;, // 大概和以前相同的值 \u0026#34;id\u0026#34;: \u0026#34;配置文件标识符\u0026#34;, // 十六进制 \u0026#34;name\u0026#34;: \u0026#34;玩家名\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;十六进制字符\u0026#34;, \u0026#34;createdAt\u0026#34;: 数值, // （账户创建时间）自1970年1月1日起毫秒 \u0026#34;legacyProfile\u0026#34;: true 或者 false, // 即使失败也存在 \u0026#34;suspended\u0026#34;: true 或者 false, // 很可能是否 \u0026#34;paid\u0026#34;: true 或者 false, // 很可能是是 \u0026#34;migrated\u0026#34;: true 或者 false, // 即使是迁移账号也是否...? (https://bugs.mojang.com/browse/WEB-1461)（作者不确定） \u0026#34;legacy\u0026#34;: true or false // 只有当为是时才会出现在应中。默认为false。对新的legacyProfile而言是多余的。。。 } ], \u0026#34;selectedProfile\u0026#34;: { // 只有在收到agent字段时才出现 \u0026#34;id\u0026#34;: \u0026#34;无短线的uuid\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;游戏名\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;十六进制字符\u0026#34;, \u0026#34;createdAt\u0026#34;: 1325376000000, \u0026#34;legacyProfile\u0026#34;: true 或者 false, \u0026#34;suspended\u0026#34;: true 或者 false, \u0026#34;paid\u0026#34;: true 或者 false, \u0026#34;migrated\u0026#34;: true 或者 false, \u0026#34;legacy\u0026#34;: true 或者 false }, \u0026#34;user\u0026#34;: { // 仅当请求负载中的requestUser为true时才存在 \u0026#34;id\u0026#34;: \u0026#34;user identifier\u0026#34;, // 十六进制 \u0026#34;email\u0026#34;: \u0026#34;user@email.example\u0026#34;, // 为迁移账户的 Hashed(?)（作者不确定） 值 \u0026#34;username\u0026#34;: \u0026#34;user@email.example\u0026#34;, // 未迁移帐户的常规名称，迁移帐户的电子邮件 \u0026#34;registerIp\u0026#34;: \u0026#34;198.51.100.*\u0026#34;, // 最后一次登录的IP地址 \u0026#34;migratedFrom\u0026#34;: \u0026#34;minecraft.net\u0026#34;, \u0026#34;migratedAt\u0026#34;: 1420070400000, \u0026#34;registeredAt\u0026#34;: 1325376000000, // 或许比配置文件创造的时间稍早一些 \u0026#34;passwordChangedAt\u0026#34;: 1569888000000, \u0026#34;dateOfBirth\u0026#34;: -2208988800000, \u0026#34;suspended\u0026#34;: false, \u0026#34;blocked\u0026#34;: false, \u0026#34;secured\u0026#34;: true, \u0026#34;migrated\u0026#34;: false, // 甚至在migratedAt和migratedFrom存在时似乎也是否... \u0026#34;emailVerified\u0026#34;: true, \u0026#34;legacyUser\u0026#34;: false, \u0026#34;verifiedByParent\u0026#34;: false, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;preferredLanguage\u0026#34;, // 或许不是所有账户都存在此项 \u0026#34;value\u0026#34;: \u0026#34;en\u0026#34; // Java locale 格式 (https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html##toString--) }, { \u0026#34;name\u0026#34;: \u0026#34;twitch_access_token\u0026#34;, // 只有连接了twitch账户时才存在 (see https://account.mojang.com/me/settings) \u0026#34;value\u0026#34;: \u0026#34;twitch oauth token\u0026#34; // OAuth 2.0 Token; alphanumerical; e.g. https://api.twitch.tv/kraken?oauth_token=[...] // Twitch API的文档: https://github.com/justintv/Twitch-API } ] } } 未完待续 Note: 如果用户希望保持登录状态，强烈建议您保存accesToken而不是密码本身。\n目前每个账户仅有一个配置文件，但是未来可能会有多个配置文件。如果用户试图登录到没有随附Minecraft许可证的有效Mojang帐户，则身份验证将成功，但响应将不包含selectedProfile字段，并且availableProfiles数组将为空。\nSome instances in the wild have been observed of Mojang returning a flat null for failed refresh attempts against legacy accounts. It\u0026rsquo;s not clear what the actual error tied to the null response is and it is extremely rare, but implementations should be wary of null output from the response.\nThis endpoint is severely rate-limited: multiple /authenticate requests for the same account in a short amount of time (think 3 requests in a few seconds), even with the correct password, will eventually lead to an Invalid credentials. response. This error clears up a few seconds later. Refresh\nRefreshes a valid accessToken. It can be used to keep a user logged in between gaming sessions and is preferred over storing the user\u0026rsquo;s password in a file (see lastlogin). Endpoint\n/refresh\nPayload\n{ \u0026ldquo;accessToken\u0026rdquo;: \u0026ldquo;valid accessToken\u0026rdquo;, \u0026ldquo;clientToken\u0026rdquo;: \u0026ldquo;client identifier\u0026rdquo;, // This needs to be identical to the one used // to obtain the accessToken in the first place \u0026ldquo;selectedProfile\u0026rdquo;: { // optional; sending it will result in an error \u0026ldquo;id\u0026rdquo;: \u0026ldquo;profile identifier\u0026rdquo;, // hexadecimal \u0026ldquo;name\u0026rdquo;: \u0026ldquo;player name\u0026rdquo; }, \u0026ldquo;requestUser\u0026rdquo;: true // optional; default: false; true adds the user object to the response }\nNote: The provided accessToken gets invalidated. Response\n{ \u0026ldquo;accessToken\u0026rdquo;: \u0026ldquo;random access token\u0026rdquo;, // hexadecimal \u0026ldquo;clientToken\u0026rdquo;: \u0026ldquo;client identifier\u0026rdquo;, // identical to the one received \u0026ldquo;selectedProfile\u0026rdquo;: { \u0026ldquo;id\u0026rdquo;: \u0026ldquo;profile identifier\u0026rdquo;, // hexadecimal \u0026ldquo;name\u0026rdquo;: \u0026ldquo;player name\u0026rdquo; }, \u0026ldquo;user\u0026rdquo;: { // only present if requestUser was true in the request payload \u0026ldquo;id\u0026rdquo;: \u0026ldquo;user identifier\u0026rdquo;, // hexadecimal \u0026ldquo;properties\u0026rdquo;: [ { \u0026ldquo;name\u0026rdquo;: \u0026ldquo;preferredLanguage\u0026rdquo;, // might not be present for all accounts \u0026ldquo;value\u0026rdquo;: \u0026ldquo;en\u0026rdquo; // Java locale format (https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html##toString\u0026ndash;) }, { \u0026ldquo;name\u0026rdquo;: \u0026ldquo;twitch_access_token\u0026rdquo;, // only present if a twitch account is associated (see https://account.mojang.com/me/settings) \u0026ldquo;value\u0026rdquo;: \u0026ldquo;twitch oauth token\u0026rdquo; // OAuth 2.0 Token; alphanumerical; e.g. https://api.twitch.tv/kraken?oauth_token=[\u0026hellip;] // the Twitch API is documented here: https://github.com/justintv/Twitch-API } ] } }\nValidate\nChecks if an accessToken is usable for authentication with a Minecraft server. The Minecraft Launcher (as of version 1.6.13) calls this endpoint on startup to verify that its saved token is still usable, and calls /refresh if this returns an error.\nNote that an accessToken may be unusable for authentication with a Minecraft server, but still be good enough for /refresh. This mainly happens when one has used another client (e.g. played Minecraft on another PC with the same account). It seems only the most recently obtained accessToken for a given account can reliably be used for authentication (the next-to-last token also seems to remain valid, but don\u0026rsquo;t rely on it).\n/validate may be called with or without a clientToken. If a clientToken is provided, it should match the one used to obtain the accessToken. The Minecraft Launcher does send a clientToken to /validate. Endpoint\n/validate\nPayload\n{ \u0026ldquo;accessToken\u0026rdquo;: \u0026ldquo;valid accessToken\u0026rdquo;, \u0026ldquo;clientToken\u0026rdquo;: \u0026ldquo;associated clientToken\u0026rdquo; // optional, see above }\nResponse\nReturns an empty payload (204 No Content) if successful, an error JSON with status 403 Forbidden otherwise. Signout\nInvalidates accessTokens using an account\u0026rsquo;s username and password. Endpoint\n/signout\nPayload\n{ \u0026ldquo;username\u0026rdquo;: \u0026ldquo;mojang account name\u0026rdquo;, \u0026ldquo;password\u0026rdquo;: \u0026ldquo;mojang account password\u0026rdquo; }\nResponse\nReturns an empty payload if successful. Invalidate\nInvalidates accessTokens using a client/access token pair. Endpoint\n/invalidate\nPayload\n{ \u0026ldquo;accessToken\u0026rdquo;: \u0026ldquo;valid accessToken\u0026rdquo;, \u0026ldquo;clientToken\u0026rdquo;: \u0026ldquo;client identifier\u0026rdquo; // This needs to be identical to the one used // to obtain the accessToken in the first place }\nResponse\nReturns an empty payload if successful. Joining a Server\nSee Protocol Encryption##Authentication\n","date":"2019-02-08T21:04:35+08:00","permalink":"https://blog.gaein.cn/passages/minecraft-login/","title":"Minecraft启动器正版登录原理"},{"content":"VMWare是世界闻名的虚拟机软件，那么如何在官网下载正版呢？\n打开VMWare官网 VMware中国\n转到下载页面 点击左侧下载\u0026gt;产品下载\u0026gt;Workstation Pro\n！注意，是“产品下载”中的Workstation Pro而不是“免费产品试用版和演示”中的\n跳转到软件下载 跳转后在页面中选择自己需要的，跳转至下载\n点击“了解更多信息” 记下“内部版本号” 拼接链接： \u0026quot;https://download3.vmware.com/software/wkst/file/VMware-workstation-full-\u0026quot;+版本（15.0.2）+\u0026quot;-\u0026quot;+内部版本号（10952284）+\u0026quot;.exe\u0026quot;\n比如我这个15.0.2,10952284的下载链接就是 https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.2-10952284.exe\n脚本 2021.5.15 补充\n前阵子无聊扒了一下VMWare的API，瞎写了一个屎山脚本，用于实验室内网资源站更新VMWare方便一些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # import requests import httpx as requests import json vmware_public_api_url = \u0026#34;https://my.vmware.com/channel/public/api/v1.0\u0026#34; def get_latest_version() -\u0026gt; str: vmware_all_url = vmware_public_api_url + \u0026#34;/products/getProductsAtoZ?locale=en_US\u0026amp;isPrivate=false\u0026#34; print(f\u0026#34;[INFO]向{vmware_all_url}发送请求，请稍后...\u0026#34;) all_file_resp = requests.get(vmware_all_url) latest_rev = \u0026#34;\u0026#34; if all_file_resp.status_code == 200: ret_json = json.loads(all_file_resp.text) products_list = ret_json[\u0026#34;productCategoryList\u0026#34;][0][\u0026#34;productList\u0026#34;] for item in products_list: if item[\u0026#34;name\u0026#34;] == \u0026#34;VMware Workstation Pro\u0026#34;: latest_rev = item[\u0026#34;actions\u0026#34;][0][\u0026#34;target\u0026#34;].split(\u0026#39;/\u0026#39;)[-1] return latest_rev def get_info_by_version(version: str) -\u0026gt; dict: vmware_list_url = vmware_public_api_url + f\u0026#34;/products/getRelatedDLGList?category=desktop_end_user_computing\u0026amp;product=vmware_workstation_pro\u0026amp;version={version}\u0026amp;dlgType=PRODUCT_BINARY\u0026#34; print(f\u0026#34;[INFO]向{vmware_list_url}发送请求，请稍后...\u0026#34;) resp = requests.get(vmware_list_url) if resp.status_code == 200: return json.loads(resp.text)[\u0026#34;dlgEditionsLists\u0026#34;][0][\u0026#34;dlgList\u0026#34;][0] else: print(f\u0026#34;ERROR:{resp.status_code} at url {vmware_list_url}\u0026#34;) def get_file_by_id(product_id: str, dl_group: str) -\u0026gt; str: vmware_file_url = vmware_public_api_url + f\u0026#34;/dlg/details?locale=en_US\u0026amp;downloadGroup={dl_group}\u0026amp;productId={product_id}\u0026#34; print(f\u0026#34;[INFO]向{vmware_file_url}发送请求，请稍后...\u0026#34;) resp = requests.get(vmware_file_url) if resp.status_code == 200: return json.loads(resp.text)[\u0026#34;downloadFiles\u0026#34;][0] if __name__ == \u0026#34;__main__\u0026#34;: latest_version = get_latest_version() if latest_version is not None: print(f\u0026#34;[INFO]获取到最新版本{latest_version}\u0026#34;) vmware_info = get_info_by_version(latest_version) if vmware_info is not None: print(f\u0026#34;[INFO]获取到：ID {vmware_info[\u0026#39;productId\u0026#39;]},名称 {vmware_info[\u0026#39;name\u0026#39;]},发布时间 {vmware_info[\u0026#39;releaseDate\u0026#39;]}\u0026#34;) file_info = get_file_by_id(vmware_info[\u0026#39;productId\u0026#39;], vmware_info[\u0026#39;code\u0026#39;]) print(f\u0026#34;[INFO]获取到：文件名 {file_info[\u0026#39;fileName\u0026#39;]},MD5{file_info[\u0026#39;md5checksum\u0026#39;]},文件大小{file_info[\u0026#39;fileSize\u0026#39;]}\u0026#34;) download_url = f\u0026#34;https://download3.vmware.com/software/wkst/file/{file_info[\u0026#39;fileName\u0026#39;]}\u0026#34; print(f\u0026#34;[INFO]拼接下载链接：\\n{download_url}\u0026#34;) 屎山（但是能跑）\n","date":"2019-01-23T14:46:35+08:00","permalink":"https://blog.gaein.cn/passages/download-workstation-pro/","title":"优雅的从 VMWare 官网上下载完整版 Workstation Pro"},{"content":"随着SSD价格的回落，越来越多的人选择入手了新的固态硬盘。考虑到老的东芝 A100 实在是有些慢了，于是权衡了影驰和阿斯加特后入手了阿斯加特 AN2 SSD(250G)。这款硬盘采用石墨烯散热，薄薄的一层黑色片代替以前厚重的金属散热。速度也很可观，于是便从某宝入手了。\n目前在阿斯加特官网上面只有 AN 系列和雷赤系列，没有找到新的 AN2。\n包装 阿斯加特 AN2 的盒子以黑色为主色调，辅之以红色，非常帅气。正面写有白字的 Asgord AN series M.2 NVMe SSD，侧面有 Asgord 标识。\n背面则是介绍和基本的一些信息（比如容量等）\n内部 拆开包装后，里面就是主角啦！\n另外还有说明书、螺丝以及螺丝刀\n全家福qwq\n说明书里面内容比较详细，带图片说明了安装方法等\n硬盘 再来仔细的端详一下硬盘\n硬盘表面是磨砂质感的黑色散热，上面有红色的 Asgord LOGO\n背面和外包装大致相同，写了一些基本的信息和防伪查询码\n这张图可以看出散热非常的薄，侧面几乎看不出\n测试 是骡子是马应该拉出来溜溜才对\n官方宣传的速度是：\nREAD:2100MB/S WRITE:1800MB/S 因为主板没有 M.2 接口，只能用 PCI- E转接卡，没有 nvme 协议肯定会有所损失，另外主板的接口还是 PCIE2.0\nPCIE-M.2 是某宝花了几十买的，据说浦科特的那个非常好，只不过转接卡快赶上我固态的价格了\u0026hellip;\n仔细看看做工还算可以，一开始这个 SATA 吓我一大跳，仔细一看，一个是基于 SATA 的，另一个是 PCIE 的\n非常轻松的按照说明书按照 SSD，第一次装 M.2 的固态，感觉有点像笔记本内存的装法？？？\n安装完成\n安装到电脑的 PCIE 插槽上面，至少需要 PCIE X4 才能发挥出来它的性能，还好 ROG 有四个槽，我插在了 PCIE X8/X16 上面，应该是没有问题的了\n随便用了两个比较常见的软件进行测试，结果总结如下，可见比较 SATA SSD 来说， M.2 的优势是显而易见的。不过并没有达到官方宣传速度。\n测试平台：\nCPU: AMD FX8300 Mother Board: ASUS Republic Of Gamers Crosshair V Formula Graphics Card: DATALAND RX 460 X-serial 4G OS: Windows 10 x64 ","date":"2018-12-07T21:34:35+08:00","permalink":"https://blog.gaein.cn/passages/asgord-m2-an2-ssd/","title":"值得一试：阿斯加特 AN2 石墨烯黑科技固态开箱评测"},{"content":"前言 最近入手了阿斯加特的AN2系列的NVMe SSD，苦于主板不支持NVMe协议，没法用作系统盘。百度无果之后就尝试着自己MOD一个BIOS了 首先在华硕官网找到C5F的BIOS，另外拿了一个970PRO的BIOS（华硕支持NVMe的AM3+主板好像只有970）大上周用了C6H的BIOS好像刷坏了，还专门买了个编程器\n网上的模块我不知道为什么没法用（大概是因为他们都是Intel板子的吧\u0026lt;瞎扯淡）于是只好自己从其他支持NVMe板子中提取\n实践 工具准备 文件 首先把C5F的BIOS复制到UBU的目录下，然后运行UBU.BAT，升级一些东西，为NVMe模块挪出地方\n升级模块 按照提示升级，需要一些英文基础，注意网卡那边的升级不要选错版本！ 完成后输入0退出，再输入0保存为BIOS.BIN\n提取模块 使用MMTool打开970的BIOS文件\n注意，需要使用MMTool 4打开，MMTool5会出错。\nMMTool在Windows10下会显示不全，所以我开了个Windows7的虚拟机来操作\n成功读取BIOS，找到NVMe相关的模块（NVMe、NVMeSmm、NVMeINT13）\n选中“NVMe” Extract菜单，点击Extract，提取。文件名为“模块.ffs”\n其他两个也如法炮制\n再打开C5F的BIOS，找到CSMCORE，插入这三个模块，注意勾选“Insert Compress”\n插入完成后应该在CSMCORE同卷（01）的最后\n保存文件\n4194304字节大概是3.99MB，BIOS能够盛下\n使用AFU刷入BIOS，点击OPEN打开，FLASH写入，期间会有弹窗提示，注意关闭其他软件。\n刷BIOS有风险，请做好准备，手里有BIOS烧录器的最好。\n虽然这样下来主板里面仍然没有我的SSD，但是试了一下总算可以正常使用系统了，算是勉强解决，后续再研究。\n参考 【2017整理】如何在使用AMI UEFI BIOS的老平台上加入NVMe支持 主板没法从NVMe启动咋办？硬改BIOS！ 老夫卿发少年狂——老主板升级PCI-E NVMe SSD攻略 ","date":"2018-12-05T16:01:40+08:00","permalink":"https://blog.gaein.cn/passages/cvf-nvme-bios/","title":"华硕 C5F 改 BIOS 支持 NVMe SSD 启动"},{"content":"最近社里面交图片，要求格式为 姓名-编号 作为一个懒癌晚期患者，我默默打开了visual studio 下面是代码，原理是获取文件名，保存到数组中，再循环重命名到最后一个\n最近社里面交图片，要求格式为 姓名-编号 作为一个懒癌晚期患者，我默默打开了visual studio 下面是代码，原理是获取文件名，保存到数组中，再循环重命名到最后一个\n2021年2月补充 （我2年前写的什么玩意是）重命名采用MoveTo方法就行了，因为我联想到Linux下重命名也是mv\u0026hellip;\n重命名采用的方法是引用VB.NET里面的重命名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Forms; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Imaging; using System.Windows.Navigation; using System.Windows.Shapes; using Microsoft.VisualBasic.Devices; namespace Rename { /// \u0026lt;summary\u0026gt; /// MainWindow.xaml 的交互逻辑 /// \u0026lt;/summary\u0026gt; public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); Output.Text = \u0026#34;窗口初始化完成\u0026#34;; } private void P_Click(object sender, RoutedEventArgs e) { Output.Text = \u0026#34;初始化..\u0026#34;; string path = Bin.Text; string[] files=new string[10000]; string name = Name.Text; int i = 0; Output.Text = \u0026#34;初始化变量成功\u0026#34;; DirectoryInfo folder = new DirectoryInfo(@path); while (i \u0026lt; folder.GetFiles(\u0026#34;*.jpg\u0026#34;).Count()) { files[i] = folder.GetFiles(\u0026#34;*.jpg\u0026#34;)[i].Name; i++; } Output.Text = \u0026#34;文件获取成功，共\u0026#34;+i+\u0026#34;个\u0026#34;; int s = 0; while (s \u0026lt;i) { Computer MyComputer = new Computer(); MyComputer.FileSystem.RenameFile(path+@\u0026#34;\\\u0026#34;+files[s],name+\u0026#34;-\u0026#34;+ Convert.ToString(s+1)+ \u0026#34;.jpg\u0026#34;); Output.Text = \u0026#34;正在转换，\u0026#34; + s+\u0026#34;/\u0026#34;+i + \u0026#34;个\u0026#34;; s++; } Output.Text = \u0026#34;转换完成！\u0026#34;; } private void Where_Click(object sender, RoutedEventArgs e) { Output.Text = \u0026#34;正在浏览文件夹\u0026#34;; try { FolderBrowserDialog dialog = new FolderBrowserDialog(); dialog.Description = \u0026#34;请选择文件路径\u0026#34;; System.Windows.Forms.DialogResult result = dialog.ShowDialog(); if (result == System.Windows.Forms.DialogResult.Cancel) { return; } string folderPath = dialog.SelectedPath.Trim(); DirectoryInfo theFolder = new DirectoryInfo(folderPath); if (theFolder.Exists) { Bin.Text = folderPath; return; } } finally { } Output.Text = \u0026#34;完成\u0026#34;; } } } ","date":"2018-11-04T14:11:09+08:00","permalink":"https://blog.gaein.cn/passages/renamer-files/","title":"CSharp批量重命名图片为指定格式"},{"content":"最近给Ubuntu添加了一块硬盘，下面是具体的步骤\n买的云服务器IDC给了一块10GB的数据盘，因为系统盘不大，就要把数据盘用上了 但是Linux下数据盘并没有挂载，Linux的磁盘系统也不同于windows，需要挂载使用 1、新建分区并格式化 使用 fdisk -l 查看当前的硬盘，可以看到有sda、sdb两块盘，第一块作为系统盘已经分区，sdb就是我们要挂载的数据盘 首先进行分区 fdisk /dev/sdb 进入磁盘sdb（如果你是磁盘sdc就相应的替换为sdc）相当于选中这个硬盘的意思 首先输入m看一下帮助 比较简单，应该很容易看懂，暂时把几个常用的写上了意思 Command (m for help): p ##显示磁盘信息 Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disklabel type: dos Disk identifier: 0xb5106536 Command (m for help): n ##新建分区 Partition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions) Select (default p): p ##新建逻辑分区 Partition number (1-4, default 1): First sector (2048-20971519, default 2048): Last sector, +sectors or +size{K,M,G,T,P} (2048-20971519, default 20971519): ##直接留空，我只想把所有的空间分一个分区 Created a new partition 1 of type \u0026amp;##39;Linux\u0026amp;##39; and of size 10 GiB.\nCommand (m for help): w ##保存退出 The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks.\n再次使用fdisk -l已经可以看到sdb有一个分区sdb1了 同Windows一样，磁盘需要格式化后才能使用 用 mkntfs /dev/sdb1 来格式化为NTFS格式，其他格式可以自行百度 出现 Cluster size has been automatically set to 4096 bytes. Initializing device with zeroes: 100% - Done. Creating NTFS volume structures. mkntfs completed successfully. Have a nice day. 即为格式化完成 2、挂载磁盘 临时挂载可以使用mount命令，但是重启后需要重新挂载 用法为 mount 分区 目录 比如我需要使用 mount /dev/sdb1 /data 挂载 （当然前提是存在目录/data） 编辑 /etc/fstab 来永久挂载磁盘 ## /etc/fstab: static file system information. ## ## Use \u0026##39;blkid\u0026##39; to print the universally unique identifier for a ## device; this may be used with UUID= as a more robust way to name devices ## that works even if disks are added and removed. See fstab(5). ## ## \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; ## / was on /dev/sda1 during installation UUID=22e202f3-ae04-4995-b214-de7f192f33c4 / ext4 errors=remount-ro 0 1 ## swap was on /dev/sda5 during installation UUID=472580b3-a87b-4fe2-8bda-59b59d087ec6 none swap sw 0 0 /dev/fd0 /media/floppy0 auto rw,user,noauto,exec,utf8 0 0 /dev/sdb1 /data ntfs defaults 0 0 磁盘 挂载目录 磁盘格式 需要注意的是，中间的空不需要打空格，用TAB制表符更方便 root@rootadmin:/data## mkdir blog root@rootadmin:/data## dir blog root@rootadmin:/data## reboot Connection closing...Socket close. Connection closed by foreign host.\nDisconnected from remote host(GAEIN.CN) at 12:21:20.\nType `help\u0026amp;##39; to learn how to use Xshell prompt. [C:~]$\nConnecting to ...:22\u0026hellip;\nConnection established. To escape to local shell, press \u0026amp;##39;Ctrl+Alt+]\u0026amp;##39;.\nWelcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-38-generic x86_64)\nDocumentation: https://help.ubuntu.com Management: https://landscape.canonical.com Support: https://ubuntu.com/advantage System information as of Sat Oct 20 12:21:29 CST 2018\nSystem load: 0.49 Processes: 89 Usage of /: 24.9% of 12.67GB Users logged in: 0 Memory usage: 7% IP address for eth0: ... Swap usage: 0%\nCanonical Livepatch is available for installation. Reduce system reboots and improve kernel security. Activate at: https://ubuntu.com/livepatch 0 个可升级软件包。 0 个安全更新。\nFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings\nLast login: Sat Oct 20 11:26:33 2018 from ... rootadmin@rootadmin:~$ cd /data rootadmin@rootadmin:/data$ dir blog rootadmin@rootadmin:/data$\n重启了一下，挂载确实成功了 ","date":"2018-10-20T12:07:15+08:00","permalink":"https://blog.gaein.cn/passages/linux-add-newdisk/","title":"Linux挂载新硬盘"},{"content":" 注意：本博客过于久远，内容可能已经不适用\n注意：正确的更改DNS的方法见博客：常见公共DNS服务\u0026amp;Linux和Windows下修改DNS的方法\nDNS莫名其妙出错，啥也干不了\n百度了一波，发现解决方案很简单，就是手动加入DNS\n1 sudo vim /etc/resolv.conf 加入DNS\n1 nameserver 119.29.29.29 当然可以自己去百度其他家的DNS，我这是DNS PUBLIC+的地址\n按照百度说的我保存重启\n结果发现并没有什么卵用\u0026hellip;\n仔细观摩一下文件\n1 2 3 4 5 6 # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8) # DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN # 127.0.0.53 is the systemd-resolved stub resolver. # run \u0026#34;systemd-resolve --status\u0026#34; to see details about the actual nameservers. nameserver 127.0.0.53\u0026lt;/pre\u0026gt; 被覆盖了\n而且说明也写着“DO NOT EDIT THIS FILE BY HAND”\n我按照其他的方法修改了一下编辑resolv.conf.d目录下的base文件\n不过也没有效果\n但是按照第二篇看的文章找到了问题所在：\n重启系统后DNS设置不但不会被应用还会被覆盖，应该重启网卡来解决\n1 sudo /etc/init.d/networking restart\u0026lt;/pre\u0026gt; 完美解决\n参考：\nubuntu apt-get 异常 Temporary failure resolving \u0026lsquo;us.archive.ubuntu.com\u0026rsquo; 解决 - 人工智能 ubuntu16.04 出现域名解析暂时失败 解决方法_tsq292978891的博客-CSDN博客_域名解析暂时失败 ubuntu域名解析失败解决方案_廿四桥明月夜的博客-CSDN博客_ubuntu域名解析失败 不过刚刚重启了好像又被覆盖了，很是绝望\n干脆写了个脚本，然后开机自动运行脚本得了\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash ### BEGIN INIT INFO # Provides: run.sh # Required-start: $local_fs $remote_fs $network $syslog # Required-Stop: $local_fs $remote_fs $network $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: starts the run.shh daemon # Description: starts run.sh using start-stop-daemon ### END INIT INFO sudo echo \u0026#34;nameserver 119.29.29.29\u0026#34; \u0026gt;\u0026gt; /etc/resolv.conf sudo /etc/init.d/networking restart 然后复制到init.d中，再\n1 update-rc.d run.sh defaults 99 ","date":"2018-10-20T11:42:39+08:00","permalink":"https://blog.gaein.cn/passages/fix-ubuntu-dns-error/","title":"Ubuntu下apt“无法解析域名”解决方案"},{"content":"由于本人英文渣，加之一个服务器终端是中文一个服务器终端是英文（当然两个服务器都穷的续不起了）\n所以今天更改Ubuntu的语言为中文\n因为是服务器所以只能通过终端更改\n首先安装下语言包\n1 sudo apt search language-pack-zh-hans 我先使用apt搜索了一下语言包\n使用命令安装他们\n1 2 sudo apt install language-pack-zh-hans sudo apt install language-pack-zh-hans-base 安装下对于程序的语言支持\n1 sudo apt install `check-language-support -l zh` 将语言设置为中文\n1 sudo localectl set-locale.UTF-8 重启系统\n1 sudo reboot 随便输入个什么命令，比如 date\n显示为中文，修改成功\n如果没有修改成功的话，使用文本编辑器编辑文件\n1 sudo vim /etc/default/locale 将 LANG LANGUAGE等 后面换成\n1 zh_CN.UTF-8 重启系统后就是中文了\n参考：\nubuntu如何在终端下更改系统语言 - Linux大神博客 Ubuntu 14.04 英文SSH终端更改为中文显示_雅礼·实验-CSDN博客 ","date":"2018-08-17T09:36:49+08:00","permalink":"https://blog.gaein.cn/passages/change-ubuntu-to-chinese/","title":"Ubuntu终端更改为中文"},{"content":"nodeBB在默认的4567开启，通常需要nginx作为反代理才能更好的访问，并且nginx也能开启一些优化使访问更快速\n默认安装nginx的配置文件在 /etc/nginx/nginx.conf 使用\nvim /etc/nginx/nginx.conf\n编辑配置文件，在http{}之间，追加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 80; server_name www.xxx.com; ## 你的域名 location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:4567; proxy_redirect off; ## Socket.IO Support proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; } } 因为我网站跑的服务器在香港，配置又不行，所以只能想办法来优化一下\n先上整个的配置文件，因为用了宝塔面板（SSL实在弄不好）所以配置文件可能与其他的有出入，请自行修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 server { ##基础设置 listen 80; listen 443 ssl; server_name www.minecrafter.cn; ##错误页面 error_page 502 /502.html; location = /502.html { root /502; internal; } ##反代理设置 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; ##proxy_pass http://127.0.0.1:4567; ##proxy_pass http://io_nodes; proxy_redirect off; ## Socket.IO Support proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; ##gizip设置 gzip on; gzip_min_length 1000; gzip_proxied off; gzip_types text/plain application/xml text/javascript application/javascript application/x-javascript text/css application/json; ##SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则 ##error_page 404/404.html; ##HTTP_TO_HTTPS_START if ($server_port !~ 443) { rewrite ^(/.*)$ https://$host$1 permanent; } ##HTTP_TO_HTTPS_END ssl_certificate /etc/letsencrypt/live/www.minecrafter.cn/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/www.minecrafter.cn/privkey.pem; ssl_protocols TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; error_page 497 https://$host$request_uri; ##SSL-END ##静态资源代理设置 location @nodebb { proxy_pass http://io_nodes; } location ~ ^/assets/(.*) { root /data/nodebb/; try_files /build/public/$1 /public/$1 @nodebb; } location /plugins/ { root /data/nodebb/build/public/; try_files $uri @nodebb; } location / { proxy_pass http://io_nodes; } } ##负载均衡设置 upstream io_nodes { ip_hash; server 127.0.0.1:526; server 127.0.0.1:527; } 这是最终版本，有负载均衡，资源代理，压缩\n不需要压缩删除 ##gzip设置的内容即可\n不需要负载均衡（仅一个端口）删除 ##负载均衡的内容，将 ##静态资源代理设置的内容中\n1 proxy_pass http://io_nodes; 改成\n1 proxy_pass ##端口依情况而定 不需要静态资源代理删除 ##静态资源代理内容，如果有负载均衡，删除\n1 ##proxy_pass http://io_nodes; 前的“##”\n没有则删除\n1 proxy_pass http://127.0.0.1:4567; ##端口依情况而定 前的“##”\n除了nginx之外要做的\n集群使用：\n默认情况下，NodeBB将在一个进程上运行，某些调用可能比其他进程更长，从而导致相同资源的延迟或队列等待。要解决这个问题，可以通过添加多个端口到config.json中来指示NodeBB在多个进程上运行。\n我习惯把端口数目设置为核心数，首先使用\n1 cat /proc/cpuinfo| grep \u0026#34;cpu cores\u0026#34;| uniq 查看核心数目（我的四核）\n在nodebb目录下（就是输./nodebb setup那个目录），使用\n1 vim config.json 编辑配置文件\n将与端口有关的port:4567,改成\n1 2 3 { \u0026#34;port\u0026#34;: [\u0026#34;4567\u0026#34;, \u0026#34;4568\u0026#34;] //这将启动2个进程，分别监听这2个端口 } 具体为什么可以百度JSON格式，如果重启nodebb出错请检查这个文件，端口随便写，不要占用80(HTTP),22(SSH),443(SSL),6379(Redis),27017(MongoDB)等\n在Nginx配置文件中加入\n1 2 3 4 5 6 upstream io_nodes { ip_hash; server 127.0.0.1:4567; server 127.0.0.1:4568; } 端口依config内容而定\n然后把以前配置文件中的\nproxy_pass 一行\n改成\n1 proxy_pass http://io_nodes; 即可\n","date":"2018-07-25T21:16:00+08:00","permalink":"https://blog.gaein.cn/passages/configure-nginx-for-nodebb/","title":"NodeBB设置——使用NginX进行反代理并优化"},{"content":"因为没有在面板中开启端口，碰壁过好几次 回来想想哭笑不得，但是这样的例子还不止我一个 所以提示大家，记得在 1. 服务器系统防火墙 2. 服务器系统安全狗 3. 服务器自己安装的面板 4. 服务商提供的管理面板 5. 服务商提供的安全策略组 中开启相应端口 NodeBB需要端口 80，http 4567，默认端口（记得添加你在config.json中定义的） 6379，redis 27017，mongodb 443，SSL 按需添加 \u0026lt;img src=\u0026quot;https://s1.ax1x.com/2018/07/25/PYOYhn.jpg\u0026quot; alt=\u0026quot;\u0026quot; data-load=\u0026quot;full\u0026quot; style=\u0026quot;\u0026quot; width=\u0026quot;1697\u0026quot; height=\u0026quot;548\u0026quot;/\u0026gt; ","date":"2018-07-25T01:27:20+08:00","permalink":"https://blog.gaein.cn/passages/tips-for-nodebb/","title":"NodeBB小贴士——也是所有云服务器的小贴士：记得在相关软件中开启端口"},{"content":" CentOS在各种服务器上使用的较多，所以捏，就来尝试一下CnetOS上安装NodeBB CentOS 7 on VMWare 不过我这次选择的数据库是MongoDB 一、准备工作 打开终端，切换到root用户 su root 关闭SELinux（有些可能没有，跳过） vim /etc/sysconfig/selinux 如果没有vim（见https://blog-old.gaein.cn/post/Nodebb-Linux-Ubuntu.html 就用yum安装呗 yum install vim ##如果 vim 指令未安装，那就安装它 按下i键（当然如果你想知道有什么键可以自行百度） 找到 SELINUX 然后修改成 disabled. 按下ESC退出编辑模式，输入:，再输入退出并保存命令：wq yum update yum -y install epel-release yum -y groupinstall \u0026quot;Development Tools\u0026quot; yum -y install git ImageMagick ImageMagick-devel##更新系统并安装一些基础工具 二、安装NodeJS 在Github可以找到最新的nvm安装命令 https://github.com/creationix/nvm 所以我们使用 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash ##或者 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装nvm（这是一个快速部署的脚本） 使用 export NVM_DIR=\u0026quot;$HOME/.nvm\u0026quot; [ -s \u0026quot;$NVM_DIR/nvm.sh\u0026quot; ] \u0026amp;\u0026amp; . \u0026quot;$NVM_DIR/nvm.sh\u0026quot; ## This loads nvm 把nvm添加到环境变量 使用 source ~/.bashrc 令环境变量生效 最后使用 command -v nvm 检查是否安装成功 安装成功之后，如果是国内的机器需要使用 export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node export NVM_IOJS_ORG_MIRROR=http://npm.taobao.org/mirrors/iojs 让nvm使用淘宝源 npm config set registry http://registry.npm.taobao.org/ 让npm使用淘宝源 使用 nvm install --lts 安装lts版本的nodejs 之后记得使用 npm -v 和 nodeb -v 检查版本，如果成功输出版本号，则安装成功 三，安装数据库（MongoDB） 使用命令 vim /etc/yum.repos.d/mongodb-org-3.6.repo 创建文件并且输入i进行编辑，将以下内容粘贴进去 [mongodb-org-3.6]name=MongoDB Repositorybaseurl= gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc 输入:wq保存并退出 再使用 yum updata 更新 使用 yum -y install mongodb-org 安装mongoDB 因为是国外的服务器所以速度不行，当然也可以自行在使用update之前把链接替换为国内的镜像站 完成之后使用 service mongod start ##启动 Mongodb mongod --version ##查看 Mongodb 版本 有一点需要注意：如果版本3.4.10的话需要升级，因为3.4.10以下有风险 安装完成后，为了消除 MongoDB 的性能警告，需要关闭 Linux 巨型页： 使用 echo never \u0026gt; /sys/kernel/mm/transparent_hugepage/enabled echo never \u0026gt; /sys/kernel/mm/transparent_hugepage/defrag 来关闭 不同于官方文档，在获取nodebb之前，我选择先进行数据库设置 输入 mongo 进入mongoDB的命令行 使用 use nodebb 新建数据库（名为nodebb） 使用 db.createUser({user: \u0026quot;nodebb\u0026quot; ,pwd: \u0026quot;替换成你的密码\u0026quot; ,roles:[ \u0026quot;readWrite\u0026quot; ]}) 添加用户角色（牢记用户名（此处为nodebb）和密码！） 如果需要在nodebb后台查看数据库数据，输入以下代码 db.grantRolesToUser( \u0026quot;nodebb\u0026quot; ,[{ role: \u0026quot;clusterMonitor\u0026quot;, db: \u0026quot;admin\u0026quot; }]); 打开权限认证，使用命令 vim /etc/mongod.conf 取消注释并改为 security: authorization: enabled 如图所示 使用 service mongod restart 重启mongoDB 四、安装NodeBB 如果没有git，请使用 yum install git 中文社区的文档中已经说明 在开始之前:① 提前切换成root用户，免得麻烦。② 不要直接下载 Github 上发布的 release 压缩包，那里面没有 .git/config 配置文件，而在安装过程中需要读取配置文件的值。正确的做法是使用 Git 从 GitHub 上克隆源代码。 新建一个目录（如果是云服务器的话最好放在数据盘里面，默认的/root目录不会太大，不过因为我比较懒就直接这样了） 可以使用 mkdir 目录 来新建文件夹（注意有\u0026##39;/\u0026##39;和没有的区别） 使用 cd 目录 进入刚刚新建的目录（同样注意\u0026##39;/\u0026##39;） 使用 git clone -b v1.10.x https://github.com/NodeBB/NodeBB.git nodebb##把nodebb克隆进nodebb文件夹 现在，你可以使用国内的镜像仓库(https://gitee.com/NodeBB-CN/NodeBB.git)来提高连接速度。 这是中文社区文档上的话，但是... （这个是当时没有截图后来用物理机补的:D） 嗯... 所以我闲的创建了一个仓库，可以使用 https://gitee.com/nidb/NodeBB.git 使用 ./nodebb setup 来安装，当然，上一篇（在Ubuntu上搭建现代化的论坛Nodebb|NodeBB安装记录（Linux-Ubuntu篇））中说过，可以使用可视化的界面来安装，使用 ./nodebb install 和普通的博客安装差不多啦！ 说明： Web Address(URL)是以后访问的地址，如果是搭建的论坛记得写域名（可以不加端口，以后在nginx反代理）当然，建议先使用默认的调试。注意不要忘记“http://”，结尾不要加\u0026##39;/\u0026##39;，只有这个链接能够访问论坛，其他链接访问会显示链接断开（比如我有一个服务器，IP是1.2.3.4，域名www.exp.com和exp.com都A记录过去了，这里我填写www.exp.com，那么exp.com和1.2.3.4访问的时候都会显示与“NodeBB的链接断开”） Username，Email Address ，Password是论坛管理员的账号邮箱密码，牢记。邮箱要填写可以用的，以便以后开邮件验证功能的时候不用再去修改 Confirm Password是确认密码 数据库选择MongoDB Redis的话自己去网上看资料吧23333 中文社区的文档都很详细的，这个是CentOS+Redis的链接：https://www.kancloud.cn/a632079/nodebb-cn/372107\u0026nbsp; ，至于Ubuntu，看我以前的博文 Host IP or address of your MongoDB instance是数据库的地址，如果使用的是本机，默认即可 Host port of your MongoDB instance是数据库端口，如果没有改过，默认即可 MongoDB username是用户名，Password of your MongoDB database是密码，前面设置过的 MongoDB database name是数据库名，前面use nodebb创建的 点击Install NodeBB安装 终端已经有反应了 然后开始部署 这可能需要几分钟，部署完成后提示你使用 ./nodebb start 开启nodebb NodeBB已经成功运行，并且提示你三个常用的命令：分别是停止、日志（实时）、和重启 打开http://127.0.0.1:4567 已经可以正常访问！ ","date":"2018-07-21T19:20:03+08:00","permalink":"https://blog.gaein.cn/passages/install-nodebb-on-centos/","title":"在CentOS上搭建现代化的论坛Nodebb|NodeBB安装记录（Linux-CentOS篇）"},{"content":" 继上次\u0026nbsp;https://blog-old.gaein.cn/post/nodeBB-windows-4.html\u0026nbsp;失败后，我仍然不思悔改，NodeBB就是好看！在老家闲来无事的时候租用了一个服务器，于是，故事开始了 NodeBB是基于nodejs的现代化论坛程序 系统我选择了Ubuntu，再多次干到凌晨四五点后，终于让网站成功运行了！ 因为服务器是使用SSH链接的，所以即使有桌面，我也选择用终端（在安装NodeBB这方面桌面好像没用...） 相关安装文档查看： https://www.kancloud.cn/a632079/nodebb-cn/ 前奏 第一步我选择切换到管理员账户（root） 貌似没有vim（一个强大的文本编辑软件） 使用 apt-get install vim 按y同意安装 这网速真是伤感 如果安装失败了，尝试用 apt-get update 更新，然后再尝试 在执行第一条命令（快速安装nodejs用）的时候，又报错了 这系统真是纯洁，啥都没有... 使用 apt install curl 安装curl 安装Node.js LTS 使用 curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - 来快速安装Node.js 如果服务器在大陆的话 vim /etc/apt/sources.list.d/nodesource.list 将链接全部换成 https://mirrors.ustc.edu.cn/nodesource/deb/node_{版本号，例如: 8}.x 按“i”进入编辑模式，完成后按ESC退出编辑模式，再输入:wq 保存退出 再次更新APT源 sudo apt-get update 然后通过APT安装Node.js sudo apt-get install -y nodejs 使用 node -v 检查版本，确实已经安装完成 数据库：Redis 鉴于Redis体积较小等优点，数据库我选择了redis sudo add-apt-repository ppa:chris-lea/redis-server sudo apt-get update sudo apt-get install -y redis-server ##安装redis 使用这三行来安装redis（当然是从上到下一行一行来） 按回车键继续 最后一步，慢慢等待 Redis安全设置（强烈推荐进行这一步） 使用 vim /etc/redis/redis.conf 编辑配置文件 按“i”进入编辑模式，在前面插入如下三行 requirepass yourpassword bind 127.0.0.1 rename-command FLUSHALL \u0026quot;\u0026quot; 其中，“yourpassword”是你自己设置的密码，记住它，后面要用到的 我设置为2018password 按ESC再输入:wq保存 使用： service redis-server restart 重启redis 如果没有任何报错信息就是没问题了，否则检查你的配置文件 NodeBB的安装 一切无误，进入最后步骤了（这当然不是全部的全部） 如果没有git，使用： sudo apt-get install -y git build-essential 安装它 不知道有没有，使用 git 如果返回了一大串东西则是安装了，返回“Command \u0026##39;git\u0026##39; not found, but can be installed with:......”则是没有安装 安装完毕后进入一个你喜欢的目录 在新版本的Ubuntu，你需要先 mkdir /www ##你喜欢的名字，带不带/有很大区别的 然后再 cd /www 使用命令，从git克隆nodebb sudo git clone -b v1.9.x https://github.com/NodeBB/NodeBB.git nodebb ##这将在 /home 下面 新建一个名叫nodebb的文件夹并且会把程序从Github克隆到里面 在大陆，尤其是网络环境不好的情况下，这个过程可能会非常漫长（解决方案见https://blog-old.gaein.cn/post/NodeBB-Linux-CentOS.html） 目前NodeBB已经更新v1.10.x，请将“v1.9.x”替换成“v1.10.x”在发送命令，以获取最新版 在50kib/s的速度下，需要将近16分钟！ 妈呀，终于完成了，合个影 输入： cd nodebb 进入目录 使用： ./nodebb setup ##尽管我使用的是./nodebb start \u0026lt;=习惯的锅，由于没有运行过，仍然会进行安装 进行安装 可能还需要一些时间，顺便一提，在新版的NodeBB（1.7以后，也不算新啦！）中，可以使用： ./nodebb install 进行可视化安装，也就是在服务器上面进入 http://127.0.0.1:4567 进行安装，和普通的PHP博客论坛什么的差不多，很简单！ GOOGLE字体库全责！ 再次成功翻车！ 无奈挂VPN 这个就是安装完成了，需要你输入一些信息 第一个URL used... 如果有相要对外开放，请输入实际使用的域名:端口（4567），如果使用的不是这里设置的域名，会出现 无法连接的现象 第二个是直接回车 第三个我们安装的数据库是redis，熟入redis即可 然后是前面设置的数据库密码（LINUX输入密码不会显示任何东西！） 管理员用户名和密码 完成设置 NODEBB基础搭建完成！ ","date":"2018-06-22T23:47:33+08:00","permalink":"https://blog.gaein.cn/passages/install-nodebb-on-ubuntu/","title":"在Ubuntu上搭建现代化的论坛Nodebb|NodeBB安装记录（Linux-Ubuntu篇）"}]